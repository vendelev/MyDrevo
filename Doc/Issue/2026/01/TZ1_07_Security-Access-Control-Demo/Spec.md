# Спецификация бизнес-требований TZ1_07

## Метаинформация

- **Номер задачи:** TZ1_07
- **Эпик:** TZ1 — Веб-сайт семейного генеалогического древа
- **Этап:** Stage 7 — Безопасность, права доступа и готовность к демонстрации
- **Дата создания:** 2026-01-24
- **Статус:** Черновик

## Описание проблемы/потребности

### Контекст

После реализации этапов 1-6 проект имеет:

- Готовую схему базы данных SQLite с данными генеалогического древа (этап 1)
- Доменную модель Person, Name, Surname, Relation с репозиториями (этап 2)
- Интерфейс просмотра персон с многоязычными данными (этап 3)
- Управление персонами: создание, редактирование, удаление (этап 4)
- Управление связями между персонами с валидацией (этап 5)
- Визуализацию генеалогического древа в формате SVG (этап 6)

Текущее состояние:

- Все функциональные возможности работают для одного тестового пользователя
- Отсутствует авторизация и аутентификация пользователей
- Нет разграничения доступа к данным между пользователями
- Нельзя гарантировать безопасность персональных данных
- Продукт не готов к демонстрации реальным пользователям
- Отсутствуют инструменты для быстрой подготовки демонстрационных данных

### Проблема

**КРИТИЧНО:** Без системы авторизации и разграничения доступа продукт небезопасен и не готов к использованию:

1. **Отсутствие авторизации:** Любой пользователь может просматривать и изменять любые данные
2. **Нет изоляции данных:** Пользователи видят генеалогические деревья друг друга
3. **Невозможность демонстрации:** Стейкхолдеры не могут увидеть работающую систему с реальными сценариями
4. **Риск утечки данных:** Персональные данные (даты рождения, связи) доступны всем
5. **Нет ролевой модели:** Невозможно предоставить администратору расширенные возможности
6. **Отсутствие инструментов подготовки данных:** Нет способа быстро создать демо-окружение
7. **Невозможность проверки прав:** На все операции отсутствует authorization

### Бизнес-ценность решения

Реализация безопасности и авторизации обеспечит:

- **Защиту данных:** Каждый пользователь видит только свои персоны и связи
- **Готовность к демонстрации:** Стейкхолдеры смогут увидеть полноценный продукт
- **Базовую безопасность:** Защита от несанкционированного доступа
- **Административные возможности:** Суперпользователь может видеть все данные для поддержки
- **Удобство тестирования:** Команда reset-data позволяет быстро пересоздать тестовое окружение
- **Законченный MVP:** Продукт становится минимально жизнеспособным и демонстрируемым
- **Основу для масштабирования:** Система авторизации — фундамент для будущего роста

## Функциональные требования

### FR-1. Базовая авторизация с использованием email

**Приоритет:** Критический

**Описание:**
Система должна предоставлять возможность входа пользователей с использованием email в качестве идентификатора.

**Детализация:**

#### FR-1.1. Модель пользователя

**Требования:**

- Таблица `users` с полями:
  - `id: int` — уникальный идентификатор
  - `email: string` — email пользователя (уникальный)
  - `password_hash: string` — хешированный пароль
  - `role: string` — роль пользователя ('user' или 'admin')
  - `created_at: datetime` — дата создания
  - `updated_at: datetime` — дата обновления

**Требования к безопасности:**

- Пароли должны храниться в хешированном виде (bcrypt, cost=10)
- Email должен быть уникальным (индекс UNIQUE)
- Минимальная длина пароля: 6 символов
- Пароль не должен храниться в открытом виде нигде в системе

#### FR-1.2. Страница входа

**Требования:**

- Маршрут: `GET /login`
- Форма входа с полями:
  - Email (type="email", required)
  - Пароль (type="password", required)
  - Кнопка "Войти"
- Использование CSRF-токена (обязательно)
- При успешном входе — переход на главную страницу (`/`)
- При ошибке — сообщение "Неверный email или пароль"

**Требования к сессиям:**

- Использовать Laravel session middleware
- Сессия должна сохраняться после закрытия браузера (remember token)
- Время жизни сессии: 120 минут по умолчанию

#### FR-1.3. Обработка входа

**Endpoint:** `POST /login`

**Request body:**

```php
[
  'email' => 'user(at)example.com',
  'password' => 'password123'
]
```

**Логика обработки:**

1. Валидация входных данных (email формат, пароль не пустой)
2. Поиск пользователя по email
3. Проверка пароля (password_verify)
4. Если успешно:
   - Создать сессию
   - Сохранить user_id в сессии
   - Redirect на `/`
5. Если ошибка:
   - Показать сообщение "Неверный email или пароль"
   - Не указывать, что именно неверно (безопасность)

**Критерии приемки FR-1:**

- ✅ Создана таблица `users` с необходимыми полями
- ✅ Email пользователя уникален (индекс UNIQUE)
- ✅ Пароли хранятся в хешированном виде (bcrypt)
- ✅ Реализована страница входа `/login`
- ✅ Форма входа защищена CSRF-токеном
- ✅ Успешный вход создает сессию и переводит на главную
- ✅ Неверные credentials показывают понятное сообщение
- ✅ Время жизни сессии настроено корректно

---

### FR-2. Выход из системы

**Приоритет:** Высокий

**Описание:**
Пользователь должен иметь возможность завершить сессию (выйти из системы).

**Детализация:**

#### FR-2.1. Кнопка выхода

**Требования:**

- Кнопка "Выйти" должна быть доступна на всех страницах авторизованного пользователя
- Расположение: в шапке сайта (header) справа
- Рядом с кнопкой отображать email текущего пользователя

#### FR-2.2. Обработка выхода

**Endpoint:** `POST /logout`

**Логика:**

1. Удалить сессию пользователя
2. Очистить куки сессии
3. Redirect на `/login`

**Требования:**

- Маршрут защищен CSRF-токеном
- После выхода пользователь не может получить доступ к защищенным страницам

**Критерии приемки FR-2:**

- ✅ Кнопка "Выйти" доступна на всех страницах
- ✅ Email текущего пользователя отображается в шапке
- ✅ POST /logout завершает сессию
- ✅ После выхода редирект на /login
- ✅ После выхода доступ к защищенным страницам запрещен
- ✅ Маршрут защищен CSRF-токеном

---

### FR-3. Разграничение доступа к данным по пользователям

**Приоритет:** Критический

**Описание:**
Система должна гарантировать, что пользователь видит только свои персоны и связи.

**Детализация:**

#### FR-3.1. Привязка данных к пользователю

**Требования:**

- Таблица `gen_person` должна иметь поле `user_id: int`
- Foreign key на `users.id`
- При создании персоны автоматически устанавливается `user_id` текущего пользователя
- Пользователь НЕ может изменить `user_id` своих персон

**Требования к миграции:**

- Добавить поле `user_id` в таблицу `gen_person`
- Создать индекс на `user_id` для производительности
- Для существующих персон установить `user_id = 1` (тестовый пользователь)

#### FR-3.2. Фильтрация данных по user_id

**Требования:**

Все запросы к данным должны фильтроваться по `user_id`:

- **Список персон** (`GET /persons`):
  - Показывать только персоны текущего пользователя
  - SQL: `WHERE user_id = :current_user_id`

- **Карточка персоны** (`GET /persons/{id}`):
  - Проверять, что `person.user_id == current_user_id`
  - Если нет — показать "Доступ запрещен" (403)

- **Создание персоны** (`POST /persons`):
  - Автоматически устанавливать `user_id = current_user_id`
  - Пользователь НЕ может указать другой `user_id`

- **Редактирование персоны** (`PUT /persons/{id}`):
  - Проверять, что `person.user_id == current_user_id`
  - Если нет — возвращать ошибку 403

- **Удаление персоны** (`DELETE /persons/{id}`):
  - Проверять, что `person.user_id == current_user_id`
  - Если нет — возвращать ошибку 403

- **Создание связи** (`POST /relations`):
  - Проверять, что обе персоны принадлежат текущему пользователю
  - Если нет — возвращать ошибку 403

- **Удаление связи** (`DELETE /relations/{id}`):
  - Проверять, что обе персоны в связи принадлежат текущему пользователю
  - Если нет — возвращать ошибку 403

- **Визуализация дерева** (`GET /tree`):
  - Показывать только персоны текущего пользователя
  - Если `?personId={id}` указывает на чужую персону — показать корень своего дерева с сообщением "Доступ запрещен"

#### FR-3.3. Защита от прямых ссылок

**Требования:**

- Пользователь НЕ должен получить доступ к чужим данным через URL
- Примеры атак:
  - `GET /persons/999` (чужая персона) → 403 Forbidden
  - `GET /tree?personId=999` (чужая персона) → показать свое дерево + сообщение
  - `POST /relations` с чужой персоной → 403 Forbidden

**Сообщения об ошибках:**

- "Доступ запрещен" — для страниц (403 Forbidden)
- "Нет доступа к этой персоне" — для API (JSON response)

**Критерии приемки FR-3:**

- ✅ Таблица `gen_person` имеет поле `user_id`
- ✅ Foreign key на `users.id` создан
- ✅ Индекс на `user_id` создан
- ✅ Все запросы фильтруются по `user_id`
- ✅ Попытка доступа к чужой персоне возвращает 403
- ✅ Попытка создать связь с чужой персоной возвращает 403
- ✅ Прямые ссылки на чужие данные не работают
- ✅ Сообщения об ошибках понятны

---

### FR-4. Контроль прав на все операции (authorization)

**Приоритет:** Критический

**Описание:**
Для каждой операции должна выполняться проверка прав доступа.

**Детализация:**

#### FR-4.1. Middleware для проверки авторизации

**Требования:**

- Создать middleware `Authenticate` для проверки наличия сессии
- Применить middleware ко всем маршрутам кроме `/login`
- Если пользователь не авторизован — redirect на `/login`

**Маршруты:**

```php
// Публичные (без middleware)
GET  /login
POST /login

// Защищенные (с middleware)
POST /logout
GET  /
GET  /persons
GET  /persons/{id}
POST /persons
PUT  /persons/{id}
DELETE /persons/{id}
GET  /relations
POST /relations
DELETE /relations/{id}
GET  /tree
```

#### FR-4.2. Проверка прав на уровне Use Case

**Требования:**

Каждый Use Case должен проверять права перед выполнением операции:

- **ViewPersonUseCase:**
  - Проверить, что `person.user_id == current_user_id`
  - Если нет — бросить `AccessDeniedException`

- **CreatePersonUseCase:**
  - Установить `user_id = current_user_id` автоматически

- **UpdatePersonUseCase:**
  - Проверить, что `person.user_id == current_user_id`
  - Если нет — бросить `AccessDeniedException`

- **DeletePersonUseCase:**
  - Проверить, что `person.user_id == current_user_id`
  - Если нет — бросить `AccessDeniedException`

- **CreateRelationUseCase:**
  - Проверить, что обе персоны принадлежат `current_user_id`
  - Если нет — бросить `AccessDeniedException`

- **DeleteRelationUseCase:**
  - Проверить, что обе персоны в связи принадлежат `current_user_id`
  - Если нет — бросить `AccessDeniedException`

- **ViewTreeUseCase:**
  - Фильтровать персоны по `user_id == current_user_id`
  - Если `personId` чужой — использовать корень своего дерева

#### FR-4.3. Обработка ошибок доступа

**Требования:**

- `AccessDeniedException` в контроллере перехватывается
- Для web-страниц: показать страницу "Доступ запрещен" (шаблон Blade)
- Для API: вернуть JSON `{"success": false, "error": "Нет доступа"}`
- HTTP статус: 403 Forbidden

**Критерии приемки FR-4:**

- ✅ Middleware `Authenticate` применен ко всем защищенным маршрутам
- ✅ Неавторизованный пользователь перенаправляется на `/login`
- ✅ Все Use Cases проверяют права доступа
- ✅ AccessDeniedException обрабатывается корректно
- ✅ Страница "Доступ запрещен" отображается понятно
- ✅ API возвращает корректный JSON при ошибке доступа
- ✅ HTTP статус 403 для всех запретов доступа

---

### FR-5. Суперпользователь с ролью admin

**Приоритет:** Высокий

**Описание:**
Суперпользователь должен видеть все данные всех пользователей без фильтрации по `user_id`.

**Детализация:**

#### FR-5.1. Определение роли admin

**Требования:**

- Поле `users.role` может иметь значения:
  - `'user'` — обычный пользователь (по умолчанию)
  - `'admin'` — суперпользователь

**Назначение роли:**

- При создании пользователя через команду reset-data можно указать роль
- Назначение роли вручную через прямое изменение БД (на этапе 7 нет UI для управления ролями)
- Пример: `UPDATE users SET role = 'admin' WHERE email = 'admin@example.com'`

#### FR-5.2. Логика работы для admin

**Требования:**

Если `current_user.role == 'admin'`:

- **Список персон** (`GET /persons`):
  - Показывать ВСЕ персоны без фильтрации по `user_id`
  - Отображать владельца каждой персоны (email или user_id)

- **Карточка персоны** (`GET /persons/{id}`):
  - Показывать ЛЮБУЮ персону (игнорировать проверку `user_id`)

- **Создание персоны** (`POST /persons`):
  - Admin может создавать персоны от своего имени (`user_id = admin_id`)

- **Редактирование персоны** (`PUT /persons/{id}`):
  - Admin может редактировать ЛЮБУЮ персону

- **Удаление персоны** (`DELETE /persons/{id}`):
  - Admin может удалять ЛЮБУЮ персону

- **Создание связи** (`POST /relations`):
  - Admin может создавать связи между ЛЮБЫМИ персонами

- **Удаление связи** (`DELETE /relations/{id}`):
  - Admin может удалять ЛЮБЫЕ связи

- **Визуализация дерева** (`GET /tree`):
  - Admin видит все деревья всех пользователей
  - Если `?personId={id}` указан — показать дерево владельца этой персоны

#### FR-5.3. Индикация режима admin

**Требования:**

- В шапке сайта для admin отображать бейдж "ADMIN"
- При просмотре чужих данных показывать владельца (email пользователя)
- Например: "Персона: Иван Петров (владелец: `user@example.com`)"

**Критерии приемки FR-5:**

- ✅ Поле `users.role` поддерживает значения 'user' и 'admin'
- ✅ Admin видит все персоны всех пользователей
- ✅ Admin может редактировать и удалять любые персоны
- ✅ Admin может создавать связи между любыми персонами
- ✅ Admin может просматривать любые деревья
- ✅ В UI отображается бейдж "ADMIN"
- ✅ При просмотре чужих данных отображается владелец
- ✅ Обычные пользователи видят только свои данные

---

### FR-6. Web-интерфейс на Blade с CSRF и сессиями

**Приоритет:** Критический

**Описание:**
Web-интерфейс должен использовать Blade-шаблоны с обязательным использованием CSRF-защиты и сессий.

**Детализация:**

#### FR-6.1. Использование Blade-шаблонов

**Требования:**

- Все страницы рендерятся через Blade
- Использовать layout с общим header/footer
- Header содержит:
  - Название сайта
  - Навигационное меню
  - Email пользователя
  - Кнопку "Выйти"
  - Бейдж "ADMIN" (если admin)

**Структура шаблонов:**

```text
{ModuleName}/Presentation/Http/View/
├── layout/
│   └── app.blade.php          (Общий layout)
├── auth/
│   └── login.blade.php        (Страница входа)
├── persons/
│   ├── index.blade.php        (Список персон)
│   ├── show.blade.php         (Карточка персоны)
│   ├── create.blade.php       (Создание персоны)
│   └── edit.blade.php         (Редактирование персоны)
├── tree/
│   └── show.blade.php         (Визуализация дерева)
└── errors/
    ├── 403.blade.php          (Доступ запрещен)
    └── 404.blade.php          (Не найдено)
```

#### FR-6.2. CSRF-защита

**Требования:**

- Все формы должны содержать CSRF-токен: `@csrf`
- CSRF middleware должен быть включен в `VerifyCsrfToken`
- При отсутствии токена — ошибка 419 (CSRF token mismatch)

**Пример формы:**

```blade
<form method="POST" action="/login">
    @csrf
    <input type="email" name="email" required>
    <input type="password" name="password" required>
    <button type="submit">Войти</button>
</form>
```

#### FR-6.3. Сессии

**Требования:**

- Использовать Laravel session driver (по умолчанию: file)
- Сессия должна содержать:
  - `user_id` — идентификатор пользователя
  - `_token` — CSRF-токен
- Конфигурация сессии в `.env`:
  - `SESSION_DRIVER=file`
  - `SESSION_LIFETIME=120` (минуты)

**Критерии приемки FR-6:**

- ✅ Все страницы рендерятся через Blade-шаблоны
- ✅ Общий layout с header/footer используется
- ✅ Header содержит email, кнопку "Выйти", бейдж "ADMIN"
- ✅ Все формы защищены CSRF-токеном
- ✅ CSRF middleware включен
- ✅ Сессии работают корректно
- ✅ Конфигурация сессии в `.env` настроена

---

### FR-7. Artisan-команда reset-data

**Приоритет:** Высокий

**Описание:**
Система должна иметь artisan-команду для сброса всех данных и создания тестового пользователя.

**Детализация:**

#### FR-7.1. Команда reset-data

**Название:** `php artisan app:reset-data`

**Описание:**
Удаляет все данные из БД и создает тестового пользователя с демонстрационными данными.

**Алгоритм:**

1. Удалить все записи из таблиц:
   - `gen_relation`
   - `gen_person_name`
   - `gen_person_surname`
   - `gen_person`
   - `users`

2. Создать тестового пользователя:
   - Email: `test@example.com`
   - Пароль: `password`
   - Роль: `user`

3. Создать администратора:
   - Email: `admin@example.com`
   - Пароль: `password`
   - Роль: `admin`

4. Создать тестовые персоны для пользователя `test@example.com`:
   - Иван Петрович Сидоров (1950-05-10)
   - Мария Ивановна Сидорова (1955-08-15)
   - Анна Петровна Иванова (1975-03-20)
   - Петр Алексеевич Иванов (1970-11-30)
   - Ольга Петровна Сидорова (1995-06-12)

5. Создать тестовые связи:
   - Иван ← родитель → Анна
   - Мария ← родитель → Анна
   - Анна ← супруг → Петр
   - Анна ← родитель → Ольга
   - Петр ← родитель → Ольга

**Требования к команде:**

- Команда должна запрашивать подтверждение: "Удалить все данные? (yes/no)"
- Если ответ не "yes" — отменить выполнение
- Использовать транзакцию для атомарности
- Выводить прогресс выполнения в консоль
- После успешного выполнения вывести:
  - "Данные сброшены"
  - "Создано пользователей: 2"
  - "Создано персон: 5"
  - "Создано связей: 10" (включая обратные)

#### FR-7.2. Использование команды для демонстрации

**Сценарий:**

1. Запустить `php artisan app:reset-data`
2. Подтвердить: `yes`
3. Войти как `test@example.com` / `password`
4. Увидеть список из 5 персон
5. Перейти к визуализации дерева
6. Увидеть 3 поколения с родителями, детьми, супругами

**Критерии приемки FR-7:**

- ✅ Команда `php artisan app:reset-data` создана
- ✅ Команда запрашивает подтверждение
- ✅ Команда удаляет все данные из таблиц
- ✅ Создаются 2 пользователя (test, admin)
- ✅ Создаются 5 тестовых персон для test
- ✅ Создаются связи между персонами
- ✅ Команда использует транзакцию
- ✅ Прогресс выводится в консоль
- ✅ После выполнения можно войти и увидеть данные

---

### FR-8. Базовые страницы и сообщения

**Приоритет:** Средний

**Описание:**
Система должна иметь базовые страницы для понятных сообщений пользователю.

**Детализация:**

#### FR-8.1. Страница "Нет данных"

**Маршрут:** Встроена в существующие страницы

**Требования:**

- Если у пользователя нет персон:
  - Показать сообщение: "У вас пока нет персон в древе"
  - Кнопку "Создать первую персону" → `/persons/create`

- Если у персоны нет связей:
  - Показать сообщение: "У этой персоны пока нет связей"
  - Кнопку "Добавить связь"

- Если дерево пустое:
  - Показать сообщение: "Древо пусто. Создайте первую персону, чтобы начать."
  - Кнопку "Создать персону"

#### FR-8.2. Страница "Доступ запрещен"

**Маршрут:** `/errors/403.blade.php`

**Требования:**

- Заголовок: "Доступ запрещен"
- Текст: "У вас нет доступа к этой странице или данным."
- Кнопка "На главную" → `/`
- HTTP статус: 403

#### FR-8.3. Страница "Не найдено"

**Маршрут:** `/errors/404.blade.php`

**Требования:**

- Заголовок: "Страница не найдена"
- Текст: "Запрашиваемая страница не существует."
- Кнопка "На главную" → `/`
- HTTP статус: 404

**Критерии приемки FR-8:**

- ✅ Сообщение "Нет данных" отображается корректно
- ✅ Кнопка "Создать персону" работает
- ✅ Страница 403 отображается при отказе доступа
- ✅ Страница 404 отображается при несуществующем маршруте
- ✅ Все сообщения понятны пользователю
- ✅ Кнопки навигации работают

---

## Нефункциональные требования

### NFR-1. Безопасность

**Описание:**
Система должна обеспечивать базовую защиту от типовых угроз.

**Критерии:**

- **Хранение паролей:**
  - Bcrypt с cost=10
  - Никогда не хранить пароли в открытом виде
  - Никогда не логировать пароли

- **CSRF-защита:**
  - Все формы должны содержать CSRF-токен
  - Middleware `VerifyCsrfToken` включен

- **SQL Injection:**
  - Использовать Eloquent ORM для всех запросов
  - Никогда не использовать прямые SQL-запросы с конкатенацией

- **XSS-защита:**
  - Экранировать все пользовательские данные в Blade (автоматически через `{{ }}`)
  - Никогда не использовать `{!! !!}` для пользовательских данных

- **Session Hijacking:**
  - Использовать HTTPS в production (на этапе 7 — HTTP для локальной разработки)
  - Регенерация session ID после входа

**Проверка:**

- Попытка SQL Injection в поле email → не работает
- Попытка XSS в поле имени персоны → экранируется
- Попытка CSRF-атаки без токена → ошибка 419

---

### NFR-2. Usability

**Описание:**
Интерфейс должен быть понятным и удобным.

**Критерии:**

- Сообщения об ошибках понятны нетехническому пользователю
- Формы содержат подсказки (placeholder)
- Кнопки имеют понятные названия ("Войти", "Выйти", "Создать")
- Навигация интуитивна (меню в шапке)
- Обратная связь после действий (например, "Персона создана")

**Проверка:**

- Пользовательское тестирование: пользователь может войти и создать персону без инструкции

---

### NFR-3. Производительность

**Описание:**
Авторизация не должна замедлять работу системы.

**Критерии:**

- Вход пользователя: < 200ms
- Проверка прав доступа: < 10ms (встроена в Use Case)
- Загрузка списка персон (100 записей): < 500ms

**Проверка:**

- Измерить время входа на тестовых данных
- Проверить количество SQL-запросов (не более 5 для списка персон)

---

### NFR-4. Поддерживаемость

**Описание:**
Код должен быть простым и расширяемым.

**Критерии:**

- Логика авторизации изолирована в middleware и Use Cases
- Проверка прав вынесена в отдельные методы (например, `checkAccess()`)
- Код следует принципам Clean Architecture
- Легко добавить новые роли в будущем

**Проверка:**

- Code review
- Соответствие стилю проекта (.ai/Rule/CodeStyle.md)
- Статический анализ PHPStan

---

## Модель предметной области

### Основные Entity

#### User (Пользователь)

**Описание:** Пользователь системы с авторизацией.

**Атрибуты:**

- `id: int` — уникальный идентификатор
- `email: string` — email (уникальный)
- `passwordHash: string` — хешированный пароль
- `role: UserRole` — роль пользователя
- `createdAt: DateTime` — дата создания
- `updatedAt: DateTime` — дата обновления

**Методы:**

- `verifyPassword(string $password): bool` — проверка пароля
- `isAdmin(): bool` — проверка роли admin
- `canAccess(Person $person): bool` — может ли пользователь получить доступ к персоне

---

### Enumerations

#### UserRole (Роль пользователя)

**Значения:**

- `USER` — обычный пользователь (по умолчанию)
- `ADMIN` — суперпользователь

**Методы:**

- `toCode(): string` — преобразование в код БД ('user', 'admin')
- `fromCode(string $code): UserRole` — создание из кода БД

---

### Services

#### AuthenticationService (Сервис авторизации)

**Описание:** Бизнес-логика для входа и выхода пользователей.

**Методы:**

- `login(string $email, string $password): User` — вход пользователя
- `logout(): void` — выход пользователя
- `getCurrentUser(): ?User` — получить текущего пользователя
- `isAuthenticated(): bool` — проверка авторизации

---

#### AuthorizationService (Сервис проверки прав)

**Описание:** Бизнес-логика для проверки прав доступа.

**Методы:**

- `canViewPerson(User $user, Person $person): bool` — может ли пользователь просмотреть персону
- `canEditPerson(User $user, Person $person): bool` — может ли пользователь редактировать персону
- `canDeletePerson(User $user, Person $person): bool` — может ли пользователь удалить персону
- `canCreateRelation(User $user, Person $person1, Person $person2): bool` — может ли пользователь создать связь

---

## Зависимости

### Внешние зависимости

- **Laravel 12** — фреймворк для авторизации, middleware, Blade
- **PHP 8.5** — язык программирования
- **SQLite** — СУБД для хранения пользователей и данных

### Внутренние зависимости

Этап 7 **зависит** от:

- **Этап 1 (TZ1_01)** — требует готовую схему БД
- **Этап 2 (TZ1_02)** — требует доменную модель Person, Relation
- **Этап 3 (TZ1_03)** — требует UI для просмотра персон
- **Этап 4 (TZ1_04)** — требует UI для управления персонами
- **Этап 5 (TZ1_05)** — требует управление связями
- **Этап 6 (TZ1_06)** — требует визуализацию дерева

Этап 7 **является блокирующим** для:

- **Будущие этапы** — Мультипользовательская работа, расширенные права, регистрация

---

## Сценарии использования

### UC-1. Пользователь входит и видит свое дерево

**Актор:** Пользователь

**Предусловия:**

- В БД есть пользователь `test@example.com` с паролем `password`
- У пользователя есть 5 персон с связями

**Основной сценарий:**

1. Пользователь открывает сайт
2. Перенаправляется на `/login` (не авторизован)
3. Вводит email: `test@example.com`
4. Вводит пароль: `password`
5. Нажимает "Войти"
6. Система:
   - Проверяет email и пароль
   - Создает сессию
   - Перенаправляет на `/`
7. Главная страница отображает:
   - Header с email пользователя
   - Кнопку "Выйти"
   - Список персон (5 штук)
8. Пользователь переходит к `/tree`
9. Видит визуализацию своего дерева (5 персон с связями)

**Постусловия:**

- Пользователь авторизован
- Видит только свои данные
- Может навигировать по сайту

---

### UC-2. Пользователь пытается открыть чужую персону

**Актор:** Пользователь

**Предусловия:**

- Пользователь `test@example.com` авторизован
- Существует персона с ID=999, принадлежащая другому пользователю

**Основной сценарий:**

1. Пользователь вставляет в браузер URL: `/persons/999`
2. Система:
   - Загружает персону с ID=999
   - Проверяет: `person.user_id == current_user.id`
   - Проверка не пройдена (чужая персона)
   - Бросает `AccessDeniedException`
3. Контроллер перехватывает исключение
4. Отображает страницу "Доступ запрещен" (403)
5. Пользователь видит:
   - Заголовок: "Доступ запрещен"
   - Текст: "У вас нет доступа к этой странице или данным."
   - Кнопку "На главную"

**Постусловия:**

- Пользователь НЕ увидел чужие данные
- Понятно, что доступ запрещен
- Может вернуться на главную

---

### UC-3. Администратор просматривает все данные

**Актор:** Администратор

**Предусловия:**

- Пользователь `admin@example.com` с ролью `admin` авторизован
- В системе есть 2 пользователя с персонами

**Основной сценарий:**

1. Admin входит в систему
2. В header отображается:
   - Email: `admin@example.com`
   - Бейдж: "ADMIN"
3. Переходит на `/persons`
4. Видит ВСЕ персоны всех пользователей (10 штук)
5. Для каждой персоны отображается владелец:
   - "Иван Петров (владелец: `test@example.com`)"
   - "Анна Сидорова (владелец: `user2@example.com`)"
6. Кликает на персону другого пользователя
7. Система:
   - Проверяет: `current_user.role == 'admin'`
   - Разрешает доступ (игнорирует проверку `user_id`)
8. Admin видит карточку чужой персоны
9. Может редактировать и удалять любые данные

**Постусловия:**

- Admin видит все данные
- Может управлять любыми персонами
- Понятно, кто владелец данных

---

### UC-4. Подготовка демонстрационных данных

**Актор:** Разработчик / Администратор

**Предусловия:**

- БД может содержать устаревшие тестовые данные

**Основной сценарий:**

1. Разработчик запускает команду: `php artisan app:reset-data`
2. Команда запрашивает: "Удалить все данные? (yes/no)"
3. Разработчик вводит: `yes`
4. Команда:
   - Удаляет все записи из таблиц
   - Создает пользователя `test@example.com`
   - Создает администратора `admin@example.com`
   - Создает 5 персон для test
   - Создает связи между персонами
5. Выводит в консоль:

   ```text
   Данные сброшены
   Создано пользователей: 2
   Создано персон: 5
   Создано связей: 10
   ```

6. Разработчик открывает браузер
7. Входит как `test@example.com` / `password`
8. Видит список из 5 персон
9. Переходит к `/tree`
10. Видит дерево с 3 поколениями

**Постусловия:**

- БД содержит свежие демонстрационные данные
- Можно сразу показать продукт стейкхолдерам

---

### UC-5. Стейкхолдер оценивает готовый продукт

**Актор:** Стейкхолдер (заказчик/куратор)

**Предусловия:**

- Команда `reset-data` выполнена
- БД содержит демонстрационные данные

**Основной сценарий:**

1. Стейкхолдер открывает сайт
2. Видит страницу входа
3. Вводит: `test@example.com` / `password`
4. Входит в систему
5. Проверяет:
   - ✅ Список персон отображается (5 штук)
   - ✅ Может открыть карточку персоны
   - ✅ Видит связи (родители, дети, супруги)
   - ✅ Может перейти к связанной персоне
6. Переходит к визуализации дерева (`/tree`)
7. Проверяет:
   - ✅ Дерево отображается графически
   - ✅ Видны 3 поколения
   - ✅ Связи между персонами понятны
   - ✅ Может кликать по узлам и перестраивать дерево
8. Пробует создать новую персону
9. Проверяет:
   - ✅ Форма создания работает
   - ✅ Новая персона отображается в списке
10. Пробует создать связь
11. Проверяет:
    - ✅ Форма создания связи работает
    - ✅ Связь отображается в карточке
12. Выходит из системы
13. Проверяет:
    - ✅ После выхода не может получить доступ к данным
    - ✅ Перенаправляется на `/login`
14. Одобряет продукт как готовый к использованию

**Постусловия:**

- Стейкхолдер получил демонстрируемый MVP
- Подтверждена готовность продукта к использованию
- Одобрен переход к следующим этапам

---

## Риски

### Риск 1. Сложность интеграции авторизации с существующим кодом

**Описание:**
Добавление авторизации в существующие Use Cases может потребовать значительных изменений кода.

**Вероятность:** Средняя

**Влияние:** Среднее (трудоемкость реализации)

**Меры снижения:**

- Централизовать проверку прав в AuthorizationService
- Добавить метод `checkAccess()` в базовый класс Use Case
- Использовать middleware для базовой проверки авторизации
- Тестировать каждый Use Case после добавления проверок

**План реагирования:**

- Если интеграция сложная — создать wrapper-методы в репозиториях для автоматической фильтрации
- Добавить scope в Eloquent для фильтрации по `user_id`

---

### Риск 2. Забыть добавить проверку прав в новом Use Case

**Описание:**
При добавлении новых Use Cases разработчик может забыть добавить проверку прав.

**Вероятность:** Средняя

**Влияние:** Критическое (уязвимость безопасности)

**Меры снижения:**

- Создать базовый класс `AuthorizedUseCase` с обязательной проверкой
- Добавить тесты на проверку прав для всех Use Cases
- Провести security review кода
- Документировать обязательность проверки прав в `.ai/Rule/CodeHints.md`

**План реагирования:**

- Если обнаружена уязвимость — немедленно исправить
- Добавить автоматическую проверку прав в CI/CD (PHPStan rule)

---

### Риск 3. Производительность фильтрации по user_id

**Описание:**
Фильтрация всех запросов по `user_id` может замедлить работу системы.

**Вероятность:** Низкая

**Влияние:** Среднее (медленная загрузка)

**Меры снижения:**

- Создать индекс на поле `user_id`
- Использовать Eloquent scope для автоматической фильтрации
- Измерить производительность на тестовых данных (1000+ персон)

**План реагирования:**

- Если обнаружена медленная загрузка — оптимизировать запросы
- Использовать композитные индексы (user_id + id)

---

### Риск 4. Усложнение UI для admin

**Описание:**
Интерфейс для admin может стать сложным из-за отображения владельцев данных.

**Вероятность:** Низкая

**Влияние:** Низкое (неудобство использования)

**Меры снижения:**

- Сделать отображение владельца опциональным (показывать только для admin)
- Добавить фильтр по владельцу на странице списка персон
- Провести пользовательское тестирование с admin

**План реагирования:**

- Если UI сложный — упростить отображение (например, показывать владельца только при hover)

---

### Риск 5. Безопасность хранения паролей

**Описание:**
Неправильное хранение паролей может привести к утечке данных.

**Вероятность:** Низкая (Laravel использует bcrypt по умолчанию)

**Влияние:** Критическое (утечка паролей)

**Меры снижения:**

- Использовать Laravel Hash facade для хеширования
- Никогда не хранить пароли в открытом виде
- Никогда не логировать пароли
- Провести security review кода

**План реагирования:**

- Если обнаружена уязвимость — немедленно исправить
- Провести пентест

---

## Критерии приемки

### Критерии приемки этапа

Этап считается завершенным, если выполнены **все** следующие критерии:

#### Критерии по авторизации

- ✅ Создана таблица `users` с полями id, email, password_hash, role
- ✅ Email пользователя уникален
- ✅ Пароли хранятся в хешированном виде (bcrypt)
- ✅ Реализована страница входа `/login`
- ✅ Форма входа защищена CSRF-токеном
- ✅ Успешный вход создает сессию
- ✅ Неверные credentials показывают понятное сообщение
- ✅ Реализован выход `/logout`
- ✅ После выхода доступ к защищенным страницам запрещен

#### Критерии по разграничению доступа

- ✅ Таблица `gen_person` имеет поле `user_id`
- ✅ Foreign key на `users.id` создан
- ✅ Индекс на `user_id` создан
- ✅ Все запросы фильтруются по `user_id`
- ✅ Попытка доступа к чужой персоне возвращает 403
- ✅ Попытка создать связь с чужой персоной возвращает 403
- ✅ Прямые ссылки на чужие данные не работают

#### Критерии по проверке прав

- ✅ Middleware `Authenticate` применен ко всем защищенным маршрутам
- ✅ Неавторизованный пользователь перенаправляется на `/login`
- ✅ Все Use Cases проверяют права доступа
- ✅ AccessDeniedException обрабатывается корректно
- ✅ Страница "Доступ запрещен" отображается
- ✅ HTTP статус 403 для всех запретов доступа

#### Критерии по роли admin

- ✅ Поле `users.role` поддерживает 'user' и 'admin'
- ✅ Admin видит все персоны всех пользователей
- ✅ Admin может редактировать любые персоны
- ✅ Admin может создавать связи между любыми персонами
- ✅ В UI отображается бейдж "ADMIN"
- ✅ При просмотре чужих данных отображается владелец
- ✅ Обычные пользователи видят только свои данные

#### Критерии по web-интерфейсу

- ✅ Все страницы рендерятся через Blade
- ✅ Общий layout с header/footer используется
- ✅ Header содержит email, кнопку "Выйти", бейдж "ADMIN"
- ✅ Все формы защищены CSRF-токеном
- ✅ Сессии работают корректно

#### Критерии по команде reset-data

- ✅ Команда `php artisan app:reset-data` создана
- ✅ Команда запрашивает подтверждение
- ✅ Команда удаляет все данные
- ✅ Создаются 2 пользователя (test, admin)
- ✅ Создаются 5 тестовых персон
- ✅ Создаются связи между персонами
- ✅ После выполнения можно войти и увидеть данные

#### Критерии по базовым страницам

- ✅ Сообщение "Нет данных" отображается корректно
- ✅ Страница 403 отображается при отказе доступа
- ✅ Страница 404 отображается при несуществующем маршруте
- ✅ Все сообщения понятны

#### Критерии по безопасности

- ✅ Пароли хранятся в хешированном виде
- ✅ CSRF-защита работает
- ✅ Экранирование пользовательских данных работает
- ✅ SQL Injection не работает
- ✅ XSS не работает

#### Критерии по тестам

- ✅ Написаны unit-тесты для AuthenticationService
- ✅ Написаны unit-тесты для AuthorizationService
- ✅ Написаны integration-тесты для входа/выхода
- ✅ Написаны E2E тесты для проверки прав доступа
- ✅ Тесты проверяют роль admin
- ✅ Тесты проверяют команду reset-data

#### Критерии по коду

- ✅ Код соответствует стилю проекта (.ai/Rule/CodeStyle.md)
- ✅ Код проходит статический анализ PHPStan уровня 8-9
- ✅ Код проходит проверку PHP_CodeSniffer
- ✅ Код следует принципам Clean Architecture

---

## Не входит в реализацию

Следующие функции **НЕ входят** в реализацию текущего этапа:

### Не входит в Stage 7

- ❌ **Регистрация новых пользователей** — будет добавлена в будущих этапах
- ❌ **Восстановление пароля** — будет добавлено в будущем
- ❌ **Email-подтверждение** — будет добавлено в будущем
- ❌ **Двухфакторная аутентификация** — будет добавлена в будущем
- ❌ **OAuth (Google, Facebook)** — будет добавлен в будущем
- ❌ **Расширенная ролевая модель** — будет добавлена в будущем (модератор, редактор и т.д.)
- ❌ **Логирование действий пользователей** — будет добавлено в будущем
- ❌ **Управление пользователями через UI** — будет добавлено в будущем
- ❌ **Квоты на количество персон** — будет добавлено в будущем
- ❌ **Экспорт/импорт данных** — будет добавлен в будущем
- ❌ **API-токены для внешних приложений** — будут добавлены в будущем

### Допущения текущего этапа

На текущем этапе допускаются следующие упрощения:

- ✅ **Только два пользователя создаются через команду** — регистрация отсутствует
- ✅ **Только две роли** — user и admin
- ✅ **HTTP в разработке** — HTTPS только в production
- ✅ **Базовая CSRF-защита** — без дополнительных мер (rate limiting и т.д.)
- ✅ **Простые сообщения об ошибках** — без детализации для безопасности
- ✅ **Нет логирования входов** — будет добавлено в будущем

---

## Дополнительные замечания

### Важные особенности реализации

1. **Email как идентификатор обязателен:** На этапе 7 не поддерживается username, только email.

2. **Проверка прав на уровне Use Case критична:** Middleware проверяет только авторизацию, но не authorization.

3. **Admin видит все данные без фильтрации:** Важно для поддержки и отладки.

4. **Команда reset-data обязательна для демонстрации:** Без неё невозможно быстро подготовить демо-окружение.

5. **CSRF-защита обязательна:** Все формы должны содержать токен.

### Рекомендации по реализации

1. **Начать с миграции users:** Создать таблицу и связать с gen_person.

2. **Реализовать AuthenticationService:** Централизовать логику входа/выхода.

3. **Добавить middleware:** Применить ко всем защищенным маршрутам.

4. **Обновить Use Cases:** Добавить проверку прав в каждый Use Case.

5. **Создать команду reset-data:** Протестировать на пустой БД.

6. **Провести security review:** Проверить все точки входа на уязвимости.

---

## Глоссарий

- **Авторизация (Authentication)** — процесс проверки личности пользователя (вход в систему)
- **Проверка прав (Authorization)** — процесс проверки прав доступа к ресурсам
- **CSRF (Cross-Site Request Forgery)** — атака, использующая доверие сайта к браузеру пользователя
- **Сессия (Session)** — механизм хранения состояния пользователя между запросами
- **Middleware** — промежуточное ПО для обработки HTTP-запросов
- **Bcrypt** — алгоритм хеширования паролей
- **HTTPS** — защищенный протокол HTTP с шифрованием
- **SQL Injection** — атака через внедрение SQL-кода
- **XSS (Cross-Site Scripting)** — атака через внедрение JavaScript-кода
- **Admin** — суперпользователь с расширенными правами
- **Blade** — шаблонизатор Laravel
- **Scope** — механизм Eloquent для переиспользуемых запросов
- **Foreign key** — внешний ключ для обеспечения целостности данных

---

## Конец спецификации TZ1_07
