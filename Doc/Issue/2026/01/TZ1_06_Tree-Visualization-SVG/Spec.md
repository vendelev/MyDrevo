# Спецификация бизнес-требований TZ1_06

## Метаинформация

- **Номер задачи:** TZ1_06
- **Эпик:** TZ1 — Веб-сайт семейного генеалогического древа
- **Этап:** Stage 6 — Минимальная визуализация дерева и улучшение UX
- **Дата создания:** 2026-01-23
- **Статус:** Черновик

## Описание проблемы/потребности

### Контекст

После реализации этапов 1-5 проект имеет:

- Готовую схему базы данных SQLite с данными генеалогического древа (этап 1)
- Доменную модель Person, Name, Surname, Relation с репозиториями (этап 2)
- Интерфейс просмотра персон с многоязычными данными (этап 3)
- Управление персонами: создание, редактирование, удаление (этап 4)
- Управление связями между персонами с валидацией (этап 5)

Текущее состояние:

- Пользователь может просматривать список персон в табличном виде
- Пользователь может создавать и редактировать персоны с многоязычными данными
- Пользователь может создавать связи между персонами (родители/дети/супруги)
- Связи отображаются в карточке персоны в виде текстового списка
- Пользователь может переходить по ссылкам от одной персоны к другой

### Проблема

**КРИТИЧНО:** Текущий интерфейс НЕ позволяет пользователю увидеть структуру генеалогического древа наглядно, потому что:

1. **Отсутствие визуализации древа:** Пользователь видит только списки персон и текстовые ссылки на родственников, но не видит структуру дерева целиком
2. **Сложность навигации:** Чтобы понять, как связаны несколько поколений, нужно открывать множество карточек и запоминать связи
3. **Нет общей картины:** Невозможно оценить размер дерева, количество поколений, ветви семьи
4. **Низкая наглядность:** Текстовые списки связей не дают понимания иерархии и структуры семьи
5. **Невозможность быстро найти родственников:** Нет возможности увидеть всех потомков или предков персоны одновременно
6. **Не демонстрируемый результат:** Генеалогическое древо без визуализации теряет свою основную ценность

### Бизнес-ценность решения

Реализация визуализации генеалогического древа обеспечит:

- **Наглядное представление данных:** Пользователь сможет увидеть структуру семьи графически
- **Интуитивную навигацию:** Переход между родственниками станет простым и очевидным (клик по узлу)
- **Быстрое понимание структуры:** Сразу видно количество поколений, размер семьи, ветви
- **Улучшенный UX:** Пользователь получает то, что ожидает от генеалогического древа — визуальную схему
- **Демонстрируемый результат:** Стейкхолдеры увидят полноценный продукт с визуальным представлением данных
- **Основу для расширения:** Визуализация станет базой для дальнейших улучшений (zoom, фильтры, экспорт)
- **Проверку корректности связей:** Визуально легче заметить ошибки в связях (циклы, несвязанные ветви)

## Функциональные требования

### FR-1. Страница визуализации дерева

**Приоритет:** Высокий

**Описание:**
Система должна предоставлять отдельную страницу с графической визуализацией генеалогического древа в формате SVG.

**Детализация:**

#### FR-1.1. Маршрут страницы дерева

Создать маршрут `GET /tree` с контроллером `TreeController@show`, который:

1. Получает текущий язык из `App::getLocale()`
2. Читает параметр `?personId={id}` из URL (опционально)
3. Если параметр присутствует — использует указанную персону как центральную
4. Если параметра нет или персона не найдена — выбирает корневую персону дерева
5. Загружает ближайшие связи центральной персоны (родители/дети/супруги)
6. Ограничивает количество узлов до 50 максимум
7. Генерирует SVG-схему на сервере
8. Передает SVG в Blade-шаблон

**Требования:**

- Маршрут должен быть доступен всем авторизованным пользователям (на этапе 6 используется тестовый пользователь)
- Центральная персона должна принадлежать текущему пользователю
- Если `personId` невалидный или не принадлежит пользователю — показать корневую персону
- Использовать eager loading для избежания N+1 проблемы

#### FR-1.2. Выбор корневой персоны

**Логика определения корневой персоны:**

1. Найти персону пользователя, у которой нет родителей (самое старшее поколение)
2. Если таких персон несколько — выбрать персону с наименьшим ID
3. Если у всех персон есть родители (цикл или ошибка данных) — выбрать первую персону пользователя по ID

**Требования:**

- Корневая персона должна быть стабильной (одна и та же при повторных заходах)
- Логика должна быть централизована в сервисе или репозитории
- Корневая персона используется как fallback при ошибках

**Критерии приемки FR-1:**

- ✅ Доступна страница дерева по адресу `GET /tree`
- ✅ Параметр `?personId={id}` позволяет выбрать центральную персону
- ✅ При отсутствии параметра показывается корневая персона
- ✅ При невалидном `personId` показывается корневая персона с сообщением "Персона не найдена"
- ✅ Корневая персона определяется корректно (персона без родителей)
- ✅ Страница отображает SVG-схему дерева

---

### FR-2. Алгоритм построения дерева (1 уровень вокруг персоны)

**Приоритет:** Высокий

**Описание:**
Система должна строить визуальное дерево, отображая выбранную персону в центре и ближайшие связи вокруг неё.

**Детализация:**

#### FR-2.1. Определение узлов дерева

**Алгоритм:**

1. Взять центральную персону (из параметра `?personId` или корневую)
2. Загрузить все связи первого уровня:
   - **Родители** — персоны, для которых центральная персона является ребенком
   - **Дети** — персоны, для которых центральная персона является родителем
   - **Супруги** — персоны, связанные как супруги
3. Загрузить данные каждой связанной персоны (имена, фамилии, даты)
4. Подсчитать общее количество узлов (центральная + родители + дети + супруги)
5. Если узлов больше 50 — ограничить до 50 и показать сообщение

**Требования:**

- Узлы должны быть уникальными (одна персона отображается один раз)
- Для каждого узла загружаются данные на текущем языке
- Используется eager loading для производительности
- Порядок обхода: сначала родители, затем супруги, затем дети

#### FR-2.2. Ограничение количества узлов

**Логика ограничения:**

- Максимум **50 узлов** на схеме
- Если после загрузки всех связей узлов больше 50:
  1. Отобразить первые 50 узлов по приоритету:
     - Центральная персона (всегда)
     - Родители (все)
     - Супруги (все)
     - Дети (до достижения лимита 50)
  2. Показать сообщение: "Дерево слишком большое, отображены первые 50 узлов"

**Требования:**

- Сообщение должно быть понятным и на выбранном языке
- Сообщение должно отображаться на странице (не модальное окно)
- Центральная персона всегда входит в первые 50 узлов

**Критерии приемки FR-2:**

- ✅ Дерево отображает центральную персону и связи первого уровня
- ✅ Загружаются только ближайшие родственники (родители/дети/супруги)
- ✅ Максимум 50 узлов на схеме
- ✅ При превышении лимита отображается сообщение "Дерево слишком большое, отображены первые 50 узлов"
- ✅ Приоритет узлов: центральная → родители → супруги → дети
- ✅ Нет N+1 проблемы при загрузке узлов

---

### FR-3. Серверный рендеринг SVG

**Приоритет:** Высокий

**Описание:**
Система должна генерировать SVG-схему на сервере (backend) и передавать готовую разметку в браузер.

**Детализация:**

#### FR-3.1. Генерация SVG на сервере

**Требования:**

- SVG генерируется в PHP-коде (не используется JavaScript для рендеринга)
- Используется библиотека или собственный класс для построения SVG
- SVG передается в Blade-шаблон как строка или объект
- Размер SVG canvas вычисляется динамически на основе количества узлов

**Технологии:**

- Вариант 1: Собственный класс `SvgTreeBuilder` для генерации SVG
- Вариант 2: Использовать библиотеку для работы с SVG (например, `svg/svg`)
- Вариант 3: Генерация SVG-строки через простую конкатенацию (для минимализма)

**Рекомендация:** Использовать собственный класс для полного контроля и простоты

#### FR-3.2. Структура SVG-схемы

**Минимальные требования к layout:**

1. **Древовидная структура** — иерархия читается визуально (родители сверху, дети снизу)
2. **Узлы (прямоугольники)** — для каждой персоны
3. **Линии связей** — между узлами (родитель-ребенок, супруги)
4. **Текст в узлах** — полное имя персоны на выбранном языке

**Требования к элементам:**

- **Узел персоны:**
  - Прямоугольник с закругленными углами
  - Ширина: автоматически по тексту (мин 150px, макс 300px)
  - Высота: 60px
  - Текст: полное имя с гендерной формой
  - Дополнительно: годы жизни (например, "1950-2020")
  - Цвет фона: белый для живых, серый для умерших
  - Рамка: 2px solid черная

- **Центральная персона:**
  - Выделяется цветом рамки (например, синяя рамка)
  - Всегда в центре схемы

- **Линии связей:**
  - Родитель → Ребенок: вертикальная или диагональная линия (1px solid черная)
  - Супруг ↔ Супруга: горизонтальная линия (1px solid черная)

- **Текст:**
  - Шрифт: sans-serif, 14px
  - Цвет: черный
  - Выравнивание: по центру узла

#### FR-3.3. Layout алгоритм (упрощенный)

**Алгоритм позиционирования:**

1. **Центральная персона** — в центре SVG canvas (x=canvas_width/2, y=canvas_height/2)
2. **Родители** — над центральной персоной, горизонтально рядом (если их несколько)
3. **Супруги** — справа или слева от центральной персоны (на том же уровне Y)
4. **Дети** — под центральной персоной, горизонтально рядом

**Отступы:**

- Между узлами по горизонтали: 40px
- Между уровнями по вертикали: 100px

**Размер canvas:**

- Ширина: вычисляется на основе максимального количества узлов на одном уровне
- Высота: вычисляется на основе количества уровней (родители → центр → дети)
- Минимум: 800x600px
- Максимум: не ограничен (прокрутка браузера)

**Критерии приемки FR-3:**

- ✅ SVG генерируется на сервере (PHP)
- ✅ Узлы отображаются как прямоугольники с текстом
- ✅ Центральная персона визуально выделена (синяя рамка)
- ✅ Линии связей отображаются между узлами
- ✅ Умершие персоны визуально отличаются (серый фон)
- ✅ Полное имя отображается с правильной гендерной формой
- ✅ Годы жизни отображаются в узле (если есть)
- ✅ Layout читается визуально (иерархия понятна)
- ✅ SVG корректно отображается во всех современных браузерах

---

### FR-4. Интерактивность: переход по узлам

**Приоритет:** Высокий

**Описание:**
Пользователь должен иметь возможность кликать по узлам персон и переходить к их окружению.

**Детализация:**

#### FR-4.1. Клик по узлу персоны

**Требования:**

- Каждый узел персоны (кроме центральной) должен быть кликабельным
- Клик по узлу переводит на `/tree?personId={clickedPersonId}`
- Схема перестраивается вокруг выбранной персоны (она становится центральной)
- Текущий язык сохраняется при переходе

**Реализация:**

- Каждый узел обернут в SVG элемент `<a>` с атрибутом `href="/tree?personId={id}&lang={lang}"`
- При клике браузер переходит на новую страницу (не AJAX)
- Центральная персона НЕ кликабельна (нет ссылки)

**Визуальная обратная связь:**

- При наведении на узел (hover) — курсор меняется на pointer
- Узел подсвечивается (например, рамка становится светло-синей)

#### FR-4.2. Навигация "Назад"

**Требования:**

- Кнопка браузера "Назад" работает корректно (возвращается к предыдущей центральной персоне)
- История браузера сохраняет переходы по персонам
- URL всегда содержит `personId` текущей центральной персоны

**Критерии приемки FR-4:**

- ✅ Узлы персон кликабельны (кроме центральной)
- ✅ Клик по узлу перестраивает схему вокруг выбранной персоны
- ✅ URL обновляется с новым `personId`
- ✅ Текущий язык сохраняется при переходе
- ✅ При наведении на узел курсор меняется и узел подсвечивается
- ✅ Кнопка браузера "Назад" работает корректно
- ✅ Центральная персона не кликабельна

---

### FR-5. Навигация и дополнительные элементы UI

**Приоритет:** Средний

**Описание:**
Страница визуализации должна содержать элементы навигации и вспомогательную информацию.

**Детализация:**

#### FR-5.1. Элементы навигации

**Обязательные элементы:**

1. **Кнопка "Назад к списку персон"** → `/persons?lang={lang}`
2. **Кнопка "Карточка текущей персоны"** → `/persons/{personId}?lang={lang}`
3. **Кнопка смены языка** — переключение между ru/en
4. **Ссылка на главную страницу** → `/?lang={lang}`

**Расположение:**

- Элементы навигации в верхней части страницы (над SVG-схемой)
- Кнопки должны быть понятными и визуально заметными

#### FR-5.2. Информация о центральной персоне

**Обязательные элементы:**

- **Заголовок страницы:** "Генеалогическое древо: [Полное имя центральной персоны]"
- **Годы жизни:** Если известны (например, "1950-2020" или "1950")
- **Количество отображаемых узлов:** "Показано узлов: 25 из 25"

**Расположение:**

- Информация над SVG-схемой, под элементами навигации

#### FR-5.3. Сообщения об ошибках и предупреждения

**Сообщения:**

1. **"Персона не найдена"** — если `personId` невалидный (показывается корень дерева)
2. **"Дерево слишком большое, отображены первые 50 узлов"** — если узлов больше 50
3. **"Нет данных для отображения"** — если у пользователя нет персон

**Расположение:**

- Над SVG-схемой, под заголовком
- Сообщения должны быть визуально заметными (например, желтый фон для предупреждений)

**Критерии приемки FR-5:**

- ✅ Есть кнопка "Назад к списку персон"
- ✅ Есть кнопка "Карточка текущей персоны"
- ✅ Есть кнопка смены языка
- ✅ Есть ссылка на главную страницу
- ✅ Заголовок страницы содержит имя центральной персоны
- ✅ Отображается количество узлов
- ✅ Сообщения об ошибках понятны и визуально заметны
- ✅ Навигация работает корректно и сохраняет язык

---

### FR-6. Корректное отображение многоязычных данных

**Приоритет:** Высокий

**Описание:**
Визуализация должна корректно отображать многоязычные имена и фамилии с правильными гендерными формами.

**Детализация:**

#### FR-6.1. Отображение имен в узлах

**Требования:**

- Полное имя (имя + отчество + фамилия) на выбранном языке
- Гендерные формы фамилий и отчеств корректны (Петров/Петрова, Иванович/Ивановна)
- Формат: "[Имя] [Отчество] [Фамилия]" (например, "Иван Петрович Сидоров")
- Если имя слишком длинное — сокращать отчество (например, "Иван П. Сидоров")

**Требования к длине:**

- Максимальная длина текста в узле: 30 символов
- Если имя длиннее — сокращать отчество до инициала
- Если все равно не помещается — сокращать имя до инициала
- Минимум: "И. П. Фамилия"

#### FR-6.2. Отображение дат в узлах

**Формат:**

- Если жив: "род. YYYY" (например, "род. 1950")
- Если умер: "YYYY-YYYY" (например, "1950-2020")
- Если дата рождения неизвестна: не отображать

**Расположение:**

- Даты на второй строке узла (под именем)
- Шрифт: 12px, серый цвет

#### FR-6.3. Fallback для отсутствующих переводов

**Логика:**

- Если нет перевода имени на выбранный язык — использовать первый доступный (русский)
- Если нет перевода фамилии — использовать первый доступный
- Пользователь видит корректное имя, даже если нет перевода

**Критерии приемки FR-6:**

- ✅ Полные имена отображаются на выбранном языке
- ✅ Гендерные формы фамилий и отчеств корректны
- ✅ Длинные имена сокращаются до инициалов
- ✅ Даты отображаются в едином формате
- ✅ Fallback-логика работает при отсутствии переводов
- ✅ Нет ошибок типа "Мария Иванович Петров"

---

### FR-7. Адаптивность интерфейса

**Приоритет:** Средний

**Описание:**
Визуализация должна корректно отображаться на различных устройствах (ноутбук, планшет, телефон).

**Детализация:**

#### FR-7.1. Базовая адаптивность

**Требования:**

- **Ноутбук (1366x768 и выше):**
  - SVG отображается без горизонтальной прокрутки (если узлов немного)
  - Если схема большая — появляется горизонтальная прокрутка

- **Планшет (768x1024):**
  - SVG масштабируется пропорционально
  - Горизонтальная прокрутка появляется при необходимости

- **Телефон (375x667):**
  - SVG отображается с горизонтальной и вертикальной прокруткой
  - Узлы остаются читаемыми (минимальный размер текста 12px)

**Реализация:**

- SVG помещается в контейнер с `overflow: auto`
- Минимальная ширина SVG canvas: 800px
- На маленьких экранах пользователь прокручивает SVG

#### FR-7.2. Удобство использования на мобильных

**Требования:**

- Текст в узлах читаемый (минимум 12px)
- Узлы достаточно большие для касания пальцем (минимум 44x44px)
- Кнопки навигации удобно нажимать на touch-экранах

**Критерии приемки FR-7:**

- ✅ Визуализация корректно отображается на ноутбуках
- ✅ Визуализация корректно отображается на планшетах
- ✅ Визуализация корректно отображается на телефонах (с прокруткой)
- ✅ Текст в узлах читаемый на всех устройствах
- ✅ Узлы достаточно большие для касания пальцем
- ✅ Кнопки навигации удобно нажимать на touch-экранах

---

## Нефункциональные требования

### NFR-1. Производительность

**Описание:**
Генерация SVG-схемы должна выполняться быстро даже при максимальном количестве узлов.

**Критерии:**

- Генерация SVG для 50 узлов: < 500ms
- Загрузка страницы `/tree`: < 1 секунда
- Использование eager loading для загрузки узлов (нет N+1 проблемы)
- Количество SQL-запросов: не более 10 (независимо от количества узлов)

**Проверка:**

- Измерить время генерации SVG на тестовых данных (50 узлов)
- Измерить количество SQL-запросов через Laravel Debugbar
- Запустить performance-тесты

---

### NFR-2. Читаемость визуализации

**Описание:**
SVG-схема должна быть понятной и легко читаемой.

**Критерии:**

- Иерархия читается визуально (родители сверху, дети снизу)
- Линии связей не пересекаются (для простых схем)
- Текст в узлах читаемый (минимум 12px)
- Узлы не накладываются друг на друга
- Цвета контрастные и понятные

**Проверка:**

- Ручное тестирование на тестовых данных
- Проверка на различных устройствах
- Пользовательское тестирование (feedback)

---

### NFR-3. Простота поддержки

**Описание:**
Код генерации SVG должен быть простым и расширяемым для будущих улучшений.

**Критерии:**

- Класс `SvgTreeBuilder` изолирован и тестируем
- Логика позиционирования узлов вынесена в отдельные методы
- Код следует принципам Clean Architecture
- Легко добавить новые типы узлов или связей

**Проверка:**

- Code review
- Соответствие стилю проекта (.ai/Rule/CodeStyle.md)
- Статический анализ PHPStan

---

### NFR-4. Безопасность

**Описание:**
Пользователь может видеть только свои персоны и связи.

**Критерии:**

- Проверка прав доступа на уровне контроллера
- Невозможность открыть дерево другого пользователя
- Фильтрация персон по userId
- Нет XSS-уязвимостей в SVG (экранирование текста)

**Проверка:**

- Попытка передать `personId` чужой персоны — возвращается корень своего дерева
- Проверка экранирования специальных символов в именах

---

### NFR-5. Кросс-браузерность

**Описание:**
SVG-схема должна корректно отображаться во всех современных браузерах.

**Критерии:**

- Поддержка браузеров: Chrome, Firefox, Safari, Edge (последние 2 версии)
- SVG рендерится корректно (узлы, линии, текст)
- Интерактивность работает (клики, hover)

**Проверка:**

- Тестирование на всех основных браузерах
- Проверка консоли на ошибки

---

## Модель предметной области

Этап 6 использует доменную модель, созданную на этапах 2 и 5. Основные сущности:

### Основные Entity

#### Person (Персона)

**Атрибуты:**

- `id: int` — уникальный идентификатор
- `userId: int` — владелец дерева
- `firstName: Name` — имя (многоязычное)
- `middleName: ?Name` — отчество (опционально)
- `surname: ?Surname` — текущая фамилия
- `birthDate: ?DateTime` — дата рождения
- `deathDate: ?DateTime` — дата смерти
- `gender: Gender` — пол персоны

**Методы для этапа 6:**

- `getFullName(string $language): string` — получить полное имя на нужном языке
- `getShortName(string $language, int $maxLength): string` — получить сокращенное имя (с инициалами)
- `getBirthYear(): ?int` — получить год рождения
- `getDeathYear(): ?int` — получить год смерти
- `isAlive(): bool` — жив ли человек

#### Relation (Связь)

**Атрибуты:**

- `personId1: int` — первая персона
- `personId2: int` — вторая персона
- `type: RelationType` — тип связи

#### TreeNode (Узел дерева) — новый класс для этапа 6

**Описание:** Узел визуального дерева, представляющий персону на схеме.

**Атрибуты:**

- `person: Person` — данные персоны
- `x: int` — позиция X на SVG canvas
- `y: int` — позиция Y на SVG canvas
- `width: int` — ширина узла
- `height: int` — высота узла
- `isCentral: bool` — является ли центральной персоной

**Методы:**

- `render(string $language): string` — генерация SVG-разметки узла
- `getDisplayName(string $language): string` — получить имя для отображения

#### TreeEdge (Связь в дереве) — новый класс для этапа 6

**Описание:** Линия связи между узлами дерева.

**Атрибуты:**

- `fromNode: TreeNode` — узел-источник
- `toNode: TreeNode` — узел-цель
- `type: RelationType` — тип связи

**Методы:**

- `render(): string` — генерация SVG-разметки линии

### Services

#### SvgTreeBuilder (Конструктор SVG-дерева) — новый сервис для этапа 6

**Описание:** Сервис для построения SVG-схемы генеалогического древа.

**Методы:**

- `build(Person $centralPerson, array $relatives, string $language): string` — построить SVG
- `createNodes(Person $centralPerson, array $relatives): array<TreeNode>` — создать узлы
- `createEdges(array $nodes, array $relations): array<TreeEdge>` — создать связи
- `calculateLayout(array $nodes): void` — вычислить позиции узлов
- `renderSvg(array $nodes, array $edges, string $language): string` — генерировать SVG-разметку

#### TreeService (Сервис работы с деревом) — новый сервис для этапа 6

**Описание:** Бизнес-логика для работы с генеалогическим деревом.

**Методы:**

- `findRootPerson(int $userId): ?Person` — найти корневую персону дерева
- `loadTreeData(Person $centralPerson, int $maxNodes): array` — загрузить данные для дерева
- `limitNodes(array $nodes, int $limit): array` — ограничить количество узлов

---

## Зависимости

### Внешние зависимости

- **Laravel 12** — фреймворк для контроллеров, Blade, маршрутов
- **PHP 8.5** — язык программирования
- **SQLite** — СУБД с данными

### Внутренние зависимости

Этап 6 **зависит** от:

- **Этап 1 (TZ1_01)** — требует готовую схему БД с данными
- **Этап 2 (TZ1_02)** — требует доменную модель Person, Relation и репозитории
- **Этап 3 (TZ1_03)** — требует UI для навигации и многоязычности
- **Этап 5 (TZ1_05)** — требует корректные связи между персонами

Этап 6 **является блокирующим** для:

- **Этап 7** — Авторизация (будет использовать визуализацию для демонстрации дерева пользователя)
- **Будущие улучшения** — Zoom, фильтры, экспорт в графические форматы

---

## Сценарии использования

### UC-1. Пользователь открывает визуализацию дерева

**Актор:** Пользователь

**Предусловия:**

- В БД есть тестовый пользователь с персонами
- Персоны имеют связи (родители/дети/супруги)

**Основной сценарий:**

1. Пользователь переходит на страницу `/tree` (без параметров)
2. Система находит корневую персону (персону без родителей)
3. Загружает ближайшие связи корневой персоны
4. Генерирует SVG-схему с узлами и линиями
5. Отображает страницу с:
   - Заголовком: "Генеалогическое древо: [Имя корневой персоны]"
   - SVG-схемой с центральной персоной и родственниками
   - Количеством узлов: "Показано узлов: 5 из 5"
6. Пользователь видит визуальную схему дерева

**Постусловия:**

- Пользователь увидел графическое представление дерева
- Корневая персона выделена (синяя рамка)
- Связи отображаются линиями

---

### UC-2. Пользователь переходит к другой персоне в дереве

**Актор:** Пользователь

**Предусловия:**

- Пользователь на странице `/tree?personId=1`
- На схеме отображается персона с ID=1 и её родственники

**Основной сценарий:**

1. Пользователь наводит курсор на узел персоны с ID=2 (ребенок центральной персоны)
2. Узел подсвечивается (светло-синяя рамка)
3. Курсор меняется на pointer
4. Пользователь кликает на узел
5. Браузер переходит на `/tree?personId=2`
6. Схема перестраивается вокруг персоны с ID=2
7. Персона с ID=2 теперь в центре (синяя рамка)
8. Отображаются её родственники

**Постусловия:**

- Схема перестроена вокруг новой центральной персоны
- URL обновлен с новым `personId`
- История браузера сохранила переход

---

### UC-3. Система обрабатывает большое дерево (более 50 узлов)

**Актор:** Пользователь

**Предусловия:**

- У персоны есть более 50 ближайших родственников (много детей)

**Основной сценарий:**

1. Пользователь переходит на `/tree?personId=10`
2. Система загружает ближайшие связи персоны
3. Подсчитывает узлы: 1 (центр) + 2 (родители) + 1 (супруг) + 60 (детей) = 64 узла
4. Ограничивает до 50 узлов:
   - Центральная персона (1)
   - Родители (2)
   - Супруг (1)
   - Первые 46 детей
5. Генерирует SVG-схему с 50 узлами
6. Отображает сообщение: "Дерево слишком большое, отображены первые 50 узлов"
7. Показывает: "Показано узлов: 50 из 64"

**Постусловия:**

- Отображено 50 узлов (максимум)
- Пользователь видит предупреждение о неполном отображении
- Схема остается читаемой

---

### UC-4. Пользователь указывает невалидный personId

**Актор:** Пользователь

**Предусловия:**

- Пользователь вводит URL `/tree?personId=999` (несуществующая персона)

**Основной сценарий:**

1. Система пытается загрузить персону с ID=999
2. Персона не найдена или не принадлежит пользователю
3. Система находит корневую персону пользователя (ID=1)
4. Отображает дерево вокруг корневой персоны
5. Показывает сообщение: "Персона не найдена"
6. URL остается `/tree?personId=999` (не меняется)

**Постусловия:**

- Пользователь видит корень своего дерева
- Понятно, что указанная персона не найдена
- Нет ошибок 404

---

### UC-5. Пользователь переключает язык на визуализации

**Актор:** Пользователь

**Предусловия:**

- Пользователь на странице `/tree?personId=1&lang=ru`

**Основной сценарий:**

1. Пользователь кликает на кнопку "English"
2. Браузер переходит на `/tree?personId=1&lang=en`
3. Схема перестраивается с английскими именами:
   - "Иван Петрович Сидоров" → "John Petrovich Sidorov"
4. Заголовок переводится: "Family Tree: John Petrovich Sidorov"
5. Кнопки переводятся на английский

**Постусловия:**

- Интерфейс переведен на английский
- Имена в узлах на английском
- Гендерные формы корректны на английском

---

### UC-6. Стейкхолдер оценивает визуализацию дерева

**Актор:** Стейкхолдер (заказчик/куратор)

**Предусловия:**

- Проект развернут и доступен
- В БД есть тестовые данные с множественными связями

**Основной сценарий:**

1. Стейкхолдер открывает сайт и переходит к визуализации `/tree`
2. Видит графическую схему генеалогического древа
3. Проверяет:
   - Иерархия читается (родители сверху, дети снизу)
   - Линии связей понятны
   - Имена отображаются корректно с гендерными формами
   - Центральная персона выделена
4. Кликает на узел родителя
5. Схема перестраивается вокруг родителя
6. Проверяет навигацию (назад, карточка персоны, смена языка)
7. Переключает язык на английский
8. Проверяет корректность переводов
9. Подтверждает, что визуализация работает и понятна
10. Одобряет этап

**Постусловия:**

- Стейкхолдер получил демонстрируемый результат с визуализацией
- Подтверждена корректность отображения связей
- Подтверждена интерактивность (переход по узлам)

---

## Риски

### Риск 1. Сложность алгоритма layout для SVG

**Описание:**
Автоматическое позиционирование узлов в SVG-схеме может быть сложным, особенно для деревьев с множественными детьми или супругами.

**Вероятность:** Высокая

**Влияние:** Высокое (плохая читаемость схемы)

**Меры снижения:**

- Использовать упрощенный алгоритм для этапа 6 (фиксированные отступы, без оптимизации)
- Ограничить количество узлов до 50 для управляемости
- Протестировать на различных структурах деревьев
- Документировать известные ограничения

**План реагирования:**

- Если layout нечитаемый — упростить алгоритм (родители всегда сверху, дети всегда снизу)
- Рассмотреть использование библиотеки для графов на будущих этапах
- Добавить возможность zoom и pan для больших схем (будущее)

---

### Риск 2. Производительность генерации SVG на сервере

**Описание:**
Генерация SVG-разметки для 50 узлов на PHP может быть медленной, особенно с учетом загрузки данных и вычислений layout.

**Вероятность:** Средняя

**Влияние:** Среднее (медленная загрузка страницы)

**Меры снижения:**

- Использовать eager loading для загрузки данных
- Измерять производительность на тестовых данных
- Кешировать сгенерированный SVG (если структура не меняется часто)
- Оптимизировать алгоритм layout

**План реагирования:**

- Если генерация медленная — добавить кеширование SVG
- Рассмотреть использование очередей для генерации больших деревьев
- Добавить индикатор загрузки для пользователя

---

### Риск 3. Читаемость схемы на маленьких экранах

**Описание:**
На мобильных устройствах SVG-схема может быть нечитаемой из-за маленького размера узлов и текста.

**Вероятность:** Высокая

**Влияние:** Среднее (плохой UX на мобильных)

**Меры снижения:**

- Использовать прокрутку (overflow: auto) для просмотра схемы
- Минимальный размер текста 12px
- Минимальный размер узлов 44x44px (для touch)
- Протестировать на реальных мобильных устройствах

**План реагирования:**

- Если нечитаемо — добавить возможность zoom (pinch-to-zoom)
- Рассмотреть упрощенный layout для мобильных (меньше узлов)
- Добавить переключатель "Полная версия" / "Мобильная версия"

---

### Риск 4. Пересечение линий связей

**Описание:**
Линии связей между узлами могут пересекаться, особенно в сложных деревьях с множественными связями.

**Вероятность:** Высокая

**Влияние:** Среднее (сложность чтения схемы)

**Меры снижения:**

- Использовать простой алгоритм layout с минимумом пересечений
- Ограничить количество узлов до 50
- Документировать, что пересечения возможны в сложных деревьях
- Рассмотреть использование кривых Безье для плавных линий (будущее)

**План реагирования:**

- Если пересечений слишком много — использовать разные цвета для разных типов связей
- Добавить интерактивность (подсветка связей при наведении)
- Рассмотреть библиотеку для графов с автоматическим layout (будущее)

---

### Риск 5. XSS-уязвимости в SVG

**Описание:**
Если имена персон содержат специальные символы (например, `<script>`), SVG может быть уязвим к XSS-атакам.

**Вероятность:** Низкая (имена обычно не содержат спецсимволы)

**Влияние:** Критическое (безопасность)

**Меры снижения:**

- Экранировать все текстовые данные при генерации SVG
- Использовать `htmlspecialchars()` или аналог для SVG-контекста
- Протестировать с специальными символами в именах
- Провести security review кода

**План реагирования:**

- Если обнаружена уязвимость — немедленно исправить экранирование
- Добавить тесты на специальные символы
- Провести пентест

---

## Критерии приемки

### Критерии приемки этапа

Этап считается завершенным, если выполнены **все** следующие критерии:

#### Критерии по функциональности

- ✅ Доступна страница визуализации `GET /tree`
- ✅ Параметр `?personId={id}` позволяет выбрать центральную персону
- ✅ При отсутствии параметра показывается корневая персона
- ✅ При невалидном `personId` показывается корневая персона с сообщением
- ✅ SVG-схема отображает центральную персону и связи первого уровня
- ✅ Максимум 50 узлов на схеме
- ✅ При превышении лимита отображается сообщение
- ✅ Узлы кликабельны (кроме центральной)
- ✅ Клик по узлу перестраивает схему вокруг выбранной персоны
- ✅ Текущий язык сохраняется при переходе

#### Критерии по визуализации

- ✅ Узлы отображаются как прямоугольники с текстом
- ✅ Центральная персона выделена (синяя рамка)
- ✅ Линии связей отображаются между узлами
- ✅ Умершие персоны визуально отличаются (серый фон)
- ✅ Полное имя отображается с правильной гендерной формой
- ✅ Годы жизни отображаются в узле
- ✅ Layout читается визуально (иерархия понятна)
- ✅ SVG корректно отображается во всех современных браузерах

#### Критерии по навигации

- ✅ Есть кнопка "Назад к списку персон"
- ✅ Есть кнопка "Карточка текущей персоны"
- ✅ Есть кнопка смены языка
- ✅ Есть ссылка на главную страницу
- ✅ Заголовок страницы содержит имя центральной персоны
- ✅ Отображается количество узлов
- ✅ Сообщения об ошибках понятны и визуально заметны

#### Критерии по производительности

- ✅ Генерация SVG для 50 узлов: < 500ms
- ✅ Загрузка страницы `/tree`: < 1 секунда
- ✅ Используется eager loading (нет N+1 проблемы)
- ✅ Количество SQL-запросов: не более 10

#### Критерии по адаптивности

- ✅ Визуализация корректно отображается на ноутбуках
- ✅ Визуализация корректно отображается на планшетах
- ✅ Визуализация корректно отображается на телефонах (с прокруткой)
- ✅ Текст в узлах читаемый на всех устройствах
- ✅ Узлы достаточно большие для касания пальцем

#### Критерии по безопасности

- ✅ Пользователь может видеть только свои персоны
- ✅ Попытка открыть дерево другого пользователя возвращает корень своего дерева
- ✅ Нет XSS-уязвимостей в SVG (экранирование текста)

#### Критерии по тестам

- ✅ Написаны unit-тесты для `SvgTreeBuilder`
- ✅ Написаны unit-тесты для `TreeService`
- ✅ Написаны integration-тесты для генерации SVG
- ✅ Написаны E2E тесты для визуализации дерева
- ✅ Тесты проверяют ограничение до 50 узлов
- ✅ Тесты проверяют обработку невалидного `personId`
- ✅ Тесты проверяют переход по узлам

#### Критерии по коду

- ✅ Код соответствует стилю проекта (.ai/Rule/CodeStyle.md)
- ✅ Код проходит статический анализ PHPStan уровня 8-9
- ✅ Код проходит проверку PHP_CodeSniffer
- ✅ Код следует принципам Clean Architecture
- ✅ Класс `SvgTreeBuilder` изолирован и тестируем
- ✅ Сервис `TreeService` использует репозитории

---

## Не входит в реализацию

Следующие функции **НЕ входят** в реализацию текущего этапа:

### Не входит в Stage 6

- ❌ **Zoom и pan** — возможность масштабирования и перемещения схемы (может быть добавлено в будущем)
- ❌ **Расширенный layout алгоритм** — оптимизация позиционирования узлов для минимизации пересечений (может быть улучшено)
- ❌ **Отображение нескольких уровней** — показ 2-3 уровней предков/потомков (ограничение: 1 уровень)
- ❌ **Фильтрация узлов** — скрытие/показ определенных типов родственников (будущее)
- ❌ **Экспорт в графические форматы** — PNG, PDF, GEDCOM (будущее)
- ✅ **Редактирование прямо на схеме** — создание/удаление связей через drag-and-drop (будущее)
- ❌ **История просмотра** — список недавно просмотренных персон (будущее)
- ❌ **Поиск на схеме** — подсветка персоны по имени (будущее)
- ❌ **Анимация переходов** — плавная перестройка схемы при клике (будущее)
- ❌ **Кастомизация внешнего вида** — выбор цветов, стилей узлов (будущее)
- ❌ **Фотографии в узлах** — отображение фото персон (будущее)
- ❌ **Детальная информация в tooltip** — всплывающие подсказки с датами, местами (будущее)

### Допущения текущего этапа

На текущем этапе допускаются следующие упрощения:

- ✅ **Только 1 уровень связей** — отображаются только ближайшие родственники
- ✅ **Максимум 50 узлов** — жесткое ограничение для управляемости
- ✅ **Упрощенный layout** — фиксированные отступы, возможны пересечения линий
- ✅ **Серверный рендеринг** — без клиентского JavaScript (кроме кликов)
- ✅ **Базовая адаптивность** — прокрутка на маленьких экранах (без zoom)
- ✅ **Один тестовый пользователь** — авторизация будет на Stage 7

---

## Дополнительные замечания

### Важные особенности реализации

1. **Серверный рендеринг SVG критичен:** Весь SVG генерируется на PHP, это упрощает архитектуру и избегает зависимости от JavaScript.

2. **Ограничение до 50 узлов обязательно:** Без ограничения схема может стать нечитаемой и медленной.

3. **Упрощенный layout допустим:** На этапе 6 не требуется идеальное позиционирование, главное — читаемость иерархии.

4. **Интерактивность минимальна:** Только клики по узлам, без drag-and-drop и сложных взаимодействий.

5. **Экранирование текста обязательно:** Все имена должны быть экранированы для предотвращения XSS.

### Рекомендации по реализации

1. **Начать с сервиса TreeService:** Реализовать логику поиска корневой персоны и загрузки данных.

2. **Создать класс SvgTreeBuilder:** Изолированный класс для генерации SVG с четкими методами.

3. **Тестировать на простых деревьях:** Начать с 5-10 узлов, затем проверить на 50.

4. **Использовать фиксированные размеры узлов:** 150x60px для всех узлов (упрощает layout).

5. **Протестировать на всех браузерах:** SVG может рендериться по-разному в разных браузерах.

---

## Глоссарий

- **Визуализация дерева** — графическое представление генеалогического древа в виде узлов и связей
- **Узел (Node)** — графический элемент, представляющий персону на схеме
- **Связь (Edge)** — линия между узлами, показывающая родственное отношение
- **Центральная персона** — персона, вокруг которой построена схема
- **Корневая персона** — персона без родителей (самое старшее поколение)
- **SVG (Scalable Vector Graphics)** — формат векторной графики для веба
- **Layout алгоритм** — алгоритм позиционирования узлов на схеме
- **Eager loading** — предварительная загрузка связанных данных для избежания N+1 проблемы
- **Серверный рендеринг** — генерация HTML/SVG на сервере (backend)
- **Canvas** — область рисования для SVG-схемы
- **Hover** — наведение курсора на элемент
- **Touch** — касание пальцем на сенсорных экранах
- **Fallback** — резервный вариант (дефолтное значение при отсутствии данных)
- **XSS (Cross-Site Scripting)** — уязвимость, позволяющая выполнить вредоносный JavaScript

---

**Конец спецификации TZ1_06**
