# Спецификация: Медиа и поиск (Этап 4)

## Описание проблемы/потребности

После реализации профилей и визуализации (Этапы 2-3), пользователи захотят прикреплять к профилям фотографии, документы и другие медиафайлы, а также искать людей по различным критериям. Это расширяет функциональность сервиса от простого хранения данных к полноценному исследовательскому инструменту.

## Функциональные требования

1.  **Медиа-библиотека (Backend):**
    *   Загрузка файлов (фото, документы PDF/DOC, аудио/видео).
    *   Хранение файлов (на диске или в облаке).
    *   Генерация превью для изображений.
    *   Привязка медиа к `FamilyMember`.
    *   Управление доступом (только для членов семьи).
2.  **Медиа-галерея (Frontend):**
    *   Просмотр всех медиафайлов пользователя.
    *   Просмотр медиа, связанных с конкретным `FamilyMember`.
    *   Слайд-шоу для изображений.
3.  **Поиск (Backend API):**
    *   Поиск `FamilyMember` по ФИО, году рождения, месту рождения.
    *   Фильтрация по полу, диапазону лет жизни.
    *   Поиск по содержимому биографии.
4.  **Поиск (Frontend):**
    *   Интерфейс поиска с полями фильтрации.
    *   Отображение результатов в виде списка с краткой информацией и превью-фото.

## Нефункциональные требования

1.  **Производительность:**
    *   Время отклика API поиска не более 300 мс при объеме данных до 10 000 персон.
    *   Генерация превью происходит асинхронно.
2.  **Безопасность:**
    *   Загрузка файлов ограничена по типу и размеру.
    *   Доступ к файлам только через авторизованный API.
3.  **Масштабируемость:**
    *   Возможность хранения файлов вне основного сервера (S3-совместимое хранилище).

## Модель предметной области

### Сущности (Entities)

1.  **Media (Медиафайл):**
    *   `id`: Integer (соответствует `gen_media.ID`).
    *   `fileName`: String (соответствует `gen_media.FILE_NAME`).
    *   `fileType`: String (соответствует `gen_media.FILE_TYPE`).
    *   `fileSize`: Integer (соответствует `gen_media.FILE_SIZE`).
    *   `filePath`: String (соответствует `gen_media.FILE_PATH`).
    *   `previewPath`: String (соответствует `gen_media.PREVIEW_PATH`).
    *   `description`: String (соответствует `gen_media.DESCRIPTION`).
    *   `uploadedAt`: DateTime (соответствует `gen_media.UPLOADED_AT`).
    *   `ownerId`: `FamilyMemberId` (соответствует `gen_media.PERSON_ID`).
    *   `isPublic`: Boolean (соответствует `gen_media.IS_PUBLIC`).
2.  **SearchQuery (Поисковый запрос):**
    *   `criteria`: `SearchCriteria` (объект-значение с полями для поиска).
    *   `userId`: `UserId` (идентификатор пользователя, выполнившего поиск).

### Объекты-значения (Value Objects)

1.  **SearchCriteria:**
    *   `fullName`: String (частичное совпадение).
    *   `birthYearFrom`: Integer.
    *   `birthYearTo`: Integer.
    *   `birthPlace`: String.
    *   `gender`: `Gender`.
    *   `isAlive`: Boolean.

## Технические детали (API)

### API Эндпоинты
- `POST /api/v1/media` — Загрузка нового медиафайла.
- `GET /api/v1/media` — Получение списка медиафайлов текущего пользователя.
- `GET /api/v1/media/{id}` — Получение информации о конкретном медиафайле.
- `DELETE /api/v1/media/{id}` — Удаление медиафайла.
- `GET /api/v1/family-members/{id}/media` — Получение медиафайлов конкретного члена семьи.

- `POST /api/v1/search/family-members` — Выполнение поиска по членам семьи.
    *   Тело запроса: объект `SearchCriteria`.

### Формат ответа (пример)
```json
{
  "results": [
    {
      "id": 1,
      "full_name": "Иван Иванов",
      "birth_date": "1950-01-01",
      "death_date": null,
      "photo_url": "/media/previews/1.jpg"
    }
  ],
  "total": 1,
  "page": 1,
  "per_page": 20
}
```

## Зависимости

1.  **Family Member Module (S2):** Источник данных о персонах, к которым привязываются медиа.
2.  **Auth Module (S1):** Аутентификация и авторизация для доступа к медиа и поиску.
3.  **Storage Service:** Внешний сервис для хранения файлов (локально или S3-совместимое хранилище).

## Сценарии использования

### Сценарий 1: Загрузка семейной фотографии
**Актер:** Пользователь.
1. Пользователь переходит в профиль своего дедушки.
2. Нажимает кнопку "Добавить фото".
3. Выбирает файл с компьютера.
4. Вводит описание "Свадьба 1975 года".
5. Нажимает "Загрузить".
6. Фото появляется в галерее профиля дедушки.

### Сценарий 2: Поиск по фамилии
**Актер:** Пользователь.
1. Пользователь открывает страницу поиска.
2. Вводит "Иванов" в поле "Фамилия".
3. Нажимает "Найти".
4. Система отображает список всех Ивановых в дереве с превью-фото и годами жизни.

### Сценарий 3: Поиск живых родственников
**Актер:** Пользователь.
1. Пользователь открывает страницу поиска.
2. Устанавливает фильтр "Жив" = "Да".
3. Нажимает "Найти".
4. Система отображает список всех живых родственников.

## Риски

1.  **Хранение файлов:** Неправильная настройка прав доступа может привести к утечке личных фото.
2.  **Производительность поиска:** При росте объема данных поиск может замедляться без индексов.
3.  **Размер файлов:** Пользователи могут загружать слишком большие файлы, что повлияет на хранилище и пропускную способность.

## Критерии приемки

1.  **Медиа:**
    *   Пользователь может загрузить изображение через форму.
    *   Загруженное изображение отображается в галерее профиля.
    *   Генерируется превью изображения.
    *   Пользователь может удалить свое медиа.
2.  **Поиск:**
    *   Поиск по ФИО возвращает персон с частичным совпадением.
    *   Фильтрация по году рождения работает корректно.
    *   Результаты поиска отображаются в виде списка с пагинацией.
    *   Поиск возвращает 404, если результатов нет.
3.  **API:**
    *   Все эндпоинты возвращают корректные HTTP-коды (200, 201, 400, 404, 500).
    *   API возвращает ошибки в унифицированном формате.

## Не входит в реализацию

1.  Автоматическое распознавание лиц на фото.
2.  Редактирование метаданных файла (EXIF) через интерфейс.
3.  Поиск по содержимому документов (OCR).
4.  Расширенные фильтры поиска (например, "найти всех дедушек по материнской линии").
