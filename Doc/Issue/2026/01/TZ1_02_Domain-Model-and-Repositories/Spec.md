# Спецификация бизнес-требований TZ1_02

## Метаинформация

- **Номер задачи:** TZ1_02
- **Эпик:** TZ1 — Веб-сайт семейного генеалогического древа
- **Этап:** Stage 2 — Адаптация доменной модели к существующей схеме и создание репозиториев
- **Дата создания:** 2026-01-22
- **Статус:** Черновик

## Описание проблемы/потребности

### Контекст

После успешной миграции схемы базы данных из MySQL в SQLite (этап 1), в проекте есть готовая структура таблиц с реальными данными генеалогического древа. Схема БД использует сложную многоязычную модель с промежуточными таблицами для хранения имен и фамилий в различных языковых вариантах и с поддержкой гендерных форм (мужские/женские отчества и фамилии).

Текущее состояние:

- Есть 15+ таблиц с данными в SQLite
- Схема включает многоязычность (таблицы `gen_name_lang`, `gen_surname_lang`)
- Схема включает промежуточные таблицы (`gen_mixed_name_lang`, `gen_mixed_surname_lang`)
- Есть данные о персонах, именах, фамилиях и связях
- Целостность данных проверена и подтверждена

### Проблема

**КРИТИЧНО:** Разработка бизнес-логики напрямую с использованием таблиц БД приведет к:

1. **Размыванию архитектуры:** Нарушится принцип Clean Architecture — бизнес-логика станет зависимой от деталей реализации БД
2. **Сложности кода:** Работа с многоязычной моделью через промежуточные таблицы и JOIN-запросы усложнит код
3. **Дублированию логики:** Логика извлечения имен/фамилий на нужном языке будет дублироваться в разных местах
4. **Затруднению тестирования:** Невозможно протестировать бизнес-логику без реальной БД
5. **Зависимости от фреймворка:** Бизнес-логика станет зависимой от Laravel Eloquent
6. **Риску ошибок:** Прямая работа с БД не гарантирует корректность обработки гендерных форм и языковых вариантов

### Бизнес-ценность решения

Создание доменной модели и репозиториев обеспечит:

- **Чистоту архитектуры:** Бизнес-логика будет независима от деталей хранения данных
- **Простоту разработки:** Разработчики будут работать с понятными доменными объектами (Person, Name, Surname), а не с таблицами БД
- **Переиспользование логики:** Логика работы с многоязычными именами/фамилиями будет централизована в репозиториях
- **Тестируемость:** Репозитории можно легко мокировать для unit-тестов бизнес-логики
- **Гибкость:** Если потребуется изменить схему БД, изменения будут локализованы в репозиториях
- **Основу для следующих этапов:** Доменная модель станет фундаментом для реализации use cases (просмотр, создание, редактирование персон и связей)

## Функциональные требования

### FR-1. Создание доменных сущностей (Entities)

**Приоритет:** Высокий

**Описание:**
Система должна иметь набор доменных сущностей (entities), представляющих понятия предметной области генеалогического древа: персоны, имена, фамилии, связи, пользователи.

**Детализация:**

#### FR-1.1. Entity Person (Персона)

Создать класс `Person` со следующими полями:

- `id: int` — уникальный идентификатор персоны
- `userId: int` — владелец персоны (для разграничения доступа)
- `firstName: Name` — имя персоны (многоязычное)
- `middleName: ?Name` — отчество персоны (опционально, многоязычное)
- `surname: ?Surname` — текущая фамилия (опционально, многоязычная)
- `birthSurname: ?Surname` — девичья фамилия (опционально, многоязычная)
- `birthDate: ?DateTime` — дата рождения
- `deathDate: ?DateTime` — дата смерти
- `info: array<string, string>` — дополнительная информация по языкам (ключ — код языка, значение — текст)
- `gender: Gender` — пол персоны (для выбора гендерных форм)

**Требования:**

- Класс должен находиться в модуле Core (не зависит от фреймворка)
- Все поля должны быть типизированы (PHP 8.5 typed properties)
- Класс должен быть immutable (изменения только через конструктор или named constructors)
- Класс должен иметь методы для получения полного имени на нужном языке

#### FR-1.2. Entity Name (Имя/Отчество)

Создать класс `Name` со следующими полями:

- `id: int` — уникальный идентификатор имени
- `userId: int` — владелец имени
- `translations: array<NameTranslation>` — переводы имени на разные языки

**Требования:**

- Класс должен иметь метод `getTranslation(string $language): ?NameTranslation` — получить перевод на нужный язык
- Класс должен иметь метод `getFallbackTranslation(): NameTranslation` — получить дефолтный перевод (если нет нужного языка)

#### FR-1.3. Value Object NameTranslation (Перевод имени на язык)

Создать value object `NameTranslation` со следующими полями:

- `language: string` — код языка (ru, en и т.д.)
- `name: string` — само имя
- `malePatronymic: ?string` — отчество для сына (Иванович)
- `femalePatronymic: ?string` — отчество для дочери (Ивановна)

**Требования:**

- Value object должен быть immutable
- Value object должен валидировать код языка (2-3 символа)
- Value object должен иметь метод `getPatronymic(Gender $gender): ?string` — получить отчество в зависимости от пола

#### FR-1.4. Entity Surname (Фамилия)

Создать класс `Surname` со следующими полями:

- `id: int` — уникальный идентификатор фамилии
- `userId: int` — владелец фамилии
- `translations: array<SurnameTranslation>` — переводы фамилии на разные языки

**Требования:**

- Класс должен иметь метод `getTranslation(string $language): ?SurnameTranslation` — получить перевод на нужный язык
- Класс должен иметь метод `getFallbackTranslation(): SurnameTranslation` — получить дефолтный перевод

#### FR-1.5. Value Object SurnameTranslation (Перевод фамилии на язык)

Создать value object `SurnameTranslation` со следующими полями:

- `language: string` — код языка
- `maleSurname: string` — мужская форма фамилии (Петров)
- `femaleSurname: string` — женская форма фамилии (Петрова)

**Требования:**

- Value object должен быть immutable
- Value object должен валидировать код языка (2-3 символа)
- Value object должен иметь метод `getSurname(Gender $gender): string` — получить фамилию в зависимости от пола

#### FR-1.6. Entity Relation (Связь между персонами)

Создать класс `Relation` со следующими полями:

- `personId1: int` — первая персона
- `personId2: int` — вторая персона
- `type: RelationType` — тип связи

**Требования:**

- Класс должен валидировать, что personId1 != personId2 (запрет самосвязей)
- Класс должен быть immutable

#### FR-1.7. Enum RelationType (Тип связи)

Создать enum `RelationType` со следующими значениями:

- `PARENT_CHILD` — Родитель → Ребенок
- `SPOUSE` — Супруг/Супруга

**Требования:**

- Enum должен иметь метод `toCode(): string` — преобразование в код для хранения в БД
- Enum должен иметь метод `fromCode(string $code): RelationType` — создание из кода БД

#### FR-1.8. Entity User (Пользователь-владелец дерева)

Создать класс `User` со следующими полями:

- `id: int` — уникальный идентификатор
- `login: string` — логин
- `email: string` — email
- `firstName: string` — имя пользователя
- `middleName: string` — отчество пользователя
- `surname: string` — фамилия пользователя

**Требования:**

- Класс должен валидировать email (корректный формат)
- Класс должен валидировать login (не пустой)

#### FR-1.9. Value Object Gender (Пол)

Создать enum `Gender` со следующими значениями:

- `MALE` — мужской
- `FEMALE` — женский
- `UNKNOWN` — неизвестный

**Требования:**

- Enum используется для выбора правильной гендерной формы имени/фамилии

**Критерии приемки FR-1:**

- ✅ Созданы классы entities: Person, Name, Surname, Relation, User
- ✅ Созданы классы value objects: NameTranslation, SurnameTranslation
- ✅ Созданы enums: Gender, RelationType
- ✅ Все классы используют строгую типизацию PHP 8.5 (typed properties, return types)
- ✅ Entities находятся в модуле Core (не зависят от фреймворка)
- ✅ Value objects являются immutable
- ✅ Entities валидируют свои данные (email, login, самосвязи)
- ✅ Есть методы для получения переводов на нужный язык
- ✅ Есть методы для получения гендерных форм (отчества, фамилии)

---

### FR-2. Создание интерфейсов репозиториев

**Приоритет:** Высокий

**Описание:**
Система должна иметь интерфейсы репозиториев для работы с доменными сущностями, определяющие контракты для чтения и записи данных.

**Детализация:**

#### FR-2.1. Interface PersonRepositoryInterface

Создать интерфейс `PersonRepositoryInterface` со следующими методами:

```php
interface PersonRepositoryInterface
{
    public function findById(int $id, string $language): ?Person;
    public function findByUserId(int $userId, string $language): array;
    public function save(Person $person): void;
    public function delete(int $id): void;
}
```

**Требования:**

- Метод `findById` возвращает персону с именами/фамилиями на указанном языке
- Метод `findByUserId` возвращает массив персон пользователя
- Метод `save` сохраняет или обновляет персону (определяет операцию автоматически)
- Метод `delete` удаляет персону по ID

#### FR-2.2. Interface NameRepositoryInterface

Создать интерфейс `NameRepositoryInterface` со следующими методами:

```php
interface NameRepositoryInterface
{
    public function findById(int $id): ?Name;
    public function findByUserId(int $userId): array;
    public function findByName(string $name, string $language, int $userId): ?Name;
    public function save(Name $name): void;
    public function delete(int $id): void;
}
```

**Требования:**

- Метод `findByName` ищет имя по тексту на конкретном языке у конкретного пользователя

#### FR-2.3. Interface SurnameRepositoryInterface

Создать интерфейс `SurnameRepositoryInterface` со следующими методами:

```php
interface SurnameRepositoryInterface
{
    public function findById(int $id): ?Surname;
    public function findByUserId(int $userId): array;
    public function findBySurname(string $surname, string $language, int $userId): ?Surname;
    public function save(Surname $surname): void;
    public function delete(int $id): void;
}
```

#### FR-2.4. Interface RelationRepositoryInterface

Создать интерфейс `RelationRepositoryInterface` со следующими методами:

```php
interface RelationRepositoryInterface
{
    public function findByPersonId(int $personId): array;
    public function findByUserId(int $userId): array;
    public function save(Relation $relation): void;
    public function delete(int $personId1, int $personId2, RelationType $type): void;
}
```

#### FR-2.5. Interface UserRepositoryInterface

Создать интерфейс `UserRepositoryInterface` со следующими методами:

```php
interface UserRepositoryInterface
{
    public function findById(int $id): ?User;
    public function findByLogin(string $login): ?User;
    public function save(User $user): void;
}
```

**Критерии приемки FR-2:**

- ✅ Созданы интерфейсы репозиториев для всех entities
- ✅ Интерфейсы находятся в модуле Core (не зависят от фреймворка)
- ✅ Методы интерфейсов используют доменные типы (Person, Name, Surname и т.д.)
- ✅ Интерфейсы не содержат зависимостей от Laravel или других библиотек

---

### FR-3. Реализация репозиториев для работы с БД

**Приоритет:** Высокий

**Описание:**
Система должна иметь реализации репозиториев, которые маппят доменные объекты на многоязычную схему БД через промежуточные таблицы.

**Детализация:**

#### FR-3.1. PersonRepository — Реализация репозитория персон

Создать класс `PersonRepository` (implements `PersonRepositoryInterface`) со следующей логикой:

**Метод findById(int $id, string $language): ?Person**

1. Прочитать запись из таблицы `gen_person` по ID
2. Если запись не найдена — вернуть null
3. Для каждого ID (FNAME_ID, SNAME_ID, SURNAME_ID, BSURNAME_ID):
   - Загрузить объект Name/Surname через соответствующий репозиторий
4. Прочитать информацию о персоне из `gen_person_info_lang` для указанного языка
5. Определить пол персоны (по умолчанию UNKNOWN, если не указано)
6. Создать и вернуть объект Person

**Требования:**

- Использовать eager loading для избежания N+1 проблемы
- Использовать Laravel Query Builder или Eloquent для работы с БД
- Обрабатывать NULL-значения (опциональные поля)

**Метод findByUserId(int $userId, string $language): array**

1. Прочитать все записи из таблицы `gen_person` с фильтром `WHERE USER_ID = ?`
2. Для каждой записи выполнить логику метода `findById`
3. Вернуть массив объектов Person

**Метод save(Person $person): void**

1. Если у Person есть новые Name/Surname (без ID):
   - Сохранить Name/Surname через соответствующие репозитории (получить ID)
2. Сохранить или обновить запись в таблице `gen_person` с ссылками на Name/Surname
3. Сохранить информацию в `gen_person_info_lang` для каждого языка из `$person->info`

**Метод delete(int $id): void**

1. Удалить связи персоны из таблицы `gen_relation` (WHERE PID1=? OR PID2=?)
2. Удалить информацию из `gen_person_info_lang` (WHERE PERSON_ID=?)
3. Удалить запись из таблицы `gen_person` (WHERE ID=?)

#### FR-3.2. NameRepository — Реализация репозитория имен

Создать класс `NameRepository` (implements `NameRepositoryInterface`) со следующей логикой:

**Метод findById(int $id): ?Name**

1. Прочитать запись из таблицы `gen_name` по ID
2. Если запись не найдена — вернуть null
3. Прочитать связи из `gen_mixed_name_lang` (WHERE NAME_ID=?)
4. Для каждой связи прочитать языковую запись из `gen_name_lang`
5. Создать массив объектов NameTranslation
6. Создать и вернуть объект Name

**Метод save(Name $name): void**

1. Если у Name нет ID — создать запись в `gen_name` с USER_ID
2. Если у Name есть ID — обновить не требуется (записи immutable)
3. Для каждого языка из `$name->translations`:
   - Создать запись в `gen_name_lang` (если её нет)
   - Создать связь в `gen_mixed_name_lang` (если её нет)

**Метод findByName(string $name, string $language, int $userId): ?Name**

1. Найти запись в `gen_name_lang` (WHERE FNAME=? AND LANG=?)
2. Прочитать связь из `gen_mixed_name_lang` для найденной записи
3. Получить NAME_ID из связи
4. Проверить, что имя принадлежит пользователю (gen_name.USER_ID=?)
5. Вызвать метод `findById(NAME_ID)`

#### FR-3.3. SurnameRepository — Реализация репозитория фамилий

Создать класс `SurnameRepository` (implements `SurnameRepositoryInterface`) с аналогичной логикой как у NameRepository:

- Работает с таблицами `gen_surname`, `gen_surname_lang`, `gen_mixed_surname_lang`
- Логика маппинга аналогична NameRepository

#### FR-3.4. RelationRepository — Реализация репозитория связей

Создать класс `RelationRepository` (implements `RelationRepositoryInterface`) со следующей логикой:

**Метод findByPersonId(int $personId): array**

1. Прочитать все записи из `gen_relation` (WHERE PID1=? OR PID2=?)
2. Для каждой записи создать объект Relation
3. Преобразовать RELATION_TYPE_ID в RelationType через код типа
4. Вернуть массив объектов Relation

**Метод save(Relation $relation): void**

1. Проверить, что связь не существует (по PID1, PID2, RELATION_TYPE_ID)
2. Получить RELATION_TYPE_ID из таблицы `gen_relation_type` по коду типа
3. Вставить запись в таблицу `gen_relation`

**Метод delete(int $personId1, int $personId2, RelationType $type): void**

1. Получить RELATION_TYPE_ID из таблицы `gen_relation_type` по коду типа
2. Удалить запись из `gen_relation` (WHERE PID1=? AND PID2=? AND RELATION_TYPE_ID=?)

#### FR-3.5. UserRepository — Реализация репозитория пользователей

Создать класс `UserRepository` (implements `UserRepositoryInterface`) со следующей логикой:

**Метод findById(int $id): ?User**

1. Прочитать запись из таблицы `gen_user` по ID
2. Создать и вернуть объект User

**Метод findByLogin(string $login): ?User**

1. Прочитать запись из таблицы `gen_user` по LOGIN
2. Создать и вернуть объект User

**Метод save(User $user): void**

1. Сохранить или обновить запись в таблице `gen_user`

**Критерии приемки FR-3:**

- ✅ Созданы реализации репозиториев для всех интерфейсов
- ✅ Репозитории находятся в модуле Infrastructure (зависят от Laravel)
- ✅ Репозитории корректно маппят доменные объекты на многоязычную схему БД
- ✅ Репозитории работают с промежуточными таблицами (`gen_mixed_name_lang`, `gen_mixed_surname_lang`)
- ✅ Репозитории поддерживают выбор языка при чтении данных
- ✅ Репозитории используют eager loading для избежания N+1 проблемы
- ✅ Репозитории обрабатывают NULL-значения (опциональные поля)
- ✅ Репозитории используют транзакции для save/delete операций

---

### FR-4. Регистрация репозиториев в DI-контейнере

**Приоритет:** Средний

**Описание:**
Система должна автоматически внедрять реализации репозиториев через DI-контейнер Laravel.

**Детализация:**

#### FR-4.1. Service Provider для регистрации репозиториев

Создать `RepositoryServiceProvider` со следующей логикой:

```php
class RepositoryServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->app->bind(PersonRepositoryInterface::class, PersonRepository::class);
        $this->app->bind(NameRepositoryInterface::class, NameRepository::class);
        $this->app->bind(SurnameRepositoryInterface::class, SurnameRepository::class);
        $this->app->bind(RelationRepositoryInterface::class, RelationRepository::class);
        $this->app->bind(UserRepositoryInterface::class, UserRepository::class);
    }
}
```

**Требования:**

- Service Provider должен быть зарегистрирован в `config/app.php`
- Репозитории должны создаваться как singleton (одна инстанция на запрос)

**Критерии приемки FR-4:**

- ✅ Создан RepositoryServiceProvider
- ✅ Service Provider зарегистрирован в config/app.php
- ✅ Репозитории автоматически внедряются через constructor injection
- ✅ Можно использовать репозитории в use cases без явного создания инстансов

---

### FR-5. Определение пола персоны

**Приоритет:** Средний

**Описание:**
Система должна определять пол персоны для корректного выбора гендерных форм имен и фамилий.

**Детализация:**

#### FR-5.1. Логика определения пола

На текущем этапе пол персоны определяется по следующей логике (в порядке приоритета):

1. **Если есть явное поле пола в БД** — использовать его (если такое поле будет добавлено в будущем)
2. **Если нет явного поля** — использовать Gender::UNKNOWN как дефолтное значение

**Примечание:** В будущем (на этапах 4-5) логика может быть расширена:

- Определение по окончанию фамилии (Петров — мужчина, Петрова — женщина)
- Определение по связям (если есть дети, можно определить пол по роли в связи)
- Ручное указание пола при создании/редактировании персоны

**Требования:**

- В текущей схеме БД нет поля для пола — использовать Gender::UNKNOWN
- При добавлении поля пола в БД — обновить логику маппинга в PersonRepository
- Gender::UNKNOWN должен обрабатываться корректно (выбор дефолтной формы имени/фамилии)

**Критерии приемки FR-5:**

- ✅ Каждая персона имеет поле gender типа Gender
- ✅ По умолчанию gender = Gender::UNKNOWN
- ✅ При Gender::UNKNOWN выбирается первая доступная форма имени/фамилии (например, мужская)
- ✅ Логика подготовлена для будущего расширения (добавление поля пола в БД)

---

## Нефункциональные требования

### NFR-1. Изоляция бизнес-логики от деталей реализации

**Описание:**
Доменные сущности и интерфейсы репозиториев не должны зависеть от фреймворка Laravel или конкретной СУБД.

**Критерии:**

- Entities и интерфейсы репозиториев находятся в модуле Core
- Core не имеет зависимостей от Laravel (не использует Eloquent, Facades и т.д.)
- Реализации репозиториев находятся в модуле Infrastructure
- Infrastructure может использовать Laravel и Eloquent

**Проверка:**

- Запустить статический анализ: проверить, что Core не зависит от Laravel
- Убедиться, что в Core нет `use Illuminate\*`

---

### NFR-2. Производительность при чтении персон

**Описание:**
Чтение персоны с именами/фамилиями должно выполняться за разумное время без N+1 проблемы.

**Критерии:**

- Метод `PersonRepository::findById` выполняет не более 10 SQL-запросов
- Метод `PersonRepository::findByUserId` использует eager loading
- Массив из 100 персон загружается за 1-2 секунды

**Проверка:**

- Измерить количество SQL-запросов через Laravel Debugbar
- Измерить время выполнения на тестовых данных (100 персон)

---

### NFR-3. Тестируемость

**Описание:**
Репозитории должны иметь интерфейсы для возможности мокирования в тестах.

**Критерии:**

- Все репозитории имеют интерфейсы
- Use cases зависят только от интерфейсов (не от конкретных реализаций)
- Можно создать mock-реализации репозиториев для unit-тестов

**Проверка:**

- Создать простой unit-тест use case с мокированием репозитория
- Убедиться, что тест работает без реальной БД

---

### NFR-4. Типобезопасность

**Описание:**
Весь код должен использовать строгую типизацию PHP 8.5.

**Критерии:**

- Все поля классов имеют типы (typed properties)
- Все методы имеют return types
- Используются nullable types (?) для опциональных полей
- Используются enums для перечислений (Gender, RelationType)

**Проверка:**

- Запустить PHPStan на уровне 8-9
- Убедиться, что нет ошибок типизации

---

### NFR-5. Архитектура Clean Architecture

**Описание:**
Код должен следовать принципам Clean Architecture: зависимости направлены внутрь, Core не зависит от Infrastructure.

**Критерии:**

- Entities находятся в `backend/src/Core/Domain/Entity/`
- Value objects находятся в `backend/src/Core/Domain/ValueObject/`
- Интерфейсы репозиториев находятся в `backend/src/Core/Domain/Repository/`
- Реализации репозиториев находятся в `backend/src/Infrastructure/Persistence/Repository/`
- Core не зависит от Infrastructure

**Проверка:**

- Проверить структуру директорий
- Запустить статический анализ зависимостей

---

## Модель предметной области

### Основные Entity (сущности)

#### Person (Персона)

**Описание:** Человек в генеалогическом древе.

**Атрибуты:**

- `id: int` — уникальный идентификатор
- `userId: int` — владелец дерева
- `firstName: Name` — имя (многоязычное)
- `middleName: ?Name` — отчество (опционально)
- `surname: ?Surname` — текущая фамилия (опционально)
- `birthSurname: ?Surname` — девичья фамилия (опционально)
- `birthDate: ?DateTime` — дата рождения
- `deathDate: ?DateTime` — дата смерти
- `info: array<string, string>` — описание по языкам
- `gender: Gender` — пол персоны

**Методы:**

- `getFullName(string $language): string` — получить полное имя на нужном языке
- `getAge(): ?int` — получить возраст (если известна дата рождения)
- `isAlive(): bool` — жив ли человек (проверка deathDate)

---

#### Name (Имя/Отчество)

**Описание:** Многоязычное имя с гендерными формами отчеств.

**Атрибуты:**

- `id: int` — уникальный идентификатор
- `userId: int` — владелец имени
- `translations: array<NameTranslation>` — переводы на языки

**Методы:**

- `getTranslation(string $language): ?NameTranslation` — получить перевод
- `getFallbackTranslation(): NameTranslation` — получить дефолтный перевод

---

#### Surname (Фамилия)

**Описание:** Многоязычная фамилия с гендерными формами.

**Атрибуты:**

- `id: int` — уникальный идентификатор
- `userId: int` — владелец фамилии
- `translations: array<SurnameTranslation>` — переводы на языки

**Методы:**

- `getTranslation(string $language): ?SurnameTranslation` — получить перевод
- `getFallbackTranslation(): SurnameTranslation` — получить дефолтный перевод

---

#### Relation (Связь)

**Описание:** Связь между двумя персонами в генеалогическом древе.

**Атрибуты:**

- `personId1: int` — первая персона
- `personId2: int` — вторая персона
- `type: RelationType` — тип связи

---

#### User (Пользователь)

**Описание:** Владелец генеалогического древа.

**Атрибуты:**

- `id: int` — уникальный идентификатор
- `login: string` — логин
- `email: string` — email
- `firstName: string` — имя
- `middleName: string` — отчество
- `surname: string` — фамилия

---

### Value Objects (объекты-значения)

#### NameTranslation (Перевод имени)

**Описание:** Языковой вариант имени с гендерными формами отчеств.

**Атрибуты:**

- `language: string` — код языка (ru, en)
- `name: string` — само имя
- `malePatronymic: ?string` — отчество для сына
- `femalePatronymic: ?string` — отчество для дочери

**Методы:**

- `getPatronymic(Gender $gender): ?string` — получить отчество по полу

---

#### SurnameTranslation (Перевод фамилии)

**Описание:** Языковой вариант фамилии с гендерными формами.

**Атрибуты:**

- `language: string` — код языка
- `maleSurname: string` — мужская форма
- `femaleSurname: string` — женская форма

**Методы:**

- `getSurname(Gender $gender): string` — получить фамилию по полу

---

### Enumerations (перечисления)

#### Gender (Пол)

**Значения:**

- `MALE` — мужской
- `FEMALE` — женский
- `UNKNOWN` — неизвестный

---

#### RelationType (Тип связи)

**Значения:**

- `PARENT_CHILD` — Родитель → Ребенок
- `SPOUSE` — Супруг/Супруга

**Методы:**

- `toCode(): string` — преобразование в код БД ('parent_child', 'spouse')
- `fromCode(string $code): RelationType` — создание из кода БД

---

### Диаграмма связей доменных объектов

```
┌─────────────┐
│    User     │◄──────┐
└─────────────┘       │
       │              │
       │ owns         │ owns
       ▼              │
┌─────────────┐       │
│   Person    │       │
└─────────────┘       │
       │              │
       ├──────────────┘
       │
       ├──────► Name ──────► NameTranslation
       │           (имя)         (перевод)
       │
       ├──────► Name ──────► NameTranslation
       │        (отчество)       (перевод)
       │
       ├──────► Surname ──────► SurnameTranslation
       │       (фамилия)           (перевод)
       │
       ├──────► Surname ──────► SurnameTranslation
       │      (девичья)            (перевод)
       │
       └──────► Relation ──────► RelationType
                  │                  (enum)
                  └──────► Person (другая персона)
```

---

## Зависимости

### Внешние зависимости

- **Laravel 12** — фреймворк для реализации Infrastructure
- **PHP 8.5** — язык программирования
- **SQLite** — СУБД с готовой схемой и данными

### Внутренние зависимости

Этот этап (Stage 2) **зависит** от:

- **Stage 1** (TZ1_01) — требует готовую схему БД с мигрированными данными

Этот этап **является блокирующим** для:

- **Stage 3** — Просмотр дерева (требует репозитории для чтения данных)
- **Stage 4** — Управление персонами (требует репозитории для записи данных)
- **Stage 5** — Управление связями (требует RelationRepository)

---

## Сценарии использования

### UC-1. Разработчик создает use case для просмотра персоны

**Актор:** Разработчик

**Предусловия:**

- Репозитории реализованы и зарегистрированы в DI-контейнере
- БД содержит данные персон

**Основной сценарий:**

1. Разработчик создает класс use case `GetPersonByIdUseCase`
2. В конструкторе use case объявляет зависимость от `PersonRepositoryInterface`
3. Laravel автоматически внедряет реализацию `PersonRepository` через DI
4. В методе `execute(int $personId, string $language)`:
   - Вызывает `$repository->findById($personId, $language)`
   - Получает объект `Person` с именами/фамилиями на нужном языке
5. Работает с доменной моделью без знания о структуре БД
6. Возвращает DTO для контроллера/API

**Постусловия:**

- Разработчик работает с доменными объектами, а не с таблицами БД
- Бизнес-логика не зависит от деталей реализации БД

---

### UC-2. Разработчик добавляет новую персону

**Актор:** Разработчик

**Предусловия:**

- Репозитории реализованы
- Есть данные для создания персоны (имя, фамилия на русском и английском)

**Основной сценарий:**

1. Разработчик создает use case `CreatePersonUseCase`
2. В use case получает `PersonRepository`, `NameRepository`, `SurnameRepository` через DI
3. Создает объекты `NameTranslation` для русского и английского языков:
   - Русский: name="Иван", malePatronymic="Иванович", femalePatronymic="Ивановна"
   - Английский: name="John", malePatronymic="John's", femalePatronymic="John's"
4. Создает объект `Name` с переводами
5. Сохраняет имя через `$nameRepository->save($name)` — получает ID
6. Аналогично создает и сохраняет `Surname`
7. Создает объект `Person` с ссылками на Name и Surname
8. Сохраняет персону через `$personRepository->save($person)`
9. Репозиторий автоматически:
   - Создает записи в `gen_name`, `gen_name_lang`, `gen_mixed_name_lang`
   - Создает записи в `gen_surname`, `gen_surname_lang`, `gen_mixed_surname_lang`
   - Создает запись в `gen_person` со ссылками на Name/Surname

**Постусловия:**

- Персона сохранена в БД со всеми языковыми вариантами
- Разработчик не писал SQL-запросы напрямую
- Вся логика маппинга скрыта в репозиториях

---

### UC-3. Система отображает имя персоны с правильной гендерной формой

**Актор:** Система

**Предусловия:**

- Персона имеет имя "Иван" (переводы: ru="Иван", en="John")
- Персона имеет пол Gender::MALE

**Основной сценарий:**

1. Система загружает персону через `PersonRepository::findById($id, 'ru')`
2. Получает объект `Person` с именем `Name`
3. Запрашивает имя на русском языке:
   - `$person->firstName->getTranslation('ru')` возвращает `NameTranslation`
   - `$nameTranslation->name` = "Иван"
4. Запрашивает отчество для потомка мужского пола:
   - `$nameTranslation->getPatronymic(Gender::MALE)` = "Иванович"
5. Запрашивает отчество для потомка женского пола:
   - `$nameTranslation->getPatronymic(Gender::FEMALE)` = "Ивановна"
6. Система использует правильную форму в зависимости от пола потомка

**Постусловия:**

- Гендерные формы выбираются корректно
- Система поддерживает многоязычность

---

### UC-4. Разработчик тестирует use case без реальной БД

**Актор:** Разработчик

**Предусловия:**

- Use case зависит от интерфейса репозитория (не от конкретной реализации)
- Установлен PHPUnit

**Основной сценарий:**

1. Разработчик создает unit-тест для use case
2. Создает mock-объект `PersonRepositoryInterface` с помощью PHPUnit:
   ```php
   $mockRepository = $this->createMock(PersonRepositoryInterface::class);
   ```
3. Настраивает поведение mock-репозитория:
   ```php
   $mockRepository->method('findById')
       ->willReturn($testPerson);
   ```
4. Передает mock-репозиторий в use case через конструктор
5. Вызывает метод use case
6. Проверяет результат без обращения к реальной БД

**Постусловия:**

- Unit-тест выполняется быстро (без БД)
- Бизнес-логика тестируется изолированно

---

### UC-5. Разработчик получает список всех персон пользователя

**Актор:** Разработчик

**Предусловия:**

- В БД есть пользователь с ID=1
- У пользователя есть 10 персон в генеалогическом древе

**Основной сценарий:**

1. Разработчик создает use case `GetUserPersonsUseCase`
2. В use case вызывает `$personRepository->findByUserId(1, 'ru')`
3. Репозиторий выполняет:
   - Один запрос для загрузки всех персон пользователя
   - Eager loading для загрузки имен/фамилий (избежание N+1)
   - Фильтрацию по языку 'ru'
4. Получает массив из 10 объектов `Person`
5. Для каждой персоны доступны имена/фамилии на русском языке
6. Система выводит список персон с полными именами

**Постусловия:**

- Загружены все персоны пользователя за минимальное количество запросов
- Нет N+1 проблемы

---

## Риски

### Риск 1. Сложность маппинга многоязычной модели

**Описание:**
Многоязычная схема с промежуточными таблицами (`gen_mixed_name_lang`, `gen_mixed_surname_lang`) требует аккуратного маппинга в репозиториях.

**Вероятность:** Средняя

**Влияние:** Высокое

**Меры снижения:**

- Детально проработать логику маппинга в спецификации (FR-3)
- Написать integration-тесты для репозиториев на реальных данных
- Использовать Laravel Eloquent relationships для упрощения JOIN-запросов
- Документировать логику маппинга с примерами SQL-запросов

**План реагирования:**

- Если маппинг работает некорректно — добавить отладочное логирование SQL-запросов
- Использовать Laravel Debugbar для анализа запросов

---

### Риск 2. Производительность N+1 при загрузке персон

**Описание:**
Если не использовать eager loading, загрузка 100 персон может выполнить тысячи SQL-запросов.

**Вероятность:** Высокая (если не применить меры)

**Влияние:** Критическое

**Меры снижения:**

- Использовать Laravel eager loading (`with()`) для предзагрузки связей
- Измерить количество запросов через Laravel Debugbar
- Написать тесты производительности на 100+ персонах

**План реагирования:**

- Если обнаружена N+1 проблема — добавить eager loading в методы репозитория
- Оптимизировать запросы через Query Builder

---

### Риск 3. Неполнота языковых данных в БД

**Описание:**
Если в БД не все имена/фамилии имеют переводы на нужный язык, система может не найти перевод.

**Вероятность:** Средняя

**Влияние:** Среднее

**Меры снижения:**

- Реализовать fallback-логику: если нет перевода на нужный язык — использовать первый доступный
- Метод `Name::getFallbackTranslation()` возвращает дефолтный перевод
- Логировать случаи отсутствия переводов для анализа

**План реагирования:**

- Если обнаружены пробелы в данных — добавить переводы через миграции или команды

---

### Риск 4. Неопределенность пола персоны

**Описание:**
В текущей схеме БД нет поля для хранения пола персоны, поэтому невозможно автоматически выбрать правильную гендерную форму.

**Вероятность:** Высокая (известный факт)

**Влияние:** Среднее

**Меры снижения:**

- Использовать Gender::UNKNOWN как дефолтное значение
- При Gender::UNKNOWN выбирать первую доступную форму (например, мужскую)
- Подготовить схему для добавления поля пола в будущем (миграция на этапе 4)

**План реагирования:**

- На этапе 4 добавить поле пола в таблицу `gen_person`
- Обновить логику маппинга в `PersonRepository`

---

### Риск 5. Сложность тестирования репозиториев

**Описание:**
Тестирование репозиториев требует реальной БД, что усложняет написание тестов.

**Вероятность:** Средняя

**Влияние:** Среднее

**Меры снижения:**

- Использовать тестовую БД SQLite in-memory для integration-тестов
- Подготовить фикстуры с тестовыми данными
- Использовать Laravel Database Transactions для отката изменений после тестов

**План реагирования:**

- Если тесты работают медленно — использовать in-memory SQLite
- Если тесты нестабильны — проверить изоляцию транзакций

---

## Критерии приемки

### Критерии приемки этапа

Этап считается завершенным, если выполнены **все** следующие критерии:

#### Критерии по доменным сущностям

- ✅ Созданы классы entities: Person, Name, Surname, Relation, User
- ✅ Созданы классы value objects: NameTranslation, SurnameTranslation
- ✅ Созданы enums: Gender, RelationType
- ✅ Все классы используют строгую типизацию PHP 8.5 (typed properties, return types)
- ✅ Entities находятся в модуле Core (backend/src/Core/Domain/Entity/)
- ✅ Value objects находятся в модуле Core (backend/src/Core/Domain/ValueObject/)
- ✅ Entities валидируют свои данные (email, login, самосвязи)
- ✅ Есть методы для получения переводов на нужный язык
- ✅ Есть методы для получения гендерных форм (отчества, фамилии)

#### Критерии по интерфейсам репозиториев

- ✅ Созданы интерфейсы: PersonRepositoryInterface, NameRepositoryInterface, SurnameRepositoryInterface, RelationRepositoryInterface, UserRepositoryInterface
- ✅ Интерфейсы находятся в модуле Core (backend/src/Core/Domain/Repository/)
- ✅ Интерфейсы не содержат зависимостей от Laravel или других библиотек
- ✅ Методы интерфейсов используют доменные типы

#### Критерии по реализации репозиториев

- ✅ Созданы реализации: PersonRepository, NameRepository, SurnameRepository, RelationRepository, UserRepository
- ✅ Репозитории находятся в модуле Infrastructure (backend/src/Infrastructure/Persistence/Repository/)
- ✅ Репозитории корректно маппят доменные объекты на многоязычную схему БД
- ✅ Репозитории работают с промежуточными таблицами (gen_mixed_name_lang, gen_mixed_surname_lang)
- ✅ Репозитории поддерживают выбор языка при чтении данных
- ✅ Репозитории используют eager loading для избежания N+1 проблемы
- ✅ Репозитории обрабатывают NULL-значения (опциональные поля)
- ✅ Репозитории используют транзакции для save/delete операций

#### Критерии по DI-контейнеру

- ✅ Создан RepositoryServiceProvider
- ✅ Service Provider зарегистрирован в config/app.php
- ✅ Репозитории автоматически внедряются через constructor injection
- ✅ Можно использовать репозитории в use cases без явного создания инстансов

#### Критерии по функциональности

- ✅ Можно создать персону с многоязычными именами/фамилиями через PersonRepository
- ✅ Можно прочитать персону и получить имена/фамилии на нужном языке
- ✅ Гендерные формы отчеств и фамилий выбираются корректно в зависимости от пола персоны
- ✅ Девичья фамилия (birthSurname) корректно сохраняется и читается
- ✅ Fallback-логика работает: если нет перевода на нужный язык, возвращается дефолтный

#### Критерии по тестам

- ✅ Написаны unit-тесты для entities и value objects
- ✅ Написаны integration-тесты для репозиториев (работа с реальной БД)
- ✅ Тесты проверяют корректность маппинга многоязычных данных
- ✅ Тесты проверяют выбор гендерных форм
- ✅ Тесты проверяют fallback-логику (отсутствие перевода)
- ✅ Тесты проверяют производительность (отсутствие N+1)

#### Критерии по документации

- ✅ Обновлена документация Doc/Database/Schema.md с описанием доменной модели
- ✅ Добавлены примеры использования репозиториев
- ✅ Документированы правила маппинга доменных объектов на таблицы БД
- ✅ Документированы методы entities и value objects

#### Критерии по качеству кода

- ✅ Код соответствует стилю проекта (Doc/Rule/CodeStyle.md)
- ✅ Код проходит статический анализ PHPStan уровня 8-9 без ошибок
- ✅ Код проходит проверку PHP_CodeSniffer без ошибок
- ✅ Код следует принципам Clean Architecture (Core не зависит от Infrastructure)
- ✅ Используются строгие типы (declare(strict_types=1))

---

## Не входит в реализацию

Следующие функции **НЕ входят** в реализацию текущего этапа и будут реализованы на последующих этапах:

### Не входит в Stage 2

- ❌ **Use cases для просмотра/создания/редактирования персон** — будут реализованы на Stage 3-4
- ❌ **API эндпоинты для работы с персонами** — будут реализованы на Stage 3-4
- ❌ **Пользовательский интерфейс (UI)** — будет реализован на Stage 3-6
- ❌ **Аутентификация и авторизация** — будет реализована на Stage 7
- ✅ **Определение пола персоны** — на текущем этапе используется Gender::UNKNOWN, полноценная реализация будет на Stage 4
- ❌ **Валидация бизнес-правил** — будет реализована в use cases на Stage 4-5
- ❌ **Каскадные удаления** — будут реализованы в use cases на Stage 5
- ❌ **Визуализация генеалогического древа** — будет реализована на Stage 6
- ❌ **E2E-тесты пользовательских сценариев** — будут написаны на Stage 3-6
- ❌ **Оптимизация производительности для больших деревьев** — будет выполнена на Stage 6-7

### Допущения текущего этапа

На текущем этапе допускаются следующие упрощения:

- ✅ **Gender::UNKNOWN как дефолтное значение** — полноценное определение пола будет на Stage 4
- ✅ **Fallback на первый доступный язык** — если нет перевода на нужный язык
- ✅ **Отсутствие валидации бизнес-правил** — например, проверки дублирующих персон
- ✅ **Минимальная валидация в entities** — только критичные проверки (email, самосвязи)
- ✅ **Отсутствие событий (events)** — будут добавлены при необходимости на следующих этапах

---

## Дополнительные замечания

### Важные особенности реализации

1. **Маппинг через промежуточные таблицы критичен:** Неправильная работа с `gen_mixed_name_lang` и `gen_mixed_surname_lang` приведет к потере связей между именами/фамилиями и их переводами.

2. **Eager loading обязателен:** Без eager loading загрузка 100 персон выполнит тысячи SQL-запросов (N+1 проблема).

3. **Fallback-логика необходима:** В реальных данных могут отсутствовать переводы на некоторые языки — нужен fallback на дефолтный язык.

4. **Immutability value objects:** NameTranslation и SurnameTranslation должны быть immutable для предсказуемости и безопасности.

5. **Типизация критична:** Использование строгих типов PHP 8.5 предотвращает множество ошибок на этапе разработки.

6. **Транзакции для save/delete:** Все операции записи должны выполняться в транзакциях для обеспечения целостности данных.

### Рекомендации по реализации

1. **Начать с entities и value objects:** Сначала реализовать доменную модель, затем интерфейсы репозиториев, затем реализации.

2. **Тестировать каждый слой отдельно:** Unit-тесты для entities/value objects, integration-тесты для репозиториев.

3. **Использовать Laravel Eloquent relationships:** Для упрощения работы с промежуточными таблицами.

4. **Логировать SQL-запросы:** При разработке включить логирование SQL для отладки маппинга.

5. **Проверять производительность регулярно:** Измерять количество SQL-запросов и время выполнения на тестовых данных.

---

## Глоссарий

- **Entity** — доменная сущность с уникальным идентификатором и жизненным циклом
- **Value Object** — объект-значение без идентификатора, определяется только своими атрибутами
- **Repository** — паттерн для абстракции доступа к данным
- **Маппинг** — преобразование данных между доменной моделью и схемой БД
- **Eager loading** — предварительная загрузка связанных данных для избежания N+1 проблемы
- **N+1 проблема** — ситуация, когда загрузка N объектов выполняет N+1 SQL-запросов
- **Fallback** — резервный вариант (дефолтный язык, если нет нужного)
- **Immutable** — объект, который нельзя изменить после создания
- **DI-контейнер** — механизм автоматического внедрения зависимостей
- **Гендерная форма** — разная форма слова для мужчин и женщин (Иванович/Ивановна)
- **Промежуточная таблица** — таблица для связи многие-ко-многим (gen_mixed_name_lang)
- **Clean Architecture** — архитектурный подход с разделением на слои и направлением зависимостей внутрь

---

**Конец спецификации TZ1_02**
