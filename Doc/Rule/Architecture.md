# Архитектура проекта

## Design Patterns & Principles

1. **CQRS (Command Query Responsibility Segregation)**
2. **Clean Architecture**
   - Многослойная архитектура с четкими зависимостями
   - Доменно-ориентированное проектирование
   - Бизнес-логика, независимая от фреймворка
3. **Modular Monolith**
   - Независимые модули
   - Модульные API и контракты
   - Четкие границы модулей

## Ключевые соглашения

- **Модуль**: Максимально самодостаточная часть продукта, отвечающая за определённый функционал.
  Каждый модуль может содержать публичные доменные интерфейсы, сущности или события, определяющие границы его использования (API модуля).

- **UseCase**: Реализация конкретного варианта поведения пользователя (описывает, что пользователь хочет сделать).

- **DTO** (Data Transfer Object): Типизированная структура данных для передачи между слоями и модулями.

- **События** (Event): Специализированный DTO для информирования других модулей о произошедшем событии. Три типа:
  - **Уведомления** (Notification): Сообщение о завершённом действии в прошлом. Может быть синхронным или асинхронным. Много получателей возможно. Пример: *пациент был зарегистрирован*.
  - **Запросы** (Query): Синхронный запрос на получение данных. Ровно один получатель (один ответ). Пример: *получить историю пациента*.
  - **Команды** (Command): Синхронное указание другому модулю выполнить действие (создать, изменить, удалить данные). Ровно один получатель (одна обработка). Пример: *создать запись в журнале*.

## Структура директорий в модуле

### Application

Содержит реализацию бизнес-логики модуля:

- **UseCase**: Основной класс, реализующий вариант использования. Координирует работу Command, Query, Service.
- **Command**: Команды CQRS для изменения данных (создание, обновление, удаление). Например, БД.
- **Query**: Запросы CQRS для получения данных. Например, БД.
- **Service**: Самодостаточная реализация специфичной логики (не зависит от фреймворка). Пример: калькулятор, парсер, валидатор.
- **Dto**: Объекты для передачи данных внутри Application слоя.
- **Factory**: Фабричные методы для создания DTO, Response, ValueObject.
- **Responder**: Генераторы специального контента вместо JSON (Excel, PDF, email). Содержит шаблоны и генераторы.
  - **Template** - Любые шаблоны: email, Excel/Word, сообщения в Telegram.
  - **{FileName}.php** - Генератор ответа из шаблона. Например: `CreateTaxExcelReport.php`

**Пример структуры:**

```php
Patient/
├── Application/
│   ├── UseCase/
│   │   ├── CreatePatient.php
│   │   └── GetPatientHistory.php
│   ├── Command/
│   │   └── CreatePatientCommand.php
│   ├── Query/
│   │   └── GetPatientsByAgeQuery.php
│   ├── Service/
│   │   └── PatientAgeValidator.php
│   ├── Dto/
│   │   └── CreatePatientDto.php
│   └── Factory/
│       └── PatientFactory.php
```

### Domain

Предметная область. 
Публичное API модуля. 
Все сущности отсюда доступны вне модуля:

- **{InterfaceName}.php**: Контракты (интерфейсы) для инверсии зависимостей и взаимодействия модулей.
- **Request**: DTO входящих данных в Controller/Console.
- **Response**: DTO исходящих данных из Controller.
- **Dto**: Структуры для передачи между модулями и слоями.
- **Entity**: Описание структуры таблицы БД (используется в Command и Repository).
- **ValueObject**: Узкоспециализированный DTO с встроенной валидацией. Immutable.
- **Validation**: Классы для проверки бизнес-требований к данным.
- **Event**: Уведомления, Запросы, Команды для взаимодействия между модулями.
- **Exception**: Доменные исключения об ошибках в Application слое.
- **Doc**: Документация модуля и его API.

**Пример структуры:**

```php
Patient/
├── Domain/
│   ├── Doc/
│   │   ├── Diagram.md
│   │   └── FreshDeskApi.md
│   ├── PatientRepositoryInterface.php
│   ├── Request/
│   │   └── CreatePatientRequest.php
│   ├── Response/
│   │   └── PatientResponse.php
│   ├── Entity/
│   │   └── Patient.php
│   ├── ValueObject/
│   │   ├── PatientId.php
│   │   └── Email.php
│   ├── Validation/
│   │   └── PatientAgeValidation.php
│   ├── Event/
│   │   └── PatientCreatedNotification.php
│   └── Exception/
│       └── PatientNotFoundException.php
```

### Infrastructure

Реализация интеграций с внешними системами (Anti-corruption layer):

- **Repository**: Упрощённый CQRS для доступа к БД. Преобразует Entity в Eloquent модели.
- **Adapter**: Реализует Domain интерфейсы для работы с внешними сервисами и другими модулями.
- **{ServiceName}**: Адаптеры для взаимодействия с vendor библиотеками.

**Пример структуры:**

```text
Patient/
├── Infrastructure/
│   └── Adapter/
│       └── ExternalMedicalServiceAdapter.php
```

### Presentation

Точка входа и выхода из модуля:

- **Http/Controller**: HTTP контроллеры для обработки REST запросов.
- **Http/Middleware**: Middleware компоненты.
- **Http/View**: HTML шаблоны.
- **Console**: Крон-скрипты, демоны, консольные команды.
- **Listener**: Подписчики на доменные события.
- **Config**: Конфигурация модуля (environment, DI,Service Container, routing).

**Пример структуры:**

```text
Patient/
├── Presentation/
│   ├── Http/
│   │   ├── Controller/
│   │       └── PatientController.php
│   ├── Console/
│   │   └── SyncPatientsCommand.php
│   ├── Listener/
│   │   └── PatientCreatedListener.php
│   └── Config/
│       └── PatientServiceProvider.php
```

Это "максимальная" сложность одного модуля. Не требуется создавать все папки сразу.

## Структура директорий в проекте

- **backend** - реализация REST API и Консольных команд
  - **bootstrap** - Файлы инициализации приложения Laravel
  - **config** - Файлы конфигурации Laravel
  - **database**
    - **migrations** - Файлы с миграциями в БД
    - **storage** - Хранение файлов SQLite
  - **src**
    - **Core** - Ядро приложения. Общепроектные события, исключения, обертки над фреймворком и vendor. Структура аналогична модулю.
    - **{ModuleName}** - Модули функциональности (структура как описано выше).
  - **tests**
    - **Architecture** - Архитектурные тесты.
    - **Suite** - Набор тестов приложения.
      - **{ModuleName}** - Тесты модуля.
    - **Stub** - Все необходимое для выполнения тестов. Например: универсальный fake-jwt.
      - **ModelFactory** - Файлы для генерации записей в БД для проведения тестирования  
    - **TestCase.php** - Абстрактный класс-обертка над фреймворком.

- **docker** - Файлы для сборки Docker контейнеров.
- **mock-server** - Конфигурация для [HTTP mock server](https://github.com/jmartin82/mmock)

## Правила зависимостей между слоями

**Каждый слой может использовать только свой и нижестоящие слои:**

| Слой | Может использовать                                                   |
|------|----------------------------------------------------------------------|
| **Presentation** | Infrastructure (только своего модуля), Application (только своего модуля), Domain (своего модуля и чужих)          |
| **Infrastructure** | Application (только своего модуля), Domain (своего и чужих модулей)                         |
| **Application** | Application (только своего модуля), Domain (предпочтительно только своего модуля) |
| **Domain** | Domain (своего и чужих модулей)                                      |

**Внедрение зависимостей (DI):**

- Не требуется создавать интерфейс, если существует одна реализация. НО для использования Infrastructure-реализации в Application слое обязательно создайте интерфейс в Domain.
- Пример: Application использует `AuthenticationRepositoryInterface` (определена в Domain), которую реализует `DatabaseAuthenticationRepository` (в Infrastructure).

## Зависимости между модулями

Модуль должен быть максимально не зависим от других модулей, кроме "Core".

Модули могут взаимодействовать между собой двумя способами:

1. **Синхронно через интерфейсы**: "Модуль A" использует Domain интерфейсы "модуля B" через Anti-corruption layer (Adapter в Infrastructure).
2. **Синхронно/Асинхронно через события**: "Модуль A" генерирует Domain Event, подписчики (Listener) других модулей его обрабатывают.

## Когда создавать интерфейсы

Интерфейс (контракт) обязателен в следующих случаях:

1. **В рамках модуля**: Существует 2+ реализации функциональности.
   - Пример: `CacheRepository` и `DatabaseRepository` оба реализуют `RepositoryInterface`.
2. **Для инверсии зависимостей**: Application слой зависит от Domain интерфейса, который реализует Infrastructure.
3. **Для взаимодействия модулей**: При использовании функциональности из другого модуля всегда через его Domain интерфейс.

## Валидация и типизация

### На уровне Controller (Presentation)

Валидируются **структурные** характеристики данных:

- Обязательность полей (required / nullable).
- Типы полей (string, int, array, и т.д.).
- Базовые форматы (email, date, и т.д.).
- Цель: Гарантировать, что можно создать типизированный DTO из входящего запроса.

**Инструменты:** ValidationInterface `$this->validator->validateData()`.

### На уровне UseCase (Application)

Валидируются **бизнес-требования** к данным:

- Логические ограничения (пациент старше 18 лет?).
- Состояния (можно ли выполнить действие в текущем статусе?).
- Доступность (есть ли доступ к ресурсу?).
- Цель: Гарантировать корректность бизнес-процесса.

**Инструменты:** Validation классы в Domain, проверки в UseCase или Service.

### Для сложных входных данных

Выносите логику парсинга и валидации из Controller:

```php
// В Controller:
$patientDto = PatientFactory::createFromRequest($request->validated());

// Или в Domain (ValueObject):
$email = new Email($request->input('email'));
```

### Типизация DTO

- **Public и Protected методы**: Используйте типизированные DTO как параметры и возвращаемые значения.
- **Private методы**: Допускается использование ассоциативных массивов.
- **Цель**: Обеспечить type safety и документировать контракт публичных методов.

## Гранулярность ответственности в классе

### Оставлять методы в одном классе, если:

- Зависимость из конструктора используется в **нескольких методах** для похожей функциональности.
- Методы отвечают за одну зону ответственности.

### Разделять на разные классы, если:

- Зависимость из конструктора используется в **2 методах из 5+**.
- Это указывает на разделение ответственности.
- Пример: Создание отдельного `NotificationService` вместо загрузки в основной UseCase.
- **Преимущество**: Избегаете загрузки неиспользуемых зависимостей, улучшаете тестируемость.
