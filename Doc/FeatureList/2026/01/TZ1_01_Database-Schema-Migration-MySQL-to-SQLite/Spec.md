# Спецификация бизнес-требований TZ1_01

## Метаинформация

- **Номер задачи:** TZ1_01
- **Эпик:** TZ1 — Веб-сайт семейного генеалогического древа
- **Этап:** Stage 1 — Миграция схемы БД MySQL → SQLite и проверка целостности данных
- **Дата создания:** 2026-01-21
- **Статус:** Черновик

## Описание проблемы/потребности

### Контекст

В проекте существует готовая схема базы данных MySQL с реальными данными семейного генеалогического древа, хранящаяся в файле `backend/database/migrations/structure.sql`. Эта схема содержит информацию о персонах, их именах, фамилиях (с поддержкой многоязычности и гендерных форм), а также связях между родственниками.

Текущий стек проекта использует SQLite в качестве СУБД и Laravel для управления миграциями. Существующий SQL-файл содержит MySQL-специфичный синтаксис и не может быть напрямую применен в SQLite.

### Проблема

**КРИТИЧНО:** Необходимо перенести существующую схему БД и данные из MySQL в SQLite без потери информации, сохранив все связи и целостность данных.

Основные проблемы:

1. **Несовместимость синтаксиса:** MySQL использует конструкции (`auto_increment`, `charset=utf8`, `row_format=COMPACT`), которые не поддерживаются в SQLite
2. **Различия в типах данных:** MySQL `int unsigned`, `datetime`, `mediumtext` требуют адаптации под SQLite
3. **Риск потери данных:** при экспорте/импорте могут быть потеряны или искажены данные (особенно кириллица)
4. **Неполнота схемы:** отсутствует таблица типов связей (`gen_relation_type`), на которую ссылается поле `RELATION_TYPE_ID` в таблице `gen_relation`
5. **Отсутствие валидации целостности:** нет механизма проверки корректности существующих данных (битые связи, NULL-значения, несуществующие ID)

### Бизнес-ценность решения

Успешная миграция обеспечит:

- **Сохранность данных:** вся информация о семейном древе будет перенесена в новое окружение без потерь
- **Воспроизводимость:** возможность развернуть проект в любом окружении через Docker/Makefile
- **Демонстрируемость:** стейкхолдеры смогут увидеть работающую систему с реальными данными
- **Основу для развития:** корректная схема БД и данные позволят переходить к следующим этапам разработки
- **Снижение рисков:** ранняя валидация данных выявит проблемы до начала разработки бизнес-логики

## Функциональные требования

### FR-1. Создание Laravel-миграций для всех таблиц

**Приоритет:** Высокий

**Описание:**
Система должна иметь набор Laravel-миграций, воспроизводящих структуру всех таблиц из `structure.sql` с адаптацией синтаксиса под SQLite.

**Детализация:**

#### FR-1.1. Основные таблицы данных

Должны быть созданы миграции для следующих таблиц:

- `gen_user` — пользователи системы (владельцы генеалогических деревьев)
- `gen_person` — персоны в генеалогическом древе
- `gen_relation` — связи между персонами
- `gen_name` — основная таблица имен
- `gen_name_lang` — языковые варианты имен с гендерными формами отчеств
- `gen_surname` — основная таблица фамилий
- `gen_surname_lang` — языковые варианты фамилий с гендерными формами
- `gen_mixed_name_lang` — связь имен с языковыми вариантами
- `gen_mixed_surname_lang` — связь фамилий с языковыми вариантами
- `gen_person_info_lang` — многоязычные описания персон

#### FR-1.2. Вспомогательные таблицы

Должны быть созданы миграции для следующих вспомогательных таблиц:

- `gen_user_right` — права пользователей
- `gen_menu` — структура меню системы
- `gen_menu_order` — порядок пунктов меню
- `gen_message` — сообщения/контент сайта
- `gen_message_text` — текст сообщений
- `gen_mixed_menu_mess` — связь меню и сообщений

#### FR-1.3. Адаптация типов данных MySQL → SQLite

Миграции должны корректно преобразовывать MySQL-типы в SQLite:

| MySQL | Laravel Migration | Описание |
|---|---|---|
| `int unsigned auto_increment` | `$table->id()` или `$table->unsignedInteger()->autoIncrement()` | Автоинкрементный первичный ключ |
| `int unsigned` | `$table->unsignedInteger()` | Беззнаковое целое |
| `tinyint unsigned` | `$table->unsignedTinyInteger()` | Маленькое беззнаковое целое |
| `varchar(N)` | `$table->string('name', N)` | Строка фиксированной длины |
| `char(N)` | `$table->char('code', N)` | Символьное поле фиксированной длины |
| `datetime` | `$table->dateTime()` | Дата и время |
| `mediumtext` | `$table->mediumText()` | Средний текст |
| `default 'value'` | `->default('value')` | Значение по умолчанию |
| `not null` | По умолчанию NOT NULL | Обязательное поле |
| `null` | `->nullable()` | Необязательное поле |

#### FR-1.4. Удаление MySQL-специфичных конструкций

Миграции НЕ должны содержать:

- `charset=utf8` (SQLite всегда использует UTF-8)
- `row_format=COMPACT` (специфично для MySQL InnoDB)
- Explicit `auto_increment` (используется Laravel-метод `autoIncrement()`)

#### FR-1.5. Создание индексов

Миграции должны создавать индексы на всех полях, которые используются в JOIN и WHERE:

- Внешние ключи (USER_ID, FNAME_ID, SNAME_ID, SURNAME_ID, BSURNAME_ID, PID1, PID2, RELATION_TYPE_ID)
- Языковые коды (LANG_ID, LANG)
- Идентификаторы связей (NAME_ID, NAME_LANG_ID, SURNAME_ID, SURNAME_LANG_ID)

**Пример:**

```php
$table->unsignedInteger('user_id');
$table->index('user_id');
```

#### FR-1.6. Создание таблицы типов связей

Система должна создать **отсутствующую** таблицу `gen_relation_type`:

```php
Schema::create('gen_relation_type', function (Blueprint $table) {
    $table->id();
    $table->string('name', 100); // Название типа связи (например, "Родитель-Ребенок")
    $table->string('code', 50)->unique(); // Код типа (например, "parent_child")
    $table->text('description')->nullable(); // Описание типа связи
});
```

Таблица должна быть заполнена базовыми типами связей:

- `parent_child` — Родитель → Ребенок
- `child_parent` — Ребенок → Родитель
- `spouse` — Супруг/Супруга
- `sibling` — Брат/Сестра

**Критерии приемки FR-1:**

- ✅ Все 15 таблиц из `structure.sql` создаются через Laravel-миграции
- ✅ Создана таблица `gen_relation_type` с базовыми типами связей
- ✅ Все типы данных корректно адаптированы под SQLite
- ✅ Индексы созданы на всех внешних ключах и полях поиска
- ✅ Миграции выполняются без ошибок: `php artisan migrate`
- ✅ В миграциях отсутствуют MySQL-специфичные конструкции

---

### FR-2. Команда экспорта данных из MySQL

**Приоритет:** Высокий

**Описание:**
Система должна иметь Artisan-команду для экспорта данных из существующей MySQL базы данных в формат, совместимый с SQLite.

**Детализация:**

#### FR-2.1. Интерфейс команды

```bash
php artisan db:export-mysql [options]
```

**Параметры:**

- `--host=HOSTNAME` — хост MySQL сервера (обязательный)
- `--database=DBNAME` — имя базы данных (обязательный)
- `--user=USERNAME` — имя пользователя (обязательный)
- `--password=PASSWORD` — пароль (обязательный)
- `--port=PORT` — порт MySQL (по умолчанию 3306)
- `--output=FILEPATH` — путь к файлу экспорта (по умолчанию `database/data/export_YYYY-MM-DD_HH-MM-SS.json`)
- `--tables=TABLE1,TABLE2` — список таблиц для экспорта (по умолчанию все таблицы)

#### FR-2.2. Формат экспортируемых данных

Команда должна экспортировать данные в JSON-формат со следующей структурой:

```json
{
  "export_info": {
    "timestamp": "2026-01-21T15:30:45+00:00",
    "source": {
      "host": "localhost",
      "database": "genealogy",
      "version": "MySQL 8.0.32"
    }
  },
  "tables": {
    "gen_user": [
      {
        "ID": 1,
        "LOGIN": "admin",
        "PASSWORD": "hashed_password",
        "FNAME": "Иван",
        "SNAME": "Иванович",
        "SURNAME": "Иванов",
        "EMAIL": "admin@example.com",
        "CREATE_DATE": "2025-01-15 10:30:00",
        "USER_TYPE": 1,
        "ACTIVE": 1
      }
    ],
    "gen_person": [ /* ... */ ],
    "gen_relation": [ /* ... */ ]
    // ... остальные таблицы
  }
}
```

#### FR-2.3. Обработка типов данных

Команда должна корректно экспортировать:

- **Числа:** как числа в JSON (не строки)
- **Строки:** в UTF-8 с экранированием спецсимволов
- **Даты:** в формате ISO 8601 `YYYY-MM-DD HH:MM:SS`
- **NULL-значения:** как `null` в JSON
- **Текст:** с сохранением кириллицы и других Unicode-символов

#### FR-2.4. Обработка ошибок

Команда должна:

- Проверять подключение к MySQL перед началом экспорта
- Выводить прогресс экспорта (количество обработанных таблиц и строк)
- Останавливаться при ошибке подключения или чтения данных
- Выводить детальное сообщение об ошибке
- Возвращать ненулевой код выхода при ошибке

#### FR-2.5. Сохранение файла экспорта

Команда должна:

- Создавать директорию `database/data/`, если её нет
- Сохранять файл с автоматическим именем `export_YYYY-MM-DD_HH-MM-SS.json` (если не указан `--output`)
- Выводить полный путь к сохраненному файлу
- Выводить размер файла экспорта

**Пример вывода:**

```
Подключение к MySQL: localhost:3306, база genealogy
Экспорт таблицы gen_user... 5 записей
Экспорт таблицы gen_person... 42 записи
Экспорт таблицы gen_relation... 38 записей
...
Экспорт завершен успешно!
Файл сохранен: /app/database/data/export_2026-01-21_15-30-45.json
Размер файла: 156.3 KB
Всего экспортировано: 15 таблиц, 327 записей
```

**Критерии приемки FR-2:**

- ✅ Команда `php artisan db:export-mysql` доступна
- ✅ Команда принимает все указанные параметры
- ✅ Команда подключается к MySQL и экспортирует данные
- ✅ Данные экспортируются в JSON с корректной структурой
- ✅ Кириллица корректно сохраняется в UTF-8
- ✅ Даты экспортируются в формате ISO 8601
- ✅ NULL-значения корректно обрабатываются
- ✅ Команда выводит прогресс экспорта
- ✅ Команда корректно обрабатывает ошибки подключения
- ✅ Файл сохраняется по указанному пути или с автоматическим именем
- ✅ Команда имеет справку `--help` с примерами использования

---

### FR-3. Команда импорта данных в SQLite

**Приоритет:** Высокий

**Описание:**
Система должна иметь Artisan-команду для импорта данных из файла экспорта в текущую SQLite базу данных.

**Детализация:**

#### FR-3.1. Интерфейс команды

```bash
php artisan db:import [options]
```

**Параметры:**

- `--file=FILEPATH` — путь к файлу экспорта (обязательный)
- `--validate` — проверить файл перед импортом без фактического импорта
- `--tables=TABLE1,TABLE2` — список таблиц для импорта (по умолчанию все таблицы из файла)
- `--skip-existing` — пропускать записи с существующими ID
- `--truncate` — очистить таблицы перед импортом

#### FR-3.2. Валидация файла экспорта

Команда должна проверять перед импортом:

- Существование файла экспорта
- Корректность JSON-структуры
- Наличие обязательных полей (`export_info`, `tables`)
- Соответствие таблиц в файле и в БД
- Корректность структуры данных (типы полей)

**При ошибках валидации:**

- Вывести детальное сообщение об ошибке
- Остановить импорт
- Вернуть ненулевой код выхода

#### FR-3.3. Процесс импорта

Команда должна:

1. Открыть транзакцию БД
2. Импортировать таблицы в правильном порядке (с учетом зависимостей):
   - Сначала справочники (`gen_user_right`, `gen_relation_type`)
   - Затем пользователи (`gen_user`)
   - Затем независимые сущности (`gen_name`, `gen_surname`, `gen_menu`, `gen_message`)
   - Затем языковые данные (`gen_name_lang`, `gen_surname_lang`, `gen_message_text`)
   - Затем связующие таблицы (`gen_mixed_name_lang`, `gen_mixed_surname_lang`, `gen_mixed_menu_mess`, `gen_menu_order`)
   - Затем персоны (`gen_person`)
   - Затем связи (`gen_relation`)
   - Затем дополнительная информация (`gen_person_info_lang`)
3. Выводить прогресс импорта (текущая таблица, количество импортированных записей)
4. При успехе — закоммитить транзакцию
5. При ошибке — откатить транзакцию, вывести сообщение об ошибке

#### FR-3.4. Обработка конфликтов ID

При флаге `--skip-existing`:

- Если запись с таким ID уже существует — пропустить её
- Вывести предупреждение о пропущенных записях
- Продолжить импорт

Без флага `--skip-existing`:

- При конфликте ID остановить импорт
- Откатить транзакцию
- Вывести сообщение об ошибке с указанием таблицы и ID

#### FR-3.5. Режим `--truncate`

При флаге `--truncate`:

- Перед импортом очистить все таблицы командой `TRUNCATE` (или `DELETE`)
- Сбросить счетчики автоинкремента
- Вывести предупреждение о необратимости операции
- Запросить подтверждение (если не указан флаг `--force`)

#### FR-3.6. Режим `--validate`

При флаге `--validate`:

- Выполнить только валидацию файла и структуры БД
- Не выполнять фактический импорт
- Вывести отчет о результатах валидации
- Вернуть код 0, если валидация прошла успешно

**Пример вывода валидации:**

```
Валидация файла экспорта: /app/database/data/export_2026-01-21_15-30-45.json
✓ JSON структура корректна
✓ Найдено 15 таблиц
✓ Все таблицы существуют в БД
✓ Структура данных соответствует схеме БД
Валидация завершена успешно. Готов к импорту.
```

#### FR-3.7. Вывод прогресса и результата

**Пример вывода импорта:**

```
Импорт данных из: /app/database/data/export_2026-01-21_15-30-45.json
Открыта транзакция БД
Импорт таблицы gen_user_right... 5 записей
Импорт таблицы gen_relation_type... 4 записи
Импорт таблицы gen_user... 5 записей
Импорт таблицы gen_name... 28 записей
Импорт таблицы gen_surname... 24 записи
Импорт таблицы gen_name_lang... 31 запись
Импорт таблицы gen_surname_lang... 26 записей
Импорт таблицы gen_mixed_name_lang... 31 запись
Импорт таблицы gen_mixed_surname_lang... 26 записей
Импорт таблицы gen_person... 42 записи
Импорт таблицы gen_relation... 38 записей
Импорт таблицы gen_person_info_lang... 15 записей
Транзакция закоммичена
Импорт завершен успешно!
Всего импортировано: 15 таблиц, 275 записей
```

**Критерии приемки FR-3:**

- ✅ Команда `php artisan db:import` доступна
- ✅ Команда принимает все указанные параметры
- ✅ Команда валидирует файл экспорта перед импортом
- ✅ Команда импортирует данные в правильном порядке (с учетом зависимостей)
- ✅ Импорт выполняется в транзакции (откат при ошибке)
- ✅ Кириллица корректно импортируется
- ✅ NULL-значения корректно импортируются
- ✅ Даты корректно парсятся и сохраняются
- ✅ Флаг `--skip-existing` корректно обрабатывает конфликты ID
- ✅ Флаг `--truncate` очищает таблицы перед импортом
- ✅ Флаг `--validate` выполняет только валидацию без импорта
- ✅ Команда выводит прогресс импорта
- ✅ Команда корректно обрабатывает ошибки
- ✅ Команда имеет справку `--help` с примерами использования

---

### FR-4. Команда проверки целостности данных

**Приоритет:** Высокий

**Описание:**
Система должна иметь Artisan-команду для проверки целостности данных в БД, выявления битых связей и несоответствий.

**Детализация:**

#### FR-4.1. Интерфейс команды

```bash
php artisan db:validate-integrity [options]
```

**Параметры:**

- `--verbose` — детальный вывод всех найденных проблем
- `--format=text|json` — формат вывода (по умолчанию text)
- `--fix` — автоматически исправить проблемы (если возможно)

#### FR-4.2. Проверки целостности данных

Команда должна выполнять следующие проверки:

##### 4.2.1. Проверка таблицы `gen_person`

- ✅ Все `FNAME_ID` указывают на существующие записи в `gen_name`
- ✅ Все `SNAME_ID` (если не NULL) указывают на существующие записи в `gen_name`
- ✅ Все `SURNAME_ID` (если не NULL) указывают на существующие записи в `gen_surname`
- ✅ Все `BSURNAME_ID` (если не NULL) указывают на существующие записи в `gen_surname`
- ✅ Все `USER_ID` указывают на существующие записи в `gen_user`
- ✅ Поле `BDATE` (если не NULL) имеет корректный формат даты
- ✅ Поле `DDATE` (если не NULL) имеет корректный формат даты и не меньше `BDATE`

##### 4.2.2. Проверка таблицы `gen_relation`

- ✅ Все `PID1` указывают на существующие записи в `gen_person`
- ✅ Все `PID2` указывают на существующие записи в `gen_person`
- ✅ Все `RELATION_TYPE_ID` указывают на существующие записи в `gen_relation_type`
- ✅ Отсутствуют дублирующие связи (PID1 + PID2 + RELATION_TYPE_ID уникальны)
- ✅ Отсутствуют самосвязи (PID1 != PID2)

##### 4.2.3. Проверка таблицы `gen_name`

- ✅ Все `USER_ID` указывают на существующие записи в `gen_user`
- ✅ Каждая запись имеет хотя бы одну связь в `gen_mixed_name_lang`

##### 4.2.4. Проверка таблицы `gen_name_lang`

- ✅ Поле `FNAME` не пустое
- ✅ Поле `LANG` содержит корректный код языка (2-3 символа)
- ✅ Если `MALE_ID` не NULL, он указывает на существующую запись в `gen_name_lang`

##### 4.2.5. Проверка таблицы `gen_mixed_name_lang`

- ✅ Все `NAME_ID` указывают на существующие записи в `gen_name`
- ✅ Все `NAME_LANG_ID` указывают на существующие записи в `gen_name_lang`
- ✅ Отсутствуют дублирующие связи (NAME_ID + NAME_LANG_ID уникальны)

##### 4.2.6. Проверка таблицы `gen_surname`

- ✅ Все `USER_ID` указывают на существующие записи в `gen_user`
- ✅ Каждая запись имеет хотя бы одну связь в `gen_mixed_surname_lang`

##### 4.2.7. Проверка таблицы `gen_surname_lang`

- ✅ Хотя бы одно из полей `MALE_SURNAME` или `FEMALE_SURNAME` не пустое
- ✅ Поле `LANG` содержит корректный код языка (2-3 символа)

##### 4.2.8. Проверка таблицы `gen_mixed_surname_lang`

- ✅ Все `SURNAME_ID` указывают на существующие записи в `gen_surname`
- ✅ Все `SURNAME_LANG_ID` указывают на существующие записи в `gen_surname_lang`
- ✅ Отсутствуют дублирующие связи (SURNAME_ID + SURNAME_LANG_ID уникальны)

##### 4.2.9. Проверка таблицы `gen_person_info_lang`

- ✅ Все `PERSON_ID` указывают на существующие записи в `gen_person`
- ✅ Поле `LANG` содержит корректный код языка (2-3 символа)

##### 4.2.10. Проверка таблицы `gen_user`

- ✅ Поле `LOGIN` уникально и не пустое
- ✅ Поле `EMAIL` имеет корректный формат
- ✅ Поле `CREATE_DATE` имеет корректный формат даты

#### FR-4.3. Формат вывода отчета

**Текстовый формат (по умолчанию):**

```
Проверка целостности базы данных...

[1/10] Проверка таблицы gen_user... ✓ OK (5 записей)
[2/10] Проверка таблицы gen_person... ✗ ОШИБКИ (42 записи)
  - Запись ID=15: FNAME_ID=999 не существует в gen_name
  - Запись ID=23: USER_ID=10 не существует в gen_user
[3/10] Проверка таблицы gen_relation... ✗ ОШИБКИ (38 записей)
  - Запись PID1=15, PID2=16: RELATION_TYPE_ID=5 не существует в gen_relation_type
  - Запись PID1=42, PID2=42: самосвязь (PID1=PID2)
[4/10] Проверка таблицы gen_name... ✓ OK (28 записей)
[5/10] Проверка таблицы gen_name_lang... ✓ OK (31 запись)
[6/10] Проверка таблицы gen_mixed_name_lang... ✓ OK (31 запись)
[7/10] Проверка таблицы gen_surname... ✓ OK (24 записи)
[8/10] Проверка таблицы gen_surname_lang... ✓ OK (26 записей)
[9/10] Проверка таблицы gen_mixed_surname_lang... ✓ OK (26 записей)
[10/10] Проверка таблицы gen_person_info_lang... ✓ OK (15 записей)

ИТОГО:
  Проверено: 10 таблиц, 266 записей
  Найдено проблем: 4
  Статус: ОШИБКИ

Код выхода: 1
```

**JSON-формат (`--format=json`):**

```json
{
  "status": "error",
  "total_tables": 10,
  "total_records": 266,
  "total_issues": 4,
  "checks": [
    {
      "table": "gen_user",
      "status": "ok",
      "records_checked": 5,
      "issues": []
    },
    {
      "table": "gen_person",
      "status": "error",
      "records_checked": 42,
      "issues": [
        {
          "type": "foreign_key_violation",
          "record_id": 15,
          "field": "FNAME_ID",
          "value": 999,
          "message": "FNAME_ID=999 не существует в gen_name"
        },
        {
          "type": "foreign_key_violation",
          "record_id": 23,
          "field": "USER_ID",
          "value": 10,
          "message": "USER_ID=10 не существует в gen_user"
        }
      ]
    }
    // ... остальные проверки
  ]
}
```

#### FR-4.4. Автоматическое исправление проблем (флаг `--fix`)

При флаге `--fix` команда должна попытаться автоматически исправить следующие проблемы:

- Удалить записи с битыми внешними ключами (после подтверждения)
- Удалить дублирующие связи
- Удалить самосвязи в `gen_relation`

**ВАЖНО:** Перед исправлением команда должна:

1. Вывести список проблем, которые будут исправлены
2. Запросить подтверждение у пользователя (кроме случая с флагом `--force`)
3. Создать резервную копию данных

#### FR-4.5. Коды возврата

- `0` — проверка прошла успешно, проблем не найдено
- `1` — найдены проблемы с целостностью данных
- `2` — ошибка выполнения команды (например, БД недоступна)

**Критерии приемки FR-4:**

- ✅ Команда `php artisan db:validate-integrity` доступна
- ✅ Команда выполняет все указанные проверки
- ✅ Команда выводит детальный отчет о найденных проблемах
- ✅ Команда поддерживает текстовый и JSON форматы вывода
- ✅ Команда возвращает корректный код выхода (0 — успех, 1 — проблемы, 2 — ошибка)
- ✅ Флаг `--verbose` выводит детальную информацию о каждой проблеме
- ✅ Флаг `--fix` автоматически исправляет проблемы (с подтверждением)
- ✅ Команда имеет справку `--help` с примерами использования

---

### FR-5. API эндпоинт статуса базы данных

**Приоритет:** Средний

**Описание:**
Система должна предоставлять HTTP API эндпоинт для проверки состояния базы данных и получения базовой статистики.

**Детализация:**

#### FR-5.1. Спецификация эндпоинта

- **URL:** `GET /api/status`
- **Аутентификация:** Не требуется (публичный эндпоинт)
- **Формат ответа:** JSON
- **Content-Type:** `application/json`

#### FR-5.2. Логика работы

Эндпоинт должен:

1. Попытаться подключиться к БД
2. Выполнить простой SELECT-запрос (например, `SELECT 1`)
3. Проверить наличие основных таблиц
4. Получить количество записей в основных таблицах
5. Сформировать JSON-ответ

#### FR-5.3. Формат успешного ответа (код 200)

```json
{
  "status": "ok",
  "message": "Database connection is healthy",
  "timestamp": "2026-01-21T15:30:45+00:00",
  "database": {
    "type": "sqlite",
    "path": "/app/database/database.sqlite",
    "size": "1.2 MB",
    "tables_exist": true,
    "statistics": {
      "users_count": 5,
      "persons_count": 42,
      "relations_count": 38,
      "names_count": 28,
      "surnames_count": 24
    }
  }
}
```

#### FR-5.4. Формат ответа при ошибке (код 500)

```json
{
  "status": "error",
  "message": "Database connection failed: SQLSTATE[HY000] [14] unable to open database file",
  "timestamp": "2026-01-21T15:30:45+00:00"
}
```

#### FR-5.5. Формат ответа при отсутствии таблиц (код 503)

```json
{
  "status": "unavailable",
  "message": "Database tables are not initialized. Please run migrations.",
  "timestamp": "2026-01-21T15:30:45+00:00",
  "database": {
    "type": "sqlite",
    "path": "/app/database/database.sqlite",
    "tables_exist": false,
    "missing_tables": [
      "gen_user",
      "gen_person",
      "gen_relation"
    ]
  }
}
```

#### FR-5.6. Обработка ошибок

Эндпоинт должен корректно обрабатывать:

- Отсутствие подключения к БД (код 500)
- Отсутствие таблиц (код 503)
- Ошибки чтения данных (код 500)
- Таймаут запроса (код 504)

#### FR-5.7. Производительность

- Время ответа не должно превышать 1 секунды
- Эндпоинт не должен блокировать БД надолго
- Запросы статистики должны быть оптимизированы (использовать `COUNT(*)`)

**Критерии приемки FR-5:**

- ✅ Эндпоинт `GET /api/status` доступен
- ✅ При успешном подключении возвращает код 200 и JSON с информацией о БД
- ✅ При ошибке подключения возвращает код 500 и JSON с описанием ошибки
- ✅ При отсутствии таблиц возвращает код 503 и JSON с информацией о проблеме
- ✅ JSON содержит все обязательные поля: `status`, `message`, `timestamp`, `database`
- ✅ Статистика содержит количество записей в основных таблицах
- ✅ Время ответа не превышает 1 секунды
- ✅ Эндпоинт корректно обрабатывает ошибки БД

---

### FR-6. Документация структуры базы данных

**Приоритет:** Средний

**Описание:**
Система должна иметь детальную документацию, описывающую структуру базы данных, связи между таблицами и особенности работы с данными.

**Детализация:**

#### FR-6.1. Местоположение документации

Документация должна быть размещена в файле:

```
Doc/Database/Schema.md
```

#### FR-6.2. Структура документации

Документ должен содержать следующие разделы:

##### 6.2.1. Введение

- Общее описание схемы БД
- История создания и миграции (MySQL → SQLite)
- Ссылки на исходные файлы (`structure.sql`)

##### 6.2.2. Диаграмма связей (ER-диаграмма)

Визуальное представление связей между таблицами (текстовое или изображение).

**Пример текстовой диаграммы:**

```
gen_user ──┐
           │
           ├──→ gen_person ──→ gen_relation
           │         │
           │         ├──→ gen_name ──→ gen_mixed_name_lang ──→ gen_name_lang
           │         │
           │         └──→ gen_surname ──→ gen_mixed_surname_lang ──→ gen_surname_lang
           │
           ├──→ gen_name
           │
           └──→ gen_surname
```

##### 6.2.3. Описание основных таблиц

Для каждой таблицы указать:

- Название таблицы
- Назначение таблицы
- Список полей с типами данных и описанием
- Связи с другими таблицами (внешние ключи)
- Индексы
- Примеры записей

**Пример описания таблицы:**

```markdown
### gen_person

**Назначение:** Основная таблица персон в генеалогическом древе.

**Поля:**

| Поле | Тип | Обязательное | Описание |
|---|---|---|---|
| ID | INTEGER | ✓ | Уникальный идентификатор персоны (первичный ключ) |
| FNAME_ID | INTEGER | ✓ | ID имени (→ gen_name.ID) |
| SNAME_ID | INTEGER | ✗ | ID отчества (→ gen_name.ID) |
| SURNAME_ID | INTEGER | ✗ | ID текущей фамилии (→ gen_surname.ID) |
| BSURNAME_ID | INTEGER | ✗ | ID девичьей фамилии (→ gen_surname.ID) |
| BDATE | DATETIME | ✗ | Дата рождения |
| DDATE | DATETIME | ✗ | Дата смерти |
| USER_ID | INTEGER | ✓ | ID владельца дерева (→ gen_user.ID) |

**Связи:**
- `FNAME_ID`, `SNAME_ID` → `gen_name.ID`
- `SURNAME_ID`, `BSURNAME_ID` → `gen_surname.ID`
- `USER_ID` → `gen_user.ID`

**Индексы:**
- `FNAME_ID`
- `SNAME_ID`
- `SURNAME_ID`
- `BSURNAME_ID`
- `USER_ID`

**Пример записей:**

| ID | FNAME_ID | SNAME_ID | SURNAME_ID | BSURNAME_ID | BDATE | DDATE | USER_ID |
|---|---|---|---|---|---|---|---|
| 1 | 5 | 5 | 3 | NULL | 1950-03-15 | NULL | 1 |
| 2 | 8 | 5 | 7 | 3 | 1975-07-22 | NULL | 1 |
```

##### 6.2.4. Описание многоязычной модели

Детальное описание работы с многоязычными именами и фамилиями:

- Как хранятся языковые варианты
- Как связаны основные записи с языковыми вариантами
- Как работают гендерные формы (отчества, фамилии)
- Примеры запросов для получения имени/фамилии на разных языках

##### 6.2.5. Описание модели связей персон

Детальное описание таблицы `gen_relation`:

- Типы связей (родитель-ребенок, супруги, братья/сестры)
- Как хранятся направленные связи
- Примеры запросов для получения родственников

##### 6.2.6. Примеры SQL-запросов

Типовые запросы для работы с данными:

- Получить все данные персоны (с именем, фамилией, отчеством на русском языке)
- Получить всех детей персоны
- Получить всех родителей персоны
- Получить супруга/супругу персоны
- Получить список персон пользователя

##### 6.2.7. Особенности и ограничения

- Отсутствие FOREIGN KEY constraints
- Отсутствие каскадных удалений
- Необходимость контроля целостности на уровне приложения
- Ограничения SQLite по сравнению с MySQL

**Критерии приемки FR-6:**

- ✅ Создан файл `Doc/Database/Schema.md`
- ✅ Документ содержит все указанные разделы
- ✅ Описаны все 15+ таблиц с полями и связями
- ✅ Приведена диаграмма связей (текстовая или изображение)
- ✅ Детально описана многоязычная модель
- ✅ Детально описана модель связей персон
- ✅ Приведены примеры SQL-запросов
- ✅ Описаны особенности и ограничения
- ✅ Документ понятен нетехническому пользователю

---

## Нефункциональные требования

### NFR-1. Сохранность данных

**Описание:**
При миграции данных из MySQL в SQLite **ни одна запись не должна быть потеряна или искажена**.

**Критерии:**

- Количество записей в каждой таблице после импорта совпадает с исходным
- Кириллица и другие Unicode-символы корректно сохраняются
- Даты корректно конвертируются
- NULL-значения корректно обрабатываются
- Связи между таблицами сохраняются

**Проверка:**

- Выполнить экспорт из MySQL
- Выполнить импорт в SQLite
- Сравнить количество записей в каждой таблице
- Выполнить проверку целостности данных
- Выполнить выборочную проверку данных (имена, даты, связи)

---

### NFR-2. Воспроизводимость развертывания

**Описание:**
Проект должен разворачиваться в любом окружении через Docker/Makefile без ручных действий.

**Критерии:**

- Команда `make install` разворачивает полное окружение
- Все миграции применяются автоматически
- Если есть файл экспорта данных, он импортируется автоматически
- Проект готов к работе после выполнения `make install`
- Документация содержит пошаговые инструкции развертывания

**Проверка:**

- Удалить все контейнеры и БД
- Выполнить `make install`
- Проверить статус БД через `/api/status`
- Выполнить `php artisan db:validate-integrity`

---

### NFR-3. Целостность данных

**Описание:**
Все связи между таблицами должны быть корректными после миграции.

**Критерии:**

- Все внешние ключи указывают на существующие записи
- Отсутствуют битые связи
- Отсутствуют дублирующие связи
- Отсутствуют самосвязи (где это неуместно)
- Команда `php artisan db:validate-integrity` не находит проблем

**Проверка:**

- Выполнить импорт данных
- Выполнить `php artisan db:validate-integrity`
- Убедиться, что команда возвращает код 0 (успех)

---

### NFR-4. Производительность

**Описание:**
Команды экспорта/импорта должны работать с базой размером до 10000 записей персон за разумное время.

**Критерии:**

- Экспорт 10000 персон выполняется за 2-3 минуты
- Импорт 10000 персон выполняется за 2-3 минуты
- API эндпоинт `/api/status` отвечает за 1 секунду
- Команда `php artisan db:validate-integrity` выполняется за 1-2 минуты на 10000 персон

**Проверка:**

- Создать тестовую БД с 10000 персон
- Измерить время выполнения экспорта
- Измерить время выполнения импорта
- Измерить время ответа `/api/status`
- Измерить время выполнения валидации

---

### NFR-5. Документированность

**Описание:**
Все команды и эндпоинты должны быть документированы с примерами использования.

**Критерии:**

- Каждая Artisan-команда имеет справку `--help`
- Справка содержит описание команды, параметров и примеры
- Документация `Doc/Database/Schema.md` содержит полное описание БД
- README содержит инструкции по развертыванию и работе с данными

**Проверка:**

- Выполнить `php artisan db:export-mysql --help`
- Выполнить `php artisan db:import --help`
- Выполнить `php artisan db:validate-integrity --help`
- Прочитать `Doc/Database/Schema.md`
- Прочитать README

---

### NFR-6. Соответствие архитектуре проекта

**Описание:**
Все изменения должны соответствовать правилам проекта (Clean Architecture + CQRS).

**Критерии:**

- Команды реализованы в `backend/app/Console/Commands/`
- Бизнес-логика вынесена в отдельные сервисы/классы
- Используются стандартные Laravel-компоненты (миграции, Eloquent, команды)
- Код соответствует стилю проекта (см. `.ai/rules/CodeStyle.md`)
- Код проходит статический анализ (PHPStan, PHP_CodeSniffer)

**Проверка:**

- Выполнить `make php-run CMD="vendor/bin/phpstan analyse"`
- Выполнить `make php-run CMD="vendor/bin/phpcs"`
- Проверить структуру директорий

---

### NFR-7. Понятность для нетехнического пользователя

**Описание:**
Документация и вывод команд должны быть понятны нетехническому пользователю.

**Критерии:**

- Сообщения команд написаны на русском языке
- Сообщения об ошибках понятны и содержат подсказки по решению
- Документация не содержит излишнего технического жаргона
- Примеры использования команд просты и понятны

**Проверка:**

- Прочитать вывод команд
- Прочитать документацию
- Попросить нетехнического пользователя выполнить развертывание по инструкции

---

## Модель предметной области

### Основные Entity (сущности)

#### User (Пользователь)

**Описание:** Пользователь системы, владелец генеалогического древа.

**Атрибуты:**

- ID (уникальный идентификатор)
- LOGIN (логин для входа)
- PASSWORD (хешированный пароль)
- FNAME (имя пользователя)
- SNAME (отчество пользователя)
- SURNAME (фамилия пользователя)
- EMAIL (email)
- CREATE_DATE (дата регистрации)
- USER_TYPE (тип пользователя: админ/обычный)
- ACTIVE (активен ли пользователь)

**Связи:**

- Владеет множеством персон (Person)
- Владеет множеством имен (Name)
- Владеет множеством фамилий (Surname)

---

#### Person (Персона)

**Описание:** Человек в генеалогическом древе.

**Атрибуты:**

- ID (уникальный идентификатор)
- FirstName (имя — связь с Name через FNAME_ID)
- MiddleName (отчество — связь с Name через SNAME_ID)
- Surname (текущая фамилия — связь с Surname через SURNAME_ID)
- BirthSurname (девичья фамилия — связь с Surname через BSURNAME_ID)
- BirthDate (дата рождения)
- DeathDate (дата смерти)
- Owner (владелец дерева — связь с User через USER_ID)

**Связи:**

- Принадлежит пользователю (User)
- Имеет одно имя (Name)
- Может иметь отчество (Name)
- Может иметь текущую фамилию (Surname)
- Может иметь девичью фамилию (Surname)
- Имеет множество связей с другими персонами (Relation)
- Может иметь дополнительную информацию на разных языках (PersonInfo)

---

#### Name (Имя)

**Описание:** Имя персоны с поддержкой многоязычности и гендерных форм отчеств.

**Атрибуты:**

- ID (уникальный идентификатор)
- Owner (владелец — связь с User через USER_ID)
- LanguageVariants (языковые варианты — связь через NameLang)

**Связи:**

- Принадлежит пользователю (User)
- Имеет множество языковых вариантов (NameLang) через промежуточную таблицу (MixedNameLang)

---

#### NameLang (Языковой вариант имени)

**Описание:** Конкретная языковая форма имени с гендерными формами отчеств.

**Атрибуты:**

- ID (уникальный идентификатор)
- MALE_ID (ссылка на мужской вариант имени — для согласования отчеств)
- FirstName (само имя, например "Иван" или "John")
- MaleMiddleName (отчество для сына, например "Иванович")
- FemaleMiddleName (отчество для дочери, например "Ивановна")
- Language (код языка: "ru", "en", и т.д.)

**Связи:**

- Связан с основной записью имени (Name) через промежуточную таблицу (MixedNameLang)
- Может ссылаться на мужской вариант (MALE_ID) для согласования отчеств

---

#### Surname (Фамилия)

**Описание:** Фамилия персоны с поддержкой многоязычности и гендерных форм.

**Атрибуты:**

- ID (уникальный идентификатор)
- Owner (владелец — связь с User через USER_ID)
- LanguageVariants (языковые варианты — связь через SurnameLang)

**Связи:**

- Принадлежит пользователю (User)
- Имеет множество языковых вариантов (SurnameLang) через промежуточную таблицу (MixedSurnameLang)

---

#### SurnameLang (Языковой вариант фамилии)

**Описание:** Конкретная языковая форма фамилии с гендерными формами.

**Атрибуты:**

- ID (уникальный идентификатор)
- MaleSurname (мужская форма фамилии, например "Петров")
- FemaleSurname (женская форма фамилии, например "Петрова")
- Language (код языка: "ru", "en", и т.д.)

**Связи:**

- Связан с основной записью фамилии (Surname) через промежуточную таблицу (MixedSurnameLang)

---

#### Relation (Связь между персонами)

**Описание:** Связь между двумя персонами в генеалогическом древе.

**Атрибуты:**

- Person1 (первая персона — связь с Person через PID1)
- Person2 (вторая персона — связь с Person через PID2)
- RelationType (тип связи — связь с RelationType через RELATION_TYPE_ID)

**Связи:**

- Связывает две персоны (Person)
- Имеет тип связи (RelationType)

---

#### RelationType (Тип связи)

**Описание:** Справочник типов связей между персонами.

**Атрибуты:**

- ID (уникальный идентификатор)
- Name (название типа, например "Родитель-Ребенок")
- Code (код типа, например "parent_child")
- Description (описание типа)

**Предопределенные типы:**

- `parent_child` — Родитель → Ребенок
- `child_parent` — Ребенок → Родитель
- `spouse` — Супруг/Супруга
- `sibling` — Брат/Сестра

---

#### PersonInfo (Дополнительная информация о персоне)

**Описание:** Многоязычное описание персоны (биография, заметки).

**Атрибуты:**

- PersonID (связь с Person через PERSON_ID)
- Info (текст описания)
- Language (код языка: "ru", "en", и т.д.)

**Связи:**

- Принадлежит персоне (Person)

---

### Value Objects (объекты-значения)

- **Language** — код языка (ru, en, uk и т.д.)
- **Date** — дата (рождения, смерти)
- **Email** — адрес электронной почты
- **Login** — логин пользователя

---

### Диаграмма связей основных Entity

```
┌─────────────┐
│    User     │◄──────┐
└─────────────┘       │
       │              │
       │ owns         │ owns
       ▼              │
┌─────────────┐       │
│   Person    │       │
└─────────────┘       │
       │              │
       ├──────────────┘
       │
       ├──────► Name ──────► NameLang
       │                        │
       │                        │ (через MixedNameLang)
       │
       ├──────► Surname ──────► SurnameLang
       │                           │
       │                           │ (через MixedSurnameLang)
       │
       └──────► Relation ──────► RelationType
                  │
                  └──────► Person (другая персона)
```

---

## Зависимости

### Внешние зависимости

- **Laravel 12** — фреймворк для разработки backend
- **SQLite** — СУБД для хранения данных
- **Docker** — контейнеризация окружения
- **PHP 8.5** — язык программирования

### Внутренние зависимости

Данный этап (Stage 1) является **стартовым**, поэтому не имеет зависимостей от других этапов.

Этот этап является **блокирующим** для следующих этапов:

- **Stage 2** — Адаптация доменной модели (требует готовую схему БД)
- **Stage 3** — Просмотр дерева (требует данные в БД)
- **Stage 4** — Управление персонами (требует схему БД и данные)
- **Stage 5** — Управление связями (требует схему БД и данные)

---

## Сценарии использования

### UC-1. Разработчик переносит существующую БД из MySQL

**Актор:** Разработчик

**Предусловия:**

- Существует MySQL база данных с реальными данными генеалогического древа
- Проект развернут в Docker
- Laravel установлен и настроен

**Основной сценарий:**

1. Разработчик запускает команду экспорта данных из MySQL:
   ```bash
   make php-run CMD="php artisan db:export-mysql \
     --host=mysql.example.com \
     --database=genealogy \
     --user=root \
     --password=secret"
   ```
2. Система подключается к MySQL базе данных
3. Система экспортирует данные всех таблиц в JSON-формат
4. Система сохраняет файл `database/data/export_2026-01-21_15-30-45.json`
5. Система выводит сообщение об успехе с путем к файлу и размером
6. Разработчик запускает команду импорта данных в SQLite:
   ```bash
   make php-run CMD="php artisan db:import \
     --file=database/data/export_2026-01-21_15-30-45.json"
   ```
7. Система валидирует файл экспорта
8. Система импортирует данные в SQLite в правильном порядке (с учетом зависимостей)
9. Система выводит прогресс импорта (таблица за таблицей)
10. Система выводит сообщение об успехе
11. Разработчик запускает команду проверки целостности:
    ```bash
    make php-run CMD="php artisan db:validate-integrity"
    ```
12. Система проверяет целостность данных
13. Система выводит отчет: "Проверено 42 персоны, 38 связей. Найдено 0 проблем."
14. Разработчик открывает в браузере `http://localhost/api/status`
15. Система возвращает JSON с подтверждением работы БД и статистикой

**Альтернативные сценарии:**

- **3a. Ошибка подключения к MySQL:**
  1. Система выводит сообщение: "Ошибка подключения к MySQL: ..."
  2. Система возвращает код ошибки 2
  3. Разработчик проверяет параметры подключения и повторяет попытку

- **8a. Ошибка импорта (конфликт ID):**
  1. Система выводит сообщение: "Ошибка импорта: запись с ID=15 уже существует в таблице gen_person"
  2. Система откатывает транзакцию
  3. Разработчик использует флаг `--skip-existing` или `--truncate` и повторяет импорт

- **12a. Найдены проблемы с целостностью:**
  1. Система выводит детальный отчет о проблемах (битые связи, NULL-значения)
  2. Система возвращает код ошибки 1
  3. Разработчик использует флаг `--fix` для автоматического исправления или исправляет вручную

**Постусловия:**

- Все данные из MySQL перенесены в SQLite
- Целостность данных подтверждена
- API эндпоинт `/api/status` показывает корректную статистику

---

### UC-2. Стейкхолдер запускает проект с мигрированными данными

**Актор:** Стейкхолдер (заказчик/куратор проекта)

**Предусловия:**

- Проект склонирован из Git-репозитория
- В проекте есть файл экспорта данных `database/data/export.json`
- На машине установлен Docker и Make

**Основной сценарий:**

1. Стейкхолдер открывает README проекта
2. Стейкхолдер читает инструкцию по запуску
3. Стейкхолдер выполняет команду:
   ```bash
   make install
   ```
4. Система разворачивает Docker-контейнеры
5. Система выполняет `composer install`
6. Система применяет Laravel-миграции (создает схему БД)
7. Система автоматически импортирует данные из файла `database/data/export.json` (если он есть)
8. Система выводит сообщение: "Проект развернут успешно!"
9. Стейкхолдер открывает в браузере `http://localhost/api/status`
10. Система возвращает JSON:
    ```json
    {
      "status": "ok",
      "message": "Database connection is healthy",
      "database": {
        "users_count": 5,
        "persons_count": 42,
        "relations_count": 38
      }
    }
    ```
11. Стейкхолдер видит подтверждение, что БД работает и содержит данные

**Альтернативные сценарии:**

- **7a. Файл экспорта отсутствует:**
  1. Система выводит сообщение: "Файл экспорта данных не найден. БД создана без данных."
  2. Система продолжает развертывание
  3. Стейкхолдер видит в `/api/status` нулевую статистику (0 персон, 0 связей)

- **9a. БД не работает:**
  1. Система возвращает код 500 и JSON: `{"status": "error", "message": "Database connection failed"}`
  2. Стейкхолдер обращается к разработчику

**Постусловия:**

- Проект развернут и работает
- БД содержит мигрированные данные
- API эндпоинт `/api/status` доступен

---

### UC-3. Разработчик проверяет структуру БД

**Актор:** Разработчик

**Предусловия:**

- Проект развернут в Docker
- Laravel миграции применены

**Основной сценарий:**

1. Разработчик запускает миграции:
   ```bash
   make php-run CMD="php artisan migrate"
   ```
2. Система создает все таблицы из миграций
3. Система выводит список примененных миграций
4. Разработчик проверяет наличие таблиц:
   ```bash
   make php-run CMD="php artisan db:show"
   ```
5. Система выводит список всех таблиц в БД
6. Разработчик открывает файл документации `Doc/Database/Schema.md`
7. Разработчик изучает:
   - Описание всех таблиц и их полей
   - Диаграмму связей между таблицами
   - Примеры SQL-запросов
   - Описание многоязычной модели
   - Описание гендерных форм (отчества, фамилии)
8. Разработчик выполняет тестовые запросы из документации
9. Разработчик убеждается, что структура БД соответствует документации

**Постусловия:**

- Разработчик понимает структуру БД
- Разработчик готов к разработке бизнес-логики на следующих этапах

---

### UC-4. Разработчик разворачивает проект в чистом окружении

**Актор:** Разработчик

**Предусловия:**

- Новая машина или чистое окружение
- Проект склонирован из Git-репозитория
- На машине установлен Docker и Make

**Основной сценарий:**

1. Разработчик выполняет команду:
   ```bash
   make install
   ```
2. Система разворачивает Docker-контейнеры
3. Система выполняет `composer install`
4. Система применяет Laravel-миграции (создает пустую схему БД)
5. Система выводит сообщение: "Проект развернут успешно!"
6. Разработчик проверяет статус через API:
   ```bash
   curl http://localhost/api/status
   ```
7. Система возвращает JSON с подтверждением работы БД
8. Если есть файл экспорта данных, разработчик импортирует его:
   ```bash
   make php-run CMD="php artisan db:import --file=database/data/export.json"
   ```
9. Система импортирует данные
10. Разработчик повторно проверяет статус через API
11. Система возвращает JSON с количеством импортированных записей

**Постусловия:**

- Проект развернут в чистом окружении
- БД создана и (при необходимости) заполнена данными
- Проект готов к разработке

---

### UC-5. Разработчик автоматически исправляет проблемы целостности

**Актор:** Разработчик

**Предусловия:**

- БД содержит данные с проблемами целостности (битые связи, дублирующие связи)
- Проект развернут в Docker

**Основной сценарий:**

1. Разработчик запускает проверку целостности:
   ```bash
   make php-run CMD="php artisan db:validate-integrity --verbose"
   ```
2. Система выполняет проверку всех таблиц
3. Система выводит детальный отчет о найденных проблемах:
   ```
   [2/10] Проверка таблицы gen_person... ✗ ОШИБКИ (42 записи)
     - Запись ID=15: FNAME_ID=999 не существует в gen_name
     - Запись ID=23: USER_ID=10 не существует в gen_user
   [3/10] Проверка таблицы gen_relation... ✗ ОШИБКИ (38 записей)
     - Запись PID1=42, PID2=42: самосвязь (PID1=PID2)
   ИТОГО: Найдено 3 проблемы
   ```
4. Разработчик запускает автоматическое исправление:
   ```bash
   make php-run CMD="php artisan db:validate-integrity --fix"
   ```
5. Система выводит список проблем, которые будут исправлены
6. Система запрашивает подтверждение: "Удалить 2 записи с битыми связями? (yes/no)"
7. Разработчик вводит "yes"
8. Система создает резервную копию данных
9. Система удаляет записи с битыми связями
10. Система удаляет самосвязи в `gen_relation`
11. Система выводит отчет о выполненных исправлениях
12. Разработчик повторно запускает проверку
13. Система выводит: "Проверено 40 персон, 37 связей. Найдено 0 проблем."

**Альтернативные сценарии:**

- **7a. Разработчик отменяет исправление:**
  1. Разработчик вводит "no"
  2. Система отменяет операцию
  3. Данные не изменены

**Постусловия:**

- Проблемы целостности данных исправлены
- Резервная копия создана
- БД прошла проверку целостности без ошибок

---

## Риски

### Риск 1. Потеря данных при экспорте/импорте

**Описание:**
При неправильной обработке типов данных MySQL → JSON → SQLite могут быть потеряны или искажены данные.

**Вероятность:** Средняя

**Влияние:** Критическое

**Меры снижения:**

- Тщательное тестирование команд экспорта/импорта на реальных данных
- Валидация файла экспорта перед импортом
- Проверка целостности данных после импорта
- Сравнение количества записей до и после миграции
- Выборочная проверка данных (имена, даты, связи)

**План реагирования:**

- Если обнаружена потеря данных — откатить импорт и исправить логику экспорта/импорта
- Создать резервную копию перед импортом

---

### Риск 2. Ошибки импорта из-за различий типов данных MySQL vs SQLite

**Описание:**
Различия в типах данных (например, MySQL `datetime` vs SQLite `TEXT/INTEGER`) могут вызвать ошибки импорта или некорректное хранение данных.

**Вероятность:** Средняя

**Влияние:** Высокое

**Меры снижения:**

- Использовать Laravel-миграции для корректной адаптации типов данных
- Использовать Laravel Eloquent для работы с датами (автоматическое преобразование)
- Тестировать импорт на тестовых данных с различными типами полей

**План реагирования:**

- Если обнаружены ошибки — добавить специальную логику преобразования типов в команде импорта

---

### Риск 3. Проблемы с кодировкой (кириллица ломается)

**Описание:**
При экспорте/импорте кириллица может быть искажена из-за проблем с кодировкой UTF-8.

**Вероятность:** Низкая (SQLite всегда UTF-8)

**Влияние:** Высокое

**Меры снижения:**

- Использовать JSON как промежуточный формат (автоматическое экранирование UTF-8)
- Установить `charset=utf8mb4` для подключения к MySQL при экспорте
- Тестировать экспорт/импорт на данных с кириллицей

**План реагирования:**

- Если обнаружены проблемы — добавить явное указание кодировки в команде экспорта

---

### Риск 4. Битые связи в существующих данных

**Описание:**
Если в исходной MySQL БД уже есть проблемы с целостностью (битые связи, NULL-значения там где не должно быть), они проявятся при проверке.

**Вероятность:** Средняя

**Влияние:** Среднее

**Меры снижения:**

- Реализовать команду `db:validate-integrity` с детальным отчетом
- Реализовать флаг `--fix` для автоматического исправления проблем
- Создавать резервную копию перед исправлением

**План реагирования:**

- Если обнаружены битые связи — использовать `--fix` для автоматического исправления или исправить вручную
- Согласовать со стейкхолдером допустимость удаления битых записей

---

### Риск 5. Отсутствие таблицы типов связей

**Описание:**
В исходном файле `structure.sql` отсутствует таблица `gen_relation_type`, на которую ссылается поле `RELATION_TYPE_ID` в таблице `gen_relation`.

**Вероятность:** Высокая (известный факт)

**Влияние:** Высокое

**Меры снижения:**

- Создать таблицу `gen_relation_type` в миграциях
- Заполнить таблицу базовыми типами связей (parent_child, spouse, sibling)
- Проверить, что все `RELATION_TYPE_ID` в `gen_relation` указывают на существующие типы

**План реагирования:**

- Если в данных есть `RELATION_TYPE_ID`, которых нет в справочнике — создать дополнительные типы или исправить данные

---

### Риск 6. Производительность команд на больших данных

**Описание:**
Команды экспорта/импорта могут работать медленно на больших объемах данных (10000+ персон).

**Вероятность:** Средняя

**Влияние:** Среднее

**Меры снижения:**

- Использовать транзакции для ускорения импорта (batch insert)
- Использовать индексы для ускорения проверки целостности
- Выводить прогресс выполнения команд

**План реагирования:**

- Если производительность недостаточна — оптимизировать запросы, использовать batch insert

---

### Риск 7. Сложность многоязычной модели

**Описание:**
Сложная структура хранения имен/фамилий через промежуточные таблицы и гендерные формы может затруднить понимание и работу с данными.

**Вероятность:** Средняя

**Влияние:** Среднее

**Меры снижения:**

- Создать детальную документацию с примерами запросов
- Добавить диаграммы связей
- Включить в документацию примеры работы с многоязычными данными

**План реагирования:**

- Если возникают трудности — дополнить документацию конкретными примерами
- Провести код-ревью с командой для проверки понимания модели

---

## Критерии приемки

### Критерии приемки этапа

Этап считается завершенным, если выполнены **все** следующие критерии:

#### Критерии по миграциям и схеме БД

- ✅ Все 15+ таблиц из `structure.sql` создаются через Laravel-миграции
- ✅ Создана таблица `gen_relation_type` с базовыми типами связей (parent_child, spouse, sibling)
- ✅ Все типы данных корректно адаптированы под SQLite
- ✅ Индексы созданы на всех внешних ключах и полях поиска
- ✅ Миграции выполняются без ошибок: `make php-run CMD="php artisan migrate"`
- ✅ В миграциях отсутствуют MySQL-специфичные конструкции

#### Критерии по экспорту данных

- ✅ Команда `php artisan db:export-mysql` доступна и работает
- ✅ Команда принимает параметры: --host, --database, --user, --password, --port, --output, --tables
- ✅ Команда экспортирует данные в JSON с корректной структурой
- ✅ Кириллица корректно сохраняется в UTF-8
- ✅ Даты экспортируются в формате ISO 8601
- ✅ NULL-значения корректно обрабатываются
- ✅ Команда выводит прогресс экспорта
- ✅ Команда корректно обрабатывает ошибки подключения
- ✅ Файл сохраняется по указанному пути или с автоматическим именем
- ✅ Команда имеет справку `--help` с примерами

#### Критерии по импорту данных

- ✅ Команда `php artisan db:import` доступна и работает
- ✅ Команда принимает параметры: --file, --validate, --tables, --skip-existing, --truncate
- ✅ Команда валидирует файл экспорта перед импортом
- ✅ Команда импортирует данные в правильном порядке (с учетом зависимостей)
- ✅ Импорт выполняется в транзакции (откат при ошибке)
- ✅ Кириллица корректно импортируется
- ✅ NULL-значения корректно импортируются
- ✅ Даты корректно парсятся и сохраняются
- ✅ Флаг `--skip-existing` корректно обрабатывает конфликты ID
- ✅ Флаг `--truncate` очищает таблицы перед импортом
- ✅ Флаг `--validate` выполняет только валидацию без импорта
- ✅ Команда выводит прогресс импорта
- ✅ Команда корректно обрабатывает ошибки
- ✅ Команда имеет справку `--help` с примерами

#### Критерии по проверке целостности

- ✅ Команда `php artisan db:validate-integrity` доступна и работает
- ✅ Команда выполняет все указанные проверки (битые связи, NULL-значения, дублирующие связи, самосвязи)
- ✅ Команда выводит детальный отчет о найденных проблемах
- ✅ Команда поддерживает текстовый и JSON форматы вывода
- ✅ Команда возвращает корректный код выхода (0 — успех, 1 — проблемы, 2 — ошибка)
- ✅ Флаг `--verbose` выводит детальную информацию о каждой проблеме
- ✅ Флаг `--fix` автоматически исправляет проблемы (с подтверждением)
- ✅ Команда имеет справку `--help` с примерами

#### Критерии по API эндпоинту

- ✅ Эндпоинт `GET /api/status` доступен
- ✅ При успешном подключении возвращает код 200 и JSON с информацией о БД
- ✅ При ошибке подключения возвращает код 500 и JSON с описанием ошибки
- ✅ При отсутствии таблиц возвращает код 503 и JSON с информацией о проблеме
- ✅ JSON содержит все обязательные поля: status, message, timestamp, database
- ✅ Статистика содержит количество записей в основных таблицах
- ✅ Время ответа не превышает 1 секунды

#### Критерии по документации

- ✅ Создан файл `Doc/Database/Schema.md` с описанием структуры БД
- ✅ Документ содержит описание всех 15+ таблиц с полями и связями
- ✅ Документ содержит диаграмму связей (текстовую или изображение)
- ✅ Документ содержит описание многоязычной модели
- ✅ Документ содержит описание гендерных форм (отчества, фамилии)
- ✅ Документ содержит описание модели связей персон
- ✅ Документ содержит примеры SQL-запросов
- ✅ Документ содержит описание особенностей и ограничений
- ✅ Документ понятен нетехническому пользователю
- ✅ Все команды имеют справку `--help` с примерами

#### Критерии по воспроизводимости

- ✅ Проект разворачивается в чистом окружении через `make install`
- ✅ После развертывания БД создана, схема применена
- ✅ Эндпоинт `/api/status` возвращает корректный ответ
- ✅ README содержит инструкции по развертыванию и работе с данными

#### Критерии по качеству кода

- ✅ Код соответствует стилю проекта (`.ai/rules/CodeStyle.md`)
- ✅ Код проходит статический анализ PHPStan без ошибок
- ✅ Код проходит проверку PHP_CodeSniffer без ошибок
- ✅ Команды реализованы в `backend/app/Console/Commands/`
- ✅ Используются стандартные Laravel-компоненты (миграции, Eloquent, команды)

#### Критерии по тестированию

- ✅ Миграции протестированы на чистой БД
- ✅ Команды экспорта/импорта протестированы на реальных данных
- ✅ Команда проверки целостности протестирована на данных с проблемами
- ✅ API эндпоинт протестирован в различных сценариях (успех, ошибка, отсутствие таблиц)
- ✅ Проведена выборочная проверка данных (имена, даты, связи)

---

## Не входит в реализацию

Следующие функции **НЕ входят** в реализацию текущего этапа и будут реализованы на последующих этапах:

### Не входит в Stage 1

- ❌ **Доменная модель и бизнес-логика** — будет реализована на Stage 2
- ❌ **Репозитории и сервисы** — будут реализованы на Stage 2
- ❌ **API для работы с персонами** — будет реализовано на Stage 3-4
- ❌ **API для работы со связями** — будет реализовано на Stage 5
- ❌ **Пользовательский интерфейс (UI)** — будет реализован на Stage 3-6
- ❌ **Аутентификация и авторизация** — будет реализована на Stage 7
- ❌ **Права доступа к данным** — будут реализованы на Stage 7
- ❌ **Визуализация генеалогического древа** — будет реализована на Stage 6
- ❌ **Редактирование персон через UI** — будет реализовано на Stage 4
- ❌ **Создание/удаление связей через UI** — будет реализовано на Stage 5
- ❌ **Валидация бизнес-правил** — будет реализована на Stage 4-5
- ❌ **Unit-тесты бизнес-логики** — будут написаны на Stage 2-5
- ❌ **E2E-тесты пользовательских сценариев** — будут написаны на Stage 3-6
- ❌ **Оптимизация производительности** — будет выполнена на Stage 6-7
- ❌ **Миграция на production** — будет выполнена на Stage 7

### Допущения текущего этапа

На текущем этапе допускаются следующие упрощения:

- ✅ **Отсутствие FOREIGN KEY constraints** — целостность контролируется командой `db:validate-integrity`
- ✅ **Отсутствие каскадных удалений** — будет реализовано на уровне приложения
- ✅ **Минимальная валидация данных** — только проверка существования связей
- ✅ **Отсутствие UI** — только API эндпоинт `/api/status` для проверки
- ✅ **Отсутствие аутентификации** — эндпоинт `/api/status` публичный

---

## Дополнительные замечания

### Важные особенности реализации

1. **Порядок импорта критичен:** Таблицы должны импортироваться в правильном порядке (сначала справочники, затем зависимые таблицы), иначе будут ошибки внешних ключей.

2. **Транзакции обязательны:** Импорт должен выполняться в транзакции, чтобы при ошибке можно было откатить изменения.

3. **Резервные копии:** Перед импортом с флагом `--truncate` или исправлением с флагом `--fix` необходимо создавать резервные копии.

4. **Многоязычность:** Работа с именами/фамилиями требует JOIN через промежуточные таблицы (`gen_mixed_name_lang`, `gen_mixed_surname_lang`).

5. **Гендерные формы:** При выводе отчеств и фамилий необходимо учитывать пол персоны (MALE_SNAME/FEMALE_SNAME, MALE_SURNAME/FEMALE_SURNAME).

6. **Отсутствие внешних ключей:** SQLite не поддерживает ALTER TABLE для добавления внешних ключей после создания таблицы, поэтому используем только индексы.

### Рекомендации по реализации

1. **Использовать Laravel Eloquent:** Для работы с датами и преобразованием типов данных.

2. **Логировать операции:** Все команды должны логировать свои действия для отладки.

3. **Использовать прогресс-бары:** Команды должны выводить прогресс выполнения (например, с помощью Laravel `output->progressStart()`).

4. **Тестировать на реальных данных:** Обязательно протестировать экспорт/импорт на реальной MySQL базе с кириллицей и различными типами данных.

5. **Документировать все команды:** Каждая команда должна иметь детальную справку `--help` с примерами использования.

---

## Глоссарий

- **Миграция БД** — процесс переноса схемы и данных из одной СУБД в другую
- **Laravel-миграции** — система управления схемой БД в Laravel через PHP-код
- **Артефакт** — результат работы этапа (файл, документ, код)
- **Целостность данных** — отсутствие битых связей и некорректных значений
- **Битая связь** — ссылка на несуществующую запись (например, FNAME_ID указывает на несуществующее имя)
- **Самосвязь** — связь персоны с самой собой (PID1 = PID2)
- **Многоязычность** — поддержка хранения данных на разных языках (ru, en, uk)
- **Гендерные формы** — разные формы слов для мужчин и женщин (Иванович/Ивановна, Петров/Петрова)
- **Девичья фамилия** — фамилия до брака (для женщин)
- **Транзакция БД** — группа операций, которые либо выполняются все вместе, либо откатываются

---

**Конец спецификации TZ1_01**
