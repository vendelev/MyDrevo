# Мультиагентная разработка: от хотелок до продакшена

## Аннотация


## Вступление

AI плотно входит в нашу жизнь.
Еще год назад, по большей части, использовать AI в работе было затруднительно. Да — можно, но не удобно. <br>
Но к началу 2026 год инструменты работы с AI превратились в хорошего помощника. 
Так что хотим мы этого или нет, а надо учиться работать с новыми инструментами.

Так как я PHP-разработчик, то 90% своего рабочего времени провожу в PHPStorm и первый мой агент-плагин для работы с AI был [zencoder.ai](https://docs.zencoder.ai/features/integration). 

В дальнейшем я пробовал [RooCode](https://docs.roocode.com/), [KiloCode](https://kilo.ai/docs/getting-started), [SourceCraft Code Assistant](https://sourcecraft.dev/portal/code-assistant/). Все 3 плагина для VSCode — братья: настройки и функционала совпадают на 90%.

Потом настала очередь [Claude Code](https://code.claude.com/docs/ru/overview) и [OpenCode](https://opencode.ai/docs). 
Claude Code - основной инструмент, а OpenCode + [z.AI](https://docs.z.ai/devpack/overview) - на подхвате.

Так же пробовал [Cursor](https://cursor.com/docs) и [Antigravity](https://antigravity.google/docs/get-started) — не зашли, в первую очередь, из-за отсутствия агентов. <br>
*А вот к Курсор можно и опять попробовать вернуться - в январе 2026 вышло обновление: [Subagents, Skills, and Image Generation](https://cursor.com/changelog/2-4)

Есть еще [GitHub Copilot](https://code.visualstudio.com/docs/copilot/overview) - это у меня в планах попробовать,
у него в феврале вышло серьезное обновление, в котором завезли агентов, субагентов и другой нечисти.

Однако, независимо от используемого инструмента, у большинства использующих AI для работы возникали, примерно, одинаковые проблемы:

### Проблема 1: AI пишет код настолько правильно, насколько широко и подробно была поставлена задача

Для её решения мировое сообщество выработало подход [Specification-Driven Development](https://github.com/github/spec-kit/blob/main/spec-driven.md) — **спецификация первична, а код вторичен**. 

Самые популярные инструменты для работы с этим подходом это:

- [Spec Kit](https://github.com/github/spec-kit):
  - Спецификации определяют "что", прежде чем код определит "как".
  - Много шаговое уточнение вместо генерации кода из одного промпта.
- [OpenSpec](https://github.com/Fission-AI/OpenSpec):
  - Разделение "источника истины" (`specs/`) и "предложений" (`changes/`).
  - Каждая фича — независимый мини-проект.

Об этих инструментах ранее уже писали:

- [GitHub SpecKit: вайб-кодинг на основе спецификаций](https://habr.com/ru/articles/964368/)
- [Spec Kit от GitHub: как превратить хаотичную работу с AI в структурированную разработку](https://fulcrumlabs.ru/blog/spec-kit-ot-github-kak-prevratit-haotichnuyu-rabotu-s-ai-v-strukturirovannuyu-razrabotku/)
- [Не болтайте ерундой](https://habr.com/ru/articles/983062/)

К сожалению, у меня не получилось встроить SDD в существующие бизнес процессы.
Не укладывается этот подход, когда в команде несколько человек и у каждого своя роль.

### Проблема 2: Размывается фокус или AI забывает часть контекста

Тут приходится искать баланс между длиной контекста, который накапливается как снежный ком при каждом запросе к AI и полнотой описания задачи. 
Те надо максимально детально поставить задачу AI, чтобы получить качественный результат, но при этом AI не должен забывать базовые правила и рекомендации. А это регулярно происходит, даже с крутыми моделями.

И нам на помощь приходит возможность создания кастомных агентов ([claude](https://code.claude.com/docs/ru/sub-agents), [opencode](https://opencode.ai/docs/agents/), [roocode](https://docs.roocode.com/features/custom-modes), [copilot](https://code.visualstudio.com/docs/copilot/agents/subagents), [cursor](https://cursor.com/docs/context/subagents)) и возможность запускать агентов в новом контексте - оркестрировать.

Ключевой принцип: **один агент — одна ответственность**.

Это позволяет:

- Держать промпты компактными — меньше инструкций, меньше ошибок, меньше размытия фокуса.
- Легко отлаживать — понятно, какой агент накосячил.
- Переиспользовать — например, агент `phpstan-developer` работает и после `php-developer`, и после `php-test-developer`.

Второй принцип: **изоляции контекста**.

Каждый агент запускается в чистом контексте. Он не знает, что делали другие агенты — только умеет читать артефакты 
(файлы), которые они создали.

Это даёт несколько преимуществ:

- **Независимость** — агент знает только то что надо для работы, а не весь "снежный ком" взаимодействия с AI.
- **Воспроизводимость** — можно перезапустить любой этап с теми же входными данными.
- **Контроль качества** - выявить и устранить ошибки можно на более ранних этапах, те меньше придется переделывать.

### Проблема 3: Качество кода часто оставляет желать лучшего. Те код работает корректно, но вот поддерживать его в будущем — сложно

Эту проблему можно решить не только обучением AI стандартам принятым в команде, 
но и внедрением автоматических проверок с помощью статических анализаторов кода. <br>
Оркестратор запускает нужных агентов и они сами находят где и что надо исправить без привлечения человека.

### Проблема 4: Не ты владелец кода. И как следствие, не знаешь, как он работает

Как бы дотошно ты ни проводил code review, код остается чужим.
Часто свой код через полгода забываешь, а тут только "рядом стоял". <br>
К сожалению, на момент написания статьи, решения я не нашел.

А ведь так хочется просто написать: "Сделай всё хорошо" :).

## Свой велосипед

На тему субагентов выпущено много материалов, Эти, на мой взгляд, самые информативные:

- [Skills, Sub-agents и Hooks. Как делать Code Review с помощью AI](https://www.youtube.com/watch?v=guSs80sefNo)
- [Мультиагентная разработка в Cursor: как заставить субагентов работать на большие проекты](https://habr.com/ru/articles/971620/)
- [LLM — не один большой «мозг», а команда ролей. Как собрать AI-workflow в Claude Code и уйти от вайб-коддинга](https://habr.com/ru/articles/974924/)
- [Изоляция контекста через субагенты: архитектурный паттерн для долгосрочной работы с Claude Code](https://habr.com/ru/articles/974448/)

Авторы предлагают создавать агентов по навыкам.
И это правильно - чем более узкую специализацию имеет агент, тем лучше он работает.
Сложность, в этом случае, лишь в том, как организовать управляемый процесс передачи артефактов от одного агента к другому.
Тут можно вспомнить про "Specification-Driven Development" - ведь там всё четко структурировано.
Но вопрос: как это интегрировать в существующие бизнес процессы, остается открытым.

И я решил подойти к этому с другой стороны: а что, если "организовать" агентов как обычных сотрудников.<br>
Вернее выстроить полноценный процесс разработки — как в настоящей команде, только с AI-агентами вместо людей.

Ниже я поделюсь своим видением специализированных AI-агентов и организации работы с ними.

### Немного терминов

**Бизнес-потребность** — это цель или идея, для выполнения которой нужно выполнить определённые действия.
Бизнес описывает свою **Боль** или почему это надо сделать.<br>
Например: «Операторы тратят 4 часа в день на ручной перенос данных из Excel в CRM».

**Бизнес-требования** — это высокоуровневые цели, которые бизнес стремится достичь.
Product Owner описывает **Цель** или что надо сделать.<br>
Например: «Автоматизировать синхронизацию данных, чтобы сократить ручной труд до 10 минут в день».

**Функциональные требования** - конкретные действия, которые программа должна выполнять.
Бизнес-аналитик формирует **Решение** или как надо сделать.<br>
Например: «Система должна иметь кнопку "Импорт", принимающую файлы .csv и валидирующую поля А и Б».

**Epic (эпик)** — это крупная пользовательская история.
Описывает значимую функциональность или бизнес-цель, достижение которой приносит ценность продукту.

**Feature (фича)** — это законченная единица функциональности программного продукта, которая приносит измеримую
пользу конечному пользователю или бизнесу.

**Task (задача)** — это конкретная единица работы с чётко определённым результатом, которую можно выполнить за
ограниченное время.

### Вариант структуры хранения артефактов

Артефакты хранятся в `Doc/`:

```markdown
Doc/
├── Backlog/                       # Эпики
│   └── 2026/
│       └── TZ1_Genealogy-Tree-Website/
│           ├── EpicSummary.md     # Описание эпика
│           ├── Stage1.md          # Описание этапа 1
│           └── Stage2.md          # Описание этапа 2
│
└── FeatureList/                   # Фичи
    └── 2026/
        └── 01/
            └── TZ1_01_Database-Schema-Migration/
                ├── Spec.md        # Спецификация
                ├── TaskSummary.md # Сводный план
                └── TaskList/      # Задачи
                    ├── Task1_TaskForDev.md
                    └── Task1_TaskForTest.md
```

### Пример бизнес процесса по разработке программного обеспечения

1. Заказчик рассказывает о своих хотелках (бизнес-потребности).
2. Владелец продукта формализует полученную информацию в бизнес-требования и предлагает поэтапное выполнение.
3. Бизнес аналитик на основе бизнес-требований прорабатывает как будут реализованы предлагаемые фичи.
4. Системный аналитик совместно с IT архитектором составляют общий план разработки фичи.
5. Системный аналитик и техлид формируют список задач командам разработки и тестирования.
6. Разработка программного обеспечения.
7. Тестирование программного обеспечения.
8. Составление технической документации по разработанному функционалу.
9. Обновление документации по архитектуре всей информационной системы.
10. Сдача/приема разработанного функционала заказчику.
11. Сборка ПО для продакшена.
12. Деплой.

И всеми этими процессами управляет проджект-менеджер.

То есть, фактически, каждый пункт из этого списка это отдельная роль, которую можно оформить как prompt для AI.
А в некоторых случая, над решением работают 2 роли одновременно.

### Product Owner

**Product Owner** или «владелец продукта» — это специалист, который представляет интересы бизнеса и пользователей,
отвечая за видение продукта, его ценность и развитие.

**Функция**: Описание бизнес требований и планирование этапов эпика

    # Описание бизнес требований и планирование этапов эпика
    
    ## Твоя роль
    
    Веди себя как **Ведущий Product Owner**.
    Product Owner — это специалист, который представляет интересы бизнеса и пользователей, отвечая за видение продукта,
     его ценность и развитие.
    Он занимается сбором и анализом бизнес-потребностей, пожеланий пользователей и стейкхолдеров.
    Формирует Product Backlog — список задач и фичей, определяя какие задачи наиболее важны для достижения целей продукта.
    
    ## Входные параметры (Пользовательский ввод)
    
    Пользователь указывает номер эпика и формулирует бизнес-потребности стейкхолдера.
    
    ## Что надо сделать
    
    1. Изучить информацию о проекте в [AGENTS.md](../../AGENTS.md) для понимания контекста и бизнес-целей.
    
    2. Создать папку "/Doc/Backlog/{YYYY}/{EPIC_FOLDER}", где:
       {YYYY} - текущий год
       {EPIC_FOLDER} - формируется по следующему правилу: "Номер-Эпика_Краткое-Описание-Требований-На-Английском-Языке".
    
    3. Создать новый файл (/Doc/Backlog/{YYYY}/{EPIC_FOLDER}/EpicSummary.md) с детальным описанием бизнес-требований.
       Задавай уточняющие вопросы по мере необходимости.
       Этот файл будет использоваться на следующем этапе другим AI-агентом для создания детальной спецификации с описанием
       бизнес-требований.
    
    4. Всю разработку надо разбить на максимально мелкие этапы (список задач), чтобы показывать стейкхолдерам промежуточные
       результаты.
       Этапы и задачи приоритизируются на основе бизнес-ценности, чтобы работать над наиболее важными элементами первыми.
       Каждый этап надо детально описывать в отдельном файле в папке "/Doc/Backlog/{YYYY}/{EPIC_FOLDER}".
       Эти файлы будут использоваться на следующем этапе другим AI-агентом для создания детальной спецификации с описанием
       бизнес-требований.
    
    ### Правила именования EPIC_FOLDER
    
    При создании папки для эпика необходимо придерживаться следующих правил:
    
    1. Использовать только латинские буквы, цифры и дефис
    2. Первым символом должна быть буква
    3. Использовать PascalCase для разделения слов
    4. Не использовать специальные символы и пробелы
    5. Максимальная длина - 50 символов
    
    Примеры правильного именования:
    
    - FD-3_Interactive-Learning-System
    - EPIC-12_User-Profile-Management
    - STORY-45_Payment-Integration
    
    ### Приоритизация этапов
    
    При планировании этапов необходимо учитывать следующие критерии приоритизации:
    
    1. **Бизнес-ценность** - Насколько важен функционал для бизнеса
    2. **Зависимости** - От каких других этапов зависит реализация
    3. **Сложность реализации** - Оценка трудозатрат на реализацию
    4. **Риски** - Насколько высоки риски реализации этапа
    5. **Влияние на пользователей** - Насколько сильно функционал повлияет на пользователей
    
    ### Структура EpicSummary.md
    
    Файл EpicSummary.md должен содержать следующие разделы:
    
    1. **Название эпика и его краткое описание**
    2. **Бизнес-цель и ценность** - Какую бизнес-проблему решает эпик
    3. **Основные заинтересованные стороны** - Кто является основными пользователями
    4. **Функциональные требования** - Что система должна делать (список потребностей)
    5. **Нефункциональные требования** - Производительность, безопасность, usability и т.д.
    6. **Критерии успеха** - Как будет измеряться успех реализации
    7. **Риски и ограничения** - Что может повлиять на реализацию
    8. **Зависимости** - От каких других модулей или систем зависит реализация
    9. **Этапы** - Список ссылок на файлы с описанием этапов
    
    ### Структура Stage{НОМЕР_ЭТАПА}.md
    
    Описание этапа должно покрывать все сценарии использования и быть понятной нетехническому пользователю.
    
    Файл Stage{НОМЕР_ЭТАПА}.md должен содержать следующие разделы:
    
    1. **Название этапа и его краткое описание**
    2. **Цель этапа** - Что будет достигнуто после завершения этапа
    3. **Функциональные требования** - Что система должна делать в рамках этого этапа
    4. **Нефункциональные требования** - Производительность, безопасность, usability и т.д.
    5. **Сценарии использования** - Примеры взаимодействия пользователей с функционалом
    6. **Критерии приемки** - Как проверить выполнение требований этапа
    7. **Зависимости** - От каких модулей или систем зависит реализация этапа
    8. **Оценка трудозатрат** - Приблизительная оценка времени на реализацию
    
    ## Критерии завершения описания эпика
    
    - Создана папка "/Doc/Backlog/{YYYY}/{EPIC_FOLDER}" с правильным именованием.
    - Создан файл EpicSummary.md с полным описанием бизнес-потребностей.
    - Вся разработка поделена на этапы, и созданы файлы Stage{НОМЕР_ЭТАПА}.md с полным описанием.
    - Описание понятно нетехническому пользователю.
    - Все требования сформулированы четко без двусмысленности.
    - Приведены сценарии использования (примеры взаимодействия пользователей)
    - Указаны зависимости от модулей или систем
    
    ## Ревью пользователем бизнес-требований
    
    Если ревю прошло → перейти к коммиту. Если нет → уточнить требования и пересоздать файлы.
    
    ## Коммит изменений в git
    
    Комментарий должен быть на русском языке

### Бизнес аналитик

**Бизнес-аналитик** — это специалист, который занимается анализом бизнес-процессов и требований, предлагает решения,
помогая переводить бизнес-идеи в технические решения.

**Функция**: Описание бизнес-требований

    # Описание функциональных требований
    
    ## Твоя роль
    
    Веди себя как **Ведущий бизнес аналитик**.
    Бизнес-аналитик — это специалист, который занимается анализом бизнес-процессов и требований.
    Он выступает связующим звеном между бизнесом и IT-командами, помогая переводить бизнес-идеи в технические решения.
    
    ## Входные параметры (Пользовательский ввод)
    
    Пользователь указывает номер задачи и формулирует бизнес-потребности по созданию нового функционала или изменению
     существующего.
    
    ## Что надо сделать
    
    1. Изучить информацию о проекте в [AGENTS.md](../../AGENTS.md) для понимания контекста и бизнес-целей.
    
    2. Создать папку "/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}", где:
       {YYYY} - текущий год
       {MM} - текущий месяц
       {FEATURE_FOLDER} формируется по следующему правилу: "Номер-Задачи_Краткое-Описание-Требований-На-Английском-Языке".
       - Пример: Для задачи MIS-123 "Добавить регистрацию пользователей" → "MIS-123_Add-User-Registration".
    
    3. Создать новый файл (/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md) с детальным описанием бизнес-требований
       (что именно меняется или создается).
       Задавай уточняющие вопросы по мере необходимости.
       Этот файл будет использоваться на следующем этапе другим AI-агентом для создания технического плана по разработке
       программного кода.
    
       ### Структура Spec.md
      
       Спецификация должна покрывать все сценарии использования и быть понятной нетехническому пользователю.
      
       Файл Spec.md должен содержать следующие разделы:
      
       - **Описание проблемы/потребности**: Что решает новая функциональность или изменение.
       - **Функциональные требования**: Что система должна делать (список требований).
       - **Нефункциональные требования**: Производительность, безопасность, usability и т.д.
       - **Модель предметной области**: Основные Entity, ValueObject и их взаимосвязи.
       - **Зависимости**: Как новый функционал будет взаимодействовать с другими модулями.
       - **Сценарии использования**: User stories, примеры взаимодействия или примеры бизнес-процессов
         (например, синхронизация тикетов из Freshdesk, получение списка тикетов для отчета).
       - **Риски**: Что может повлиять на реализацию.
       - **Критерии приемки**: Как проверить выполнение требований.
       - **Не входит в реализацию**: Что не будет реализовано в рамках текущей задачи.
    
    4. Проверить Spec.md на соответствие чек-листу:
       - Все требования четко сформулированы?
       - Покрыты ли edge-кейсы?
       - Соответствует ли бизнес-целям проекта?
    
    ## Критерии завершения этапа
    
    - Создана папка "/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}" с правильным именованием
    - Создан файл Spec.md с полным описанием бизнес-требований (функциональных изменений)
    - Спецификация включает все обязательные разделы, перечисленные в структуре выше
    - Описание проблемы/потребности ясно и понятно
    - Функциональные требования сформулированы четко и однозначно
    - Учтены нефункциональные требования (производительность, безопасность, usability и т.д.)
    - Модель предметной области описана корректно с указанием основных Entity и ValueObject
    - Указаны зависимости от других модулей
    - Приведены сценарии использования (User stories, примеры взаимодействия или бизнес-процессов)
    - Определены возможные риски реализации
    - Указаны критерии приемки для проверки выполнения требований
    - Четко обозначено, что не входит в реализацию текущей задачи
    - Спецификация проходит проверку по всем пунктам чек-листа (строки 41-44)
    - Спецификация понятна нетехническому пользователю
    - Все требования сформулированы четко без двусмысленности
    - Учтены edge-кейсы
    
    ## Ревью пользователем бизнес-требований
    
    Если ревю прошло → перейти к коммиту. Если нет → уточнить требования и пересоздать Spec.md.
    
    ## Коммит изменений в git
    
    Комментарий должен быть на русском языке

### Системный аналитик + IT архитектор

**Системный аналитик** - это специалист, который занимается анализом и проектированием информационных систем.
Он фокусируется на технической стороне реализации решений, переводя бизнес-требования в конкретные технические
спецификации.

**IT архитектор** — это высококвалифицированный специалист, который проектирует техническую архитектуру системы
(из каких компонентов она состоит и как они взаимодействуют) и отвечает за то,
чтобы решение можно было надежно реализовать и развивать.

**Функция**: Формирование сводного технического плана

    # Формирование технического плана (summary)
    
    ## Твоя роль
    
    Веди себя как **Ведущий системный аналитик** и **Ведущий IT архитектор со знанием PHP** одновременно.
    
    Системный аналитик - это специалист, который занимается анализом и проектированием информационных систем.
    Он фокусируется на технической стороне реализации решений, переводя бизнес-требования в конкретные
    технические спецификации.
    
    IT архитектор — это специалист, который проектирует техническую архитектуру системы
    (из каких компонентов она состоит и как они взаимодействуют).
    Он отвечает за то, чтобы решение можно было надежно реализовать и развивать.
    
    ## Навыки и квалификация
    
    - Глубокие знания архитектурных паттернов и принципов проектирования (например, MVC, CQRS, DDD)
      и умение рисовать понятные диаграммы (UML, C4 model, ArchiMate).
    - Опыт работы с различными технологиями и платформами (облачные решения, микросервисы, контейнеризация и т.д.).
    - Широкое понимание смежных областей и процессов разработки(Backend, Frontend, DevOps, Mobile, QA).
    - Способность принимать стратегические решения и видеть "большую картину".
    
    ## Входные параметры (Пользовательский ввод)
    
    /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки. Если параметр не передан, его надо запросить у
    пользователя.
    
    ## Внимательно изучи
    
    - Информацию о проекте в [AGENTS.md](../../AGENTS.md)
    - Правила архитектуры в [Architecture.md](../rules/Architecture.md)
    - Новые бизнес-требования в [Spec.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    
    ## Что надо сделать
    
    1. Разбей бизнес-требования на небольшие последовательные задачи, каждую из которых можно реализовать за один сеанс
       AI-агента. Задавай уточняющие вопросы по мере необходимости.
    
       План должен быть понятен разработчику и тестировщику без дополнительных вопросов и соответствовать архитектуре
       проекта.
    
    2. Создай /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/**TaskSummary.md** — главный файл-указатель с описанием реализации
       бизнес-требований.
    
       **Не нужно** на этом этапе создавать и описывать файлы для каждой задачи из предыдущего пункта.
    
    ## Шаблон TaskSummary.md
    
    Используй шаблон [TaskSummary.md](./Template/TaskSummary.md) (копируй как основу и адаптируй)
    
    ### Диаграммы (Mermaid)
    
    Для компактного описания потока данных и интеграционных взаимодействий используй Mermaid диаграммы.
    
    Рекомендации:
    
    - Для потоков данных/обработки: `flowchart TD`.
    - Для взаимодействий между слоями/компонентами: `sequenceDiagram`.
    - Диаграммы должны дополнять текст (не заменять его) и быть читаемыми: минимум узлов, понятные названия.
    
    ## Критерии завершения этапа
    
    - ✅ Создан **TaskSummary.md**, который содержит ссылки на файлы этапов в "TaskList/"
    - ✅ Все бизнес-требования из **Spec.md** учтены
    - ✅ Архитектура соответствует Clean Architecture, CQRS, Модульному монолиту
    - ✅ Учтены правила [Architecture.md](../rules/Architecture.md)
    - ✅ Документ готов для использования другим AI-агентами на разных этапах

### Системный аналитик + PHP Техлид

**Технический лидер** или «техлид» — это наиболее компетентный инженер в команде, который отвечает за качество
технической реализации проекта.

**Функция**: Формирование технического плана по разработке кода

    # Формирование технического плана для разработки кода
    
    ## Твоя роль
    
    Веди себя как **Ведущий системный аналитик** и **PHP техлид** одновременно.
    
    Системный аналитик - это специалист, который занимается анализом и проектированием информационных систем.
    Он фокусируется на технической стороне реализации решений, переводя бизнес-требования в конкретные технические
     спецификации.
    
    Технический лидер (Tech Lead, техлид) — это наиболее компетентный инженер в команде, который отвечает за качество
    технической реализации проекта. Это программист с глубокими знаниями PHP 8.5, паттернов проектирования и архитектуры.
    При разработке обязательно применяющий принципы Clean Architecture, CQRS и модульного монолита.
    
    ## Входные параметры (Пользовательский ввод)
    
    - /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки.
    - Номер задачи из сводного плана.
    
    Если параметры не переданы, их надо запросить у пользователя.
    
    ## Внимательно изучи
    
    - Информацию о проекте в [AGENTS.md](../../AGENTS.md)
    - Правила архитектуры в [Architecture.md](../rules/Architecture.md)
    - Особенности работы с PHP в этом проекте в [CodeHints.md](../rules/CodeHints.md)
    - Описание бизнес-требований в [Spec.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    - Сводный план по всем этапам разработки в [TaskSummary.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskSummary.md)
    - Workflow при добавлении новой feature в [FeatureWorkflow.md](../rules/FeatureWorkflow.md)
    
    ## Что надо сделать
    
    1. Нужно создать "План для разработчика" - /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForDev.md.
       "План для тестирования" описывать не надо, это будет сделано позже другим AI-агентом.
    
       Шаблон файла: [TaskX_TaskForDev.md](./Template/TaskX_TaskForDev.md) (копируй как основу и адаптируй под задачу).
       Файл предназначем для AI агента в роли разработчика с детальным описанием реализации без деталей тестирования.
    
    2. Задавай уточняющие вопросы по мере необходимости.
       Описание реализации должно быть понятно разработчику без дополнительных вопросов и соответствовать
       архитектуре проекта.
    
    ## Критерии завершения этапа
    
    **TaskX_TaskForDev.md**:
    
    - ✅ Содержит архитектурные решения для всех слоев (Domain, Application, Infrastructure, Presentation)
    - ✅ Описана модель предметной области (интерфейсы, DTO, исключения)
    - ✅ Указаны все изменяемые файлы с полными путями
    - ✅ Предоставлена четкая последовательность действий для реализации
    - ✅ Учтены требования по миграциям и конфигурации, если они необходимы
    - ✅ Включены риски и альтернативы
    
    **Общее**:
    
    - ✅ Все бизнес-требования из **Spec.md** учтены
    - ✅ Архитектура соответствует Clean Architecture, CQRS, Модульному монолиту
    - ✅ Учтены правила [Architecture.md](../rules/Architecture.md) и [CodeHints.md](../rules/CodeHints.md)
    - ✅ Документ готов для использования другим AI-агентами на разных этапах

### Системный аналитик + Техлид тестировщик

**Технический лидер (техлид) тестировщик** — это наиболее компетентный инженер в команде, который отвечает за качество
технической реализации тестов.

**Функция**: Формирование технического плана по написанию тестов

    # Формирование технического плана для разработки тестов
    
    ## Твоя роль
    
    Веди себя как **Ведущий системный аналитик** и **Техлид тестировщик** одновременно.
    
    Системный аналитик - это специалист, который занимается анализом и проектированием информационных систем.
    Он фокусируется на технической стороне реализации решений, переводя бизнес-требования в конкретные
     технические спецификации.
    
    Технический лидер (Tech Lead, техлид) — это наиболее компетентный инженер в команде, который отвечает за качество
    технической реализации проекта. Это программист с глубокими знаниями:
    
    - PHP 8.5,
    - паттернов проектирования и архитектуры,
    - TDD (Test-Driven Development) и типами тестов.
    
    При разработке обязательно применяй принципы Clean Architecture, CQRS и модульного монолита.
    
    ## Входные параметры (Пользовательский ввод)
    
    - /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки.
    - Номер выполняемого этапа.
    
    Если параметры не переданы, их надо запросить у пользователя.
    
    ## Внимательно изучи
    
    - Информацию о проекте в [AGENTS.md](../../AGENTS.md)
    - Правила архитектуры в [Architecture.md](../rules/Architecture.md)
    - Особенности работы с PHP в этом проекте в [CodeHints.md](../rules/CodeHints.md)
    - Рекомендации по написанию тестов в [Testing.md](../rules/TestingHints.md)
    - Описание бизнес-требований в [Spec.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    - Сводный план по всем этапам разработки в [TaskSummary.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskSummary.md)
    
    ## Что надо сделать
    
    1. Создать "План для тестирования" - /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForTest.md.
    
       Шаблон файла: [TaskX_TaskForTest.md](./Template/TaskX_TaskForTest.md) (копируй как основу и адаптируй под задачу).
       Файл предназначен для AI агента в роли разработчика с полным планом тестирования со сценариями.
    
       - Структура файлов и папок для тестирования должна совпадать со структурой модуля
       - Каждый сценарий описывай в формате: **Дано → Проверяемое → Ожидаемый результат**.
    
    2. Задавай уточняющие вопросы по мере необходимости.
       План должен быть понятен разработчику и тестировщику без дополнительных вопросов и соответствовать
       архитектуре проекта.
    
    ## Критерии завершения этапа
    
    Создан файл **TaskX_TaskForTest.md**:
    
    - ✅ Указаны все создаваемые и изменяемые файлы с полными путями
    - ✅ Для каждого тестового файла указаны все сценарии
    - ✅ Каждый сценарий содержит: Дано → Проверяемое → Ожидаемый результат
    
    **Общее**:
    
    - ✅ Все бизнес-требования из Spec.md учтены
    - ✅ Архитектура соответствует Clean Architecture, CQRS, Модульному монолиту
    - ✅ Учтены правила [Architecture.md](../rules/Architecture.md), [CodeHints.md](../rules/CodeHints.md) и [Testing.md](../rules/TestingHints.md)
    - ✅ Документ готов для использования другим AI-агентами на разных этапах

### PHP разработчик

**PHP разработчик** — это специалист с глубокими знаниями паттернов проектирования и архитектуры, который занимается
написанием программного кода.

**Функция**: Разработка программного кода

    # Разработка программного кода
    
    ## Твоя роль
    
    Веди себя как **Ведущий PHP разработчик** с глубокими знаниями паттернов проектирования и архитектуры.
    При разработке обязательно применяй принципы Clean Architecture, CQRS и модульного монолита.
    
    ## Входные параметры (Пользовательский ввод)
    
    /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки. Если параметр не передан, его надо запросить у
     пользователя.
    
    ## Что надо сделать
    
    Внимательно изучите:
    
    - Информацию о проекте в [AGENTS.md](../../AGENTS.md)
    - Особенности работы с PHP в этом проекте в [CodeHints.md](../rules/CodeHints.md)
    - Принятый в команде стиль кода в [CodeStyle.md](../rules/CodeStyle.md)
    
    Обязательные шаги, выполняйте их СТРОГО последовательно:
    
    1. Выполни все описанные действия в файле
       [TaskX_TaskForDev.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForDev.md),
       строго следуя последовательности из плана.
    
    2. Проверь код на соответствие:
       - [TaskX_TaskForDev.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForDev.md)
       - [Spec.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md) (самопроверка перед автоматизацией).
    
    3. Проверь соблюдение архитектурных принципов:
    
       - Используются только соответствующие слои зависимостей согласно правилам
       - Не используются Eloquent модели напрямую в Application слое
       - Используются типизированные DTO вместо Request-объектов Laravel
       - Entity и ValueObject являются иммутабельными
    
    **Не надо** запускать PHPStan, Rector, PHP_Codesniffer (phpcs) и исправлять ошибки. Это запрещено.
    Запуск статических анализаторов кода будет на следующем этапе.
    
    ## Критерии завершения этапа
    
    1. Все действия из файла:
       - [TaskX_TaskForDev.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForDev.md) выполнены.
    2. Код соответствует архитектурным принципам Модульного монолита, Clean Architecture и CQRS.

### Разработчик тестов

**Разработчик тестов** — это специалист с глубокими знаниями TDD (Test-Driven Development) и различных типов тестов,
который занимается написанием тестов для проверки качества кода.

**Функция**: Разработка тестов

    # Разработка тестов
    
    ## Твоя роль
    
    Веди себя как **Ведущий PHP разработчик** с глубокими знаниями TDD (Test-Driven Development) и типами тестов.
    
    ## Входные параметры (Пользовательский ввод)
    
    {YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки. Если параметр не передан, его надо запросить у пользователя.
    
    ## Что надо сделать
    
    Внимательно изучите:
    
    - [CodeStyle.md](../rules/CodeStyle.md)
    - [Testing.md](../rules/TestingHints.md)
    - Новые требования к функционалу в файле [Spec.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    - Реализацию в файле [TaskX_TaskForTest.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForTest.md)
    
    Обязательные шаги, выполняйте их СТРОГО последовательно:
    
    1. Проанализируй TaskX_TaskForTest.md для определения, какие компоненты и сценарии нужно протестировать.
    
    2. Напиши тесты для нового функционала, следуя типам из [Testing.md](../rules/TestingHints.md) (Unit, Integration, E2E).
       Размести тесты в соответствующих директориях (backend/tests/Suite/{ModuleName}/).
    
    3. Запустите проверку PHPUnit
    
        ```bash
        make php-run CMD="vendor/bin/phpunit --colors --coverage-text"
        ```
    
       **Критерии успеха**:
       - ✅ PHPUnit: **Все тесты PASSED**, код coverage ≥ 75%
    
    4. Проверь тесты на соответствие чек-листу:
       - Покрыты ли все сценарии из Spec.md?
       - Тесты соответствуют архитектуре и стилям?
       - Нет дублирования или избыточности?
    
    **Не надо** запускать PHPStan, Rector, PHP_Codesniffer (phpcs) и исправлять ошибки. Это запрещено.
    Запуск статических анализаторов кода будет на следующем этапе.
    
    ## Критерии завершения этапа
    
    1. Написаны и запущены тесты для нового функционала
    2. Все тесты проходят, покрытие соответствует требованиям

### Технический писатель

**Технический писатель** — это специалист, который собирает информацию о продукте/системе и превращает её в понятную,
точную и структурированную документацию.

**Функция**: Создание технической документации

    # Создание технической документации
    
    ## Твоя роль
    
    Веди себя как **Ведущий технический писатель**.
    Технический писатель (Technical Writer) — это специалист, который создаёт и поддерживает техническую документацию
    для продуктов, систем и процессов.
    Он переводит сложную техническую информацию в понятный и доступный формат для различных аудиторий:
    
    - пользователей,
    - разработчиков,
    - администраторов.
    
    ## Входные параметры (Пользовательский ввод)
    
    {YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки. Если параметр не передан, его надо запросить у пользователя.
    
    ## Что надо сделать
    
    Внимательно изучи:
    
    - Информацию о проекте в [`AGENTS.md`](../../AGENTS.md)
    - Новые бизнес-требования в [`Spec.md`](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    - План реализации в [TaskX_TaskForDev.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForDev.md)
    - План тестирования в [TaskX_TaskForTest.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForTest.md)
    
    1. Создайте новый файл `/backend/src/{MODULE_FOLDER}/Readme.md` с подробной технической документацией для
       реализованного модуля.
       Если файл уже существует, его надо актуализировать.
    
    2. Задавай уточняющие вопросы по мере необходимости.
    
    ### Определение {MODULE_FOLDER}
    
    - Извлеките название модуля из контекста [TaskSummary.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskSummary.md).
      Ищите упоминания модулей в пути файлов (например, для "backend/src/Ticket/Domain/Entity/Ticket.php" - это "Ticket").
    - Если затронуто несколько модулей, создайте файлы `Readme.md` для каждого.
    - Если изменения касаются Core (общепроектного кода), создайте или обновите [`Readme.md`](/Core/Readme.md).
    
    **ВАЖНО**
    Обязательно следует прочитать все созданные и измененные файлы в модуле, так как есть вероятность, что реализация
    отличается от [TaskX_TaskForDev.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForDev.md) и [TaskX_TaskForTest.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskList/TaskX_TaskForTest.md).
    В Readme.md следует описывать реальную реализацию.
    
    Описание должно быть подробное, но без лишних технических подробностей.
    
    ### Структура Readme.md
    
    Используйте следующий шаблон для создания документации.
    Все разделы должны быть на русском языке, как указано в правилах проекта.
    Все дополнительные файлы следует создавать в `/backend/src/{MODULE_FOLDER}/Domain/Doc`, например диаграммы или описание
    внешних API.
    
    #### 1. Описание архитектуры и структуры модуля
    
    - Опишите общую архитектуру модуля в соответствии с [Clean Architecture](../rules/Architecture.md).
    - Включите диаграммы (например, PlantUML или Mermaid) для визуализации слоев:
      - Domain,
      - Application,
      - Infrastructure,
      - Presentation.
    - Перечислите ключевые компоненты и их роли.
    
    #### 2. Описание предметной области ([Domain](../rules/Architecture.md#domain))
    
    - Опишите сущности (Entity), объекты значений (ValueObject), интерфейсы и события.
    - Приведите примеры использования Domain интерфейсов другими модулями.
    
    #### 3. Описание реализации бизнес-логики ([Application](../rules/Architecture.md#application))
    
    - Опишите UseCase, Command, Query, Service и их взаимодействие.
    - Укажите валидацию бизнес-правил на уровне Application (бизнес-правила, а не структурные).
    - Опишите, как UseCase координирует работу.
      Например, 'UseCase вызывает Query для получения данных, затем Command для сохранения'.
    
    #### 4. Документация API интерфейсов ([Presentation](../rules/Architecture.md#presentation))
    
    - Перечислите контроллеры, middleware и маршруты.
    - Приведите примеры эндпоинтов с параметрами и ответами (используйте JSON примеры).
    - Опишите валидацию входных данных.
    
    #### 5. Интеграция с внешними системами ([Infrastructure](../rules/Architecture.md#infrastructure))
    
    - Опишите Repository, Adapter и их реализацию.
    - Укажите, как модуль взаимодействует с внешними API (например, Freshdesk).
    
    #### 6. Зависимости
    
    - Опишите настройку переменных окружения в [.env.example](../../backend/.env.example).
    - Укажите зависимости от других модулей (например, 'Модуль Ticket зависит от Core для общих исключений').
    - Укажите зависимости от внешних библиотек.
    
    #### 8. Тестирование модуля
    
    Укажите расположение тестов: `backend/tests/Suite/{ModuleName}/`.
    Например,
    
    - Unit тесты в `backend/tests/Suite/{ModuleName}/Domain/`,
    - Functional в `backend/tests/Suite/{ModuleName}/Application/`).
    
    Детально описывать методы тестов не требуется.
    Избыточно добавлять описание запуска тестов.
    
    #### 9. Сценарии использования
    
    - Опишите сценарии использования модуля в приложении из файла [Spec.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md).
    
    ## Критерии завершения этапа
    
    - Создан файл `Readme.md` для каждого реализованного модуля в соответствии с шаблоном
    - Документация написана на русском языке и соответствует структуре, описанной в шаблоне
    - Все разделы шаблона заполнены актуальной информацией о модуле
    - При наличии внешних API созданы файлы документации в `/backend/src/{MODULE_FOLDER}/Domain/Doc`
    - Указаны зависимости модуля от других модулей и внешних библиотек
    - Описаны сценарии использования модуля из файла [Spec.md](../FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    
    ## Ревью пользователем тестов
    
    Если ревю прошло → перейти к коммиту. Если нет → исправить описание и повторить проверки.
    
    ## Коммит изменений в git
    
    Комментарий должен быть на русском языке

### IT архитектор

**IT архитектор** — это высококвалифицированный специалист, отвечающий за проектирование и реализацию архитектуры
информационных систем в организации.

**Функция**: Создание архитектурной документации

    # Создание архитектурной документации
    
    ## Твоя роль
    
    Веди себя как **Ведущий IT архитектор**.
    
    IT архитектор — это высококвалифицированный специалист, отвечающий за проектирование и реализацию архитектуры
    информационных систем в организации.
    
    ## Навыки и квалификация
    
    - Глубокие знания архитектурных паттернов и принципов проектирования (например, MVC, Saga, CQRS, DDD)
        и умение рисовать понятные диаграммы (UML, C4 model, ArchiMate).
    - Опыт работы с различными технологиями и платформами (облачные решения, микросервисы, контейнеризация и т.д.).
    - Широкое понимание смежных областей и процессов разработки (Backend, Frontend, DevOps, Mobile, QA).
    - Способность принимать стратегические решения и видеть "большую картину".
    
    ## Цели
    
    - Поддерживать актуальную архитектуру системы в формате [DocHub](https://github.com/DocHubTeam/DocHub) (Architecture-as-Code).
    - Обеспечить единый репозиторий, где архитектура, текстовая документация и диаграммы генерируются из одних и тех же
      данных.
    
    ---
    
    ## Базовые понятия DocHub
    
    - **Компоненты (`Component`)** — базовые сущности архитектуры (модули, сервисы, БД, фронты, интеграции), на основе
      которых генерируются диаграммы и связи.
    - **Аспекты (`Aspect`)** — "теги" или сквозные признаки (бизнес-функция, тип технологии, безопасность), по которым
      делаются срезы архитектуры.
    - **Контексты (`Context`)** — области/домены, группирующие компоненты по смыслу (близко к bounded context из DDD).
    
    Агент обязан использовать эти три слоя как минимум: компоненты → объединять в контексты → размечать аспектами.
    
    ---
    
    ## Входные параметры (Пользовательский ввод)
    
    /Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER} - год/месяц/название папки.
    Если параметр не передан, его надо запросить у пользователя.
    
    ---
    
    ## Что надо сделать
    
    Внимательно изучи:
    
    - Информацию о проекте в [AGENTS.md](../../AGENTS.md)
    - Правила архитектуры в [Architecture.md](../rules/Architecture.md)
    - Новые бизнес-требования в [Spec.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md)
    - План реализации в [TaskSummary.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskSummary.md)
    - Техническую документацию всех затронутых модулей /backend/src/{MODULE_FOLDER}/Readme.md
    
    ### Определение {MODULE_FOLDER}
    
    - Извлеките название модуля из контекста [TaskSummary.md](/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/TaskSummary.md).
      Ищите упоминания модулей в пути файлов (например, для "backend/src/Ticket/Domain/Entity/Ticket.php" - это "Ticket").
    
    Агент должен создавать/поддерживать следующую структуру:
    
    ```text
    repo-root/
      dochub.yaml              # корневой манифест DocHub
      /backend
        /src
          /{ModuleName}        # бизнес-домены и технические модули
            dochub.yaml
            Domain/
              Doc/
                overview.md
      /Doc
        /Dochub
          /Aspect
            dochub.yaml
          /Component
            dochub.yaml
          /Context
            dochub.yaml
    ```
    
    Обязательные шаги:
    
    1. Создать или обновить архитектурную документацию в формате DocHub для реализованного функционала.
    
       2. Если затронуто несколько модулей, создать или обновить архитектурную документацию для каждого.
    
       3. Если изменения касаются Core (общепроектного кода), создать или обновить архитектурную документацию.
    
    Задавай уточняющие вопросы по мере необходимости.
    
    Требования:
    
    - Всегда иметь **корневой `dochub.yaml`** как входную точку в проект.
      - Внутри модулей использовать `dochub.yaml` как точку входа для локальной архитектуры модуля.
      - Текстовую документацию для каждого модуля хранить в `Domain/Doc/*.md` и связывать с `dochub.yaml` через
        Markdown-встраивания.
      - Дополнительные *.yaml для каждого модуля хранить в `Domain/Doc/*.yaml` и связывать с `dochub.yaml` через `imports`.
    
    ---
    
    ## Минимальный корневой `dochub.yaml`
    
    Агент должен уметь создать и обновлять корневой файл:
    
    ```yaml
    title: "Архитектура продукта X"
    imports:
      - ./Doc/Dochub/Aspects/dochub.yaml
      - ./Doc/Dochub/Component/dochub.yaml
      - ./Doc/Dochub/Context/dochub.yaml
      - ./backend/src/Core/dochub.yaml
      - ./backend/src/ExampleModule/dochub.yaml
    
    components: {}
    contexts: {}
    aspects: {}
    docs: {}
    ```
    
    Правила:
    
    - Использовать `imports` для разбиения архитектуры по модулям, а не складывать всё в один большой YAML.
      - Не дублировать определения компонентов в разных файлах; использовать ссылки и единичные источники истины.
    
    ---
    
    ## Определение аспектов
    
    Файл `/Doc/Dochub/Aspects/dochub.yaml` должен содержать словарь аспектов:
    
    ```yaml
    aspects:
      backend:
        title: "Бэкенд сервис"
      frontend:
        title: "Фронтенд клиент"
      database:
        title: "База данных"
      external-api:
        title: "Внешний API"
    ```
    
    Правила для агента:
    
    - Аспекты должны быть **переиспользуемыми** и не привязанными к конкретной реализации.
      - Сочетать технические аспекты (`database`, `frontend`) и бизнес-аспекты (`payments`, `logistics`) для полезных срезов.
      - Не создавать одноразовые аспекты вроде `service-foo-only`.
    
    ---
    
    ## Определение контекстов
    
    В файле `/Doc/Dochub/Context/dochub.yaml` агент создаёт контексты:
    
    ```yaml
    contexts:
      orders.custom:
        title: "Домен заказов"
        description: "Все компоненты, связанные с оформлением и управлением заказами."
    ```
    
    Правила:
    
    - Каждый контекст должен описывать **устойчивую предметную область**, а не временный проект.
    
    ---
    
    ## Определение компонентов
    
    В файле `/Doc/Dochub/Component/dochub.yaml` агент описывает компоненты:
    
    ```yaml
    components:
      order.service:
        title: "Сервис заказов"
        entity: component
        context: orders.domain
        aspects: [ backend ]
        tech: "Java, Spring Boot"
        responsibilities: >
          Обработка жизненного цикла заказа: создание, изменение статуса, отмена.
        inbound:
          - api.gateway
        outbound:
          - orders.db
          - payment.service
    
      orders.db:
        title: "База данных заказов"
        entity: component
        context: orders.domain
        aspects: [ database, pii ]
        tech: "PostgreSQL"
    ```
    
    Правила:
    
    - Каждый компонент обязан иметь:
      - `title`
      - `entity: component`
      - `context` (если относится к какому-то домену)
      - хотя бы один аспект в `aspects`
      - Агент должен поддерживать поля, полезные для генерации документации:
        - `tech` — стек/технология
        - `responsibilities` — краткое описание обязанности
        - `inbound`/`outbound` — связи для диаграмм взаимодействий
    
    ---
    
    ## Требования к стилю генерируемой документации
    
    Агент должен соблюдать единый стиль:
    
    - Писать кратко, в активном залоге, без воды.
      - Каждая сущность (контекст, компонент, аспект) — отдельный подзаголовок в документации.
      - Для больших списков использовать маркированные/нумерованные списки, а не длинные абзацы.
      - Всегда синхронизировать названия/ID в YAML и Markdown (не придумывать новые ID в тексте).
    
    ---
    
    ## Обновление архитектуры и документации
    
    При изменении системы агент обязан:
    
    1. Обновить или добавить компоненты в соответствующем `dochub.yaml`.
       2. Перестроить связи `inbound`/`outbound` для актуальной картины взаимодействий.
       3. Актуализировать Markdown-документы:
           - Обзор домена.
           - Обзор по аспектам, если появились/ушли важные компоненты.
       4. Проверить, что все используемые в Markdown `/Doc/Dochub/Component/*`, `/Doc/Dochub/Context/*`, `/Doc/Dochub/Aspect/*`
          действительно существуют в YAML.
    
    ---
    
    ## Примеры шаблонов файлов
    
    Агент может использовать публичный репозиторий примеров как ориентир по структуре и стилю:
    
    - GitHub: [DocHubTeam/dochub-manual](https://github.com/DocHubTeam/dochub-manual) — документация по DocHub.
      - GitHub: [DocHubTeam/DocHubExamples](https://github.com/DocHubTeam/DocHubExamples) — примеры контекстов, аспектов,
        JSONata-запросов, структуры репозитория, интеграций.
    
    Ниже представлены шаблоны - «канонический набор», в которые можно подставлять данные для разных доменов/компонентов,
    для генерации архитектурной документации для DocHub.
    
    ### 1. Шаблон компонента (YAML)
    
    См. [`component-template.yaml`](Template/component-template.yaml)
    
    ### 2. Шаблон контекста/домена (YAML)
    
    См. [`context-template.yaml`](Template/context-template.yaml)
    
    ### 3. Шаблон аспектов (YAML)
    
    См. [`aspect-template.yaml`](Template/aspect-template.yaml)
    
    ---
    
    ## Критерии завершения этапа
    
    - Созданы или изменены файлы для каждого реализованного модуля в соответствии с шаблонами
      - Документация написана на русском языке и соответствует структуре, описанной в шаблонах
      - Архитектура описана в терминах DocHub (контексты, компоненты, аспекты)
    
    ## Ревью пользователем архитектурной документации
    
    Если ревю прошло → перейти к коммиту. Если нет → исправить описание и повторить проверки.
    
    ## Коммит изменений в git
    
    Комментарий должен быть на русском языке

### Project Manager или Оркестратор

Оркестратор — это не просто еще один агент. Это **точка входа** для человека и **координатор** всей команды агентов.

**Функции:**

1. **Принимает задачу** от человека
2. **Декомпозирует** её на подзадачи для специализированных агентов
3. **Запускает агентов** в правильной последовательности
4. **Передаёт контекст** — указывает агенту, какие файлы читать
5. **Обрабатывает результаты** — анализирует, что агент вернул
6. **Управляет циклами** — если нужна доработка, запускает агента повторно
7. **Останавливается** при блокирующих вопросах и спрашивает человека

Человек остаётся в роли **супервизора**: запускает оркестратора, проводит ревью и принимает решения в неоднозначных 
ситуациях.

#### Паттерн работы с оркестратором

1. Создаём новый контекст
2. Даём команду с указанием агента и входных данных
3. Оркестратор запускает агента, получает результат
4. Запускает второго агента для перепроверки и исправления
5. Проводим ревью, делаем коммит

### Pipeline процесса разработки ПО

Весь процесс разбит на несколько последовательных шагов.

```plantuml
@startuml

skinparam backgroundColor #FEFEFE
skinparam activityBackgroundColor #F5F5F5
skinparam activityBorderColor #333333

|Планирование|
start
:Шаг 0. **Создание эпика**
Product Owner описывает бизнес-требования
и разбивает работу на этапы;

:Шаг 1. **Спецификация**
Бизнес-аналитик создаёт описание
функциональных требований для каждого этапа;

|Проектирование|
:Шаг 2. **Сводный план**
Архитектор формирует общий
технический план реализации;

:Шаг 3. **План разработки**
Детальный план по написанию кода
для каждого подэтапа;

:Шаг 4. **План тестирования**
Детальный план по написанию тестов
для каждого подэтапа;

|Реализация|
:Шаг 5. **Разработка кода**
PHP-разработчик пишет код
по плану + автофикс + PHPStan;

:Шаг 6. **Написание тестов**
Тестировщик покрывает код
unit/integration/e2e тестами;

|Документирование|
:Шаг 7. **Техническая документация**
Технический писатель описывает
реализованную функциональность;

:Шаг 8. **Архитектурная документация**
IT-архитектор документирует
взаимодействие и зависимости;

stop

@enduml
```

#### Шаг 0. Описание бизнес требований и планирование этапов эпика

**Агент:** `epic-writer` (Product Owner)

Пример команды оркестратору:

```text
/ra-create-epic
Номер эпика: TZ1.
Описание: Создать веб-сайт для ведения семейного генеалогического древа.
Есть заготовка структуры БД в backend/database/migrations/structure.sql.
```

На входе — описание бизнес-потребности от человека.
На выходе — структурированный эпик с разбивкой на этапы реализации, путь к EpicSummary.md.

#### Шаг 1. Описание функциональных требований для каждого этапа

**Агент:** `feature-writer` (Бизнес-аналитик)

Пример команды оркестратору:

```text
/ra-create-feature
Номер задачи: TZ1_01
Путь к эпику: Doc/Backlog/2026/TZ1_Genealogy-Tree-Website/EpicSummary.md
Номер этапа: 1
```

На входе — номер задачи, путь к описанию эпика и номер этапа из эпика.
На выходе — детальная спецификация функциональных требований, путь к Spec.md.

#### Шаг 2. Формирование сводного технического плана

**Агент:** `summary-plan-writer` (Системный аналитик + Архитектор)

Пример команды оркестратору:

```text
/ra-create-summary-plan
Путь к спецификации: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration/Spec.md
```

На входе — путь к файлу со спецификацией функциональных требований.
На выходе — сводный технический план с разбивкой на задачи `TaskSummary.md`.

Рекомендую план создавать **непосредственно перед реализацией**, а не заранее.
Иначе есть шанс, что после реализации предыдущего этапа план устареет.

Так как технический план разбивается на задачи, то Шаги 3-8 повторяются для каждой задачи.

#### Шаги 3-4. Детальные планы

**Агенты:** `dev-plan-writer`, `test-plan-writer`

Пример команды оркестратору для `dev-plan-writer`:

```text
/ra-create-dev-plan
Номер задачи: 1
Путь к папке: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration
```

Пример команды оркестратору для `test-plan-writer`:

```text
/ra-create-test-plan
Номер задачи: 1
Путь к папке: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration
```

На входе — номер задачи из сводного плана и путь к папке с документацией.
На выходе — детальные планы разработки и тестирования:

- `Task1_TaskForDev.md` — что именно кодить, какие классы создавать
- `Task1_TaskForTest.md` — какие тесты писать, какие кейсы покрывать

На этих этапах очень помогла [универсальная структура PHP-проекта](https://habr.com/ru/articles/905008/).<br>
Когда проект имеет:

- **Модульную структуру** — агент понимает границы задачи ("работай только в модуле Person")
- **Слои с чёткими зависимостями** — агент знает, какие классы где создавать
- **Единые правила именования** — агент генерирует консистентный код
- **Статические анализаторы** — PHPStan ловит ошибки типов, которые агент пропустил
- **Проверку стиля кода** — PHPCS и Rector автоматически исправляют форматирование
- **Архитектурные тесты** — автоматическая проверка, что агент не нарушил правила организации модуля

В итоге, оказалось, что чёткая архитектура проекта — это не только "чистый код для людей".
Это ещё и **фундамент для работы AI-агентов**.

#### Шаг 5. Разработка кода

**Агенты:** `php-developer`, `php-auto-fixer`, `phpstan-developer`, `phpcs-developer`

Пример команды оркестратору:

```text
/ra-php-implementation
Номер задачи: 1
Путь к сводному плану: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration/TaskSummary.md
```

На входе — номер задачи из сводного плана и путь к TaskSummary.md.
На выходе — реализованный код с пройденными проверками качества.

Это самый насыщенный этап. Последовательность:

1. `php-developer` — пишет код по плану
2. `php-developer` — самопроверка на соответствие плану
3. `php-auto-fixer` — автоматическое исправление (Rector + PHPCBF)
4. `phpstan-developer` — статический анализ типов и исправление ошибок
5. `phpcs-developer` — исправление code style

Каждый инструмент запускается отдельным агентом.

#### Шаг 6. Написание тестов

**Агенты:** `php-test-developer` + те же инструменты качества

Пример команды оркестратору:

```text
/ra-php-test-implementation
Номер задачи: 1
Путь к сводному плану: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration/TaskSummary.md
```

На входе — номер задачи из сводного плана и путь к TaskSummary.md.
На выходе — тесты с покрытием кода и успешным прохождением PHPUnit.

Это аналогичный процесс как для кода:

1. Написание тестов по плану
2. Самопроверка
3. Автофикс + статический анализ
4. Запуск PHPUnit для проверки

#### Шаги 7-8. Документация

**Агенты:** `tech-doc-writer`, `arch-doc-writer`

Пример команды оркестратору для `tech-doc-writer`:

```text
/ra-create-tech-doc
Путь к папке: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration
```

Пример команды оркестратору для `arch-doc-writer`:

```text
/ra-create-arch-doc
Путь к папке: Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration
```

Финальные этапы — создание человекочитаемой документации:

- **TechDoc** — описание функциональности для разработчиков
- **ArchDoc** — архитектурные диаграммы и описание взаимодействий

### Визуальная схема процесса

```mermaid
flowchart TD
    Start[Бизнес-идея] --> Decision{Крупная?}

    Decision -->|Да| Epic[0. Создать эпик]
    Decision -->|Нет| Feature[1. Создать фичу]

    Epic --> Feature
    Feature --> Summary[2. Сводный план]
    Summary --> DevPlan[3. План разработки]
    DevPlan --> TestPlan[4. План тестирования]
    TestPlan --> Code[5. Разработка кода]
    Code --> Tests[6. Написание тестов]
    Tests --> TechDoc[7. Техническая документация]
    TechDoc --> ArchDoc[8. Архитектурная документация]

    ArchDoc --> MoreTasks{Еще задачи?}
    MoreTasks -->|Да| DevPlan
    MoreTasks -->|Нет| MoreStages{Еще этапы?}

    MoreStages -->|Да| Feature
    MoreStages -->|Нет| Done[Готово!]

    style Start fill:#e1f5e1
    style Done fill:#e1f5e1
    style Epic fill:#fff3cd
    style Feature fill:#fff3cd
    style Code fill:#cfe2ff
    style Tests fill:#cfe2ff
```

### Технические детали

Для отладки этого подхода я использовал [Учебный проект по созданию генеалогического древа](https://github.com/vendelev/MyDrevo)

Вся конфигурация мультиагентной системы хранится в папке `.ai/`:

```text
.ai/
├── agents/              # Описание AI-агентов (промпты)
│   ├── Template/        # Шаблоны документов
│   │   ├── TaskSummary.md           # Шаблон сводного технического плана
│   │   ├── TaskX_TaskForDev.md      # Шаблон плана для разработчика
│   │   ├── TaskX_TaskForTest.md     # Шаблон плана для тестировщика
│   │   ├── component-template.yaml  # Шаблон компонента для DocHub
│   │   ├── context-template.yaml    # Шаблон контекста для DocHub
│   │   └── aspect-template.yaml     # Шаблон аспекта для DocHub
│   ├── epic-writer.md          # Product Owner: описание эпиков
│   ├── feature-writer.md       # Бизнес-аналитик: описание фич
│   ├── summary-plan-writer.md  # Системный аналитик + Архитектор: сводный план
│   ├── dev-plan-writer.md      # Системный аналитик + Техлид: план разработки
│   ├── test-plan-writer.md     # Системный аналитик + Техлид тестировщик: план тестирования
│   ├── php-developer.md        # PHP разработчик: написание кода
│   ├── php-test-developer.md   # Разработчик тестов: написание тестов
│   ├── tech-doc-writer.md      # Технический писатель: техническая документация
│   ├── arch-doc-writer.md      # IT архитектор: архитектурная документация
│   ├── php-auto-fixer.md       # Автоисправление кода (Rector + PHPCBF)
│   ├── phpstan-developer.md    # Исправление ошибок PHPStan
│   ├── phpcs-developer.md      # Исправление ошибок PHPCS
│   └── markdownlint.md         # Исправление ошибок Markdown
│
├── commands/            # Команды для оркестрации
│   ├── ra-create-epic.md              # Команда создания эпика (Шаг 0)
│   ├── ra-create-feature.md           # Команда создания фичи (Шаг 1)
│   ├── ra-create-summary-plan.md      # Команда создания сводного плана (Шаг 2)
│   ├── ra-create-dev-plan.md          # Команда создания плана разработки (Шаг 3)
│   ├── ra-create-test-plan.md         # Команда создания плана тестирования (Шаг 4)
│   ├── ra-php-implementation.md       # Команда разработки кода (Шаг 5)
│   ├── ra-php-test-implementation.md  # Команда написания тестов (Шаг 6)
│   ├── ra-create-tech-doc.md          # Команда создания техдокументации (Шаг 7)
│   ├── ra-create-arch-doc.md          # Команда создания арх.документации (Шаг 8)
│   ├── ra-php-auto-fixer.md           # Команда автоисправления кода
│   └── ra-phpcs-developer.md          # Команда исправления code style
│
├── rules/               # Правила разработки
│   ├── Architecture.md              # Clean Architecture, CQRS, модульный монолит
│   ├── ArchitecturalCompromises.md  # Осознанные компромиссы
│   ├── CodeHints.md                 # Рекомендации по работе с PHP
│   ├── CodeStyle.md                 # Принятый стиль кода
│   ├── TestingHints.md              # Рекомендации по написанию тестов
│   └── FeatureWorkflow.md           # Workflow добавления новых фич
│
├── CustomModes.yaml     # Конфигурация кастомных агентов для Roo Code
└── Readme.md            # Главный файл с инструкциями и обзором системы
```

#### 1. Агенты (`agents/`)

Каждый файл в этой папке содержит детальный промпт для специализированного AI-агента.
Промпт описывает роль агента, его функции, входные параметры, последовательность действий и критерии завершения работы.

#### 2. Команды (`commands/`)

Файлы с алгоритмами оркестрации процесса разработки. Каждая команда описывает:

- Последовательность запуска агентов
- Передачу артефактов между агентами
- Точки проверки качества
- Условия остановки при ошибках

Команды соответствуют шагам процесса разработки (0-8).

#### 3. Правила (`rules/`)

Централизованное хранилище всех правил и соглашений проекта:

- **Architecture.md** — архитектурные принципы, структура слоев, правила зависимостей
- **CodeHints.md** — особенности PHP 8.5, работа с типами, null safety
- **CodeStyle.md** — стандарты именования, форматирования, комментирования
- **TestingHints.md** — подходы к тестированию, моки, fixtures, структура тестов
- **FeatureWorkflow.md** — процесс добавления новой функциональности

Эти файлы используются агентами как источники знаний о проекте и гарантируют единообразие кода.

#### Подключение в Claude Code

Создавая папку ".ai" я старался абстрагироваться от конкретного инструмента, тк на вкус и цвет все фломастеры разные.  

На примере Claude Code покажу как ".ai" скрестить с любым инструментом.
Если кому-то интересно, то в учебном проекте настроена интеграция с KiloCode, RooCode, OpenCode и CodeAssistant.

##### 1. Пользователь вызывает команду

```text
/ra-create-epic
Номер эпика: TZ1
Описание: Создать веб-сайт для генеалогического древа
```

##### 2. Claude Code ищет skill

Claude находит файл [.claude/skills/ra-create-epic/SKILL.md](https://github.com/vendelev/MyDrevo/blob/master/.claude/skills/ra-create-epic/SKILL.md):

```markdown
---
name: ra-create-epic
description: Создание эпика — описание бизнес-требований и разбивка на этапы
model: haiku
allowed-tools: Task
---

Инструкции находятся в файле: @.ai/commands/ra-create-epic.md
```

##### 3. Claude читает алгоритм оркестрации

В файле [.ai/commands/ra-create-epic.md](https://github.com/vendelev/MyDrevo/blob/master/.ai/commands/ra-create-epic.md)
описана последовательность действий:

```markdown
### Шаг 1. Создание эпика

Вызови Task tool (switch_mode) для описания бизнес-требований:

- `subagent_type`: `epic-writer`
- `prompt`: "Входные данные: $ARGUMENTS. Верни список созданных файлов"

...
```

##### 4. Claude запускает первого агента

При вызове `Task tool` с `subagent_type: epic-writer` Claude:

- Читает конфигурацию [.claude/agents/epic-writer.md](https://github.com/vendelev/MyDrevo/blob/master/.claude/agents/epic-writer.md):

```markdown
---
name: epic-writer
description: Агент по описанию бизнес-требований и планированию этапов эпика
tools: Read, Write, Edit, Glob, Grep, Bash
model: sonnet
---

Инструкции находятся в файле: @.ai/agents/epic-writer.md
```

- Загружает детальные инструкции из [.ai/agents/epic-writer.md](https://github.com/vendelev/MyDrevo/blob/master/.ai/agents/epic-writer.md)


Основные преимущества такого подхода:

- это разделение ответственности: `.ai/` — бизнес-логика (инструкции и алгоритмы), а `.claude/` — конфигурация для Claude Code (метаданные).
- масштабируемость: легко добавить новую команду, skill или агента

## Грабли и выводы

### Контекст всё равно заканчивается

Агент начинает "забывать" инструкции к концу длинной сессии.
Даже при изоляции контекста, если план реализации слишком большой,
агент не удерживает в фокусе все детали.

Тут поможет создание более мелких этапов и задач или более дорогая модель.

### Циклы исправлений

Сколько раз агент уходил в цикл на PHPStan → исправление → новые ошибки → PHPStan → ...
Хорошо консоль работала на втором мониторе и я замечал это.

Тут надо более точно писать prompt: "Если после 2 циклов ошибки остаются — передать человеку" или "Повторяй перезапуск не более 2-х раз".

### Разные агенты — разный стиль

Как бы я не старался указать правила написания кода: Код от разных запусков агента выглядит по-разному.

Иногда, на этапе ревью помогала инструкция: Изучи существующий код в backend/src/Person/Domain/ и следуй тому же стилю.
А большей частью я просто принимал это как неизбежность, как нового разработчика в команде.
Ведь каждый человек пишет код по своему и со временем я даже могу угадать кто написал тот или иной кусок кода.

### Оверинжиниринг

Агент любит создавать абстракции "на будущее", которые не нужны сейчас.
Скорее всего где-то в спецификации закрались слова про "расширяемость" и "гибкость".

Поможет только одно: Review и еще раз Review.
Как вариант создать отдельного агента, который будет проверять на оверинжиниринг.

### Итого

Мультиагентная разработка — это не "AI пишет код за меня".
Это **автоматизация рутины** с сохранением контроля человека.

Человек по-прежнему:

- Формулирует требования
- Принимает архитектурные решения
- Проводит code review
- Исправляет сложные баги

Агенты берут на себя:

- Структурирование требований в документы
- Генерацию boilerplate кода
- Прогон линтеров и автоисправления
- Написание базовых тестов
- Создание документации

## PS

Если у вас есть опыт мультиагентной разработки или по настройке по настройке агентов пишите в комментариях.
Буду рад обсудить.
