# Мультиагентная разработка: от хотелок до продакшена

## Аннотация



## Вступление

AI плотно входит в нашу жизнь.
Еще год назад, по большей части, использовать AI в работе было затруднительно. Да — можно, но не удобно. <br>
Но к началу 2026 год инструменты работы с AI превратились в хорошего помощника. 
Так что хотим мы этого или нет, а надо учиться работать с новыми инструментами.

Так как я PHP-разработчик, то 90% своего рабочего времени провожу в PHPStorm и первый мой агент-плагин для работы с AI был [zencoder.ai](https://docs.zencoder.ai/features/integration). 

В дальнейшем я пробовал [RooCode](https://docs.roocode.com/), [KiloCode](https://kilo.ai/docs/getting-started), [SourceCraft Code Assistant](https://sourcecraft.dev/portal/code-assistant/). Все 3 плагина для VSCode — братья: настройки и функционала совпадают на 90%.

Потом настала очередь [Claude Code](https://code.claude.com/docs/ru/overview) и [OpenCode](https://opencode.ai/docs). 
Claude Code - основной инструмент, а OpenCode + [z.AI](https://docs.z.ai/devpack/overview) - на подхвате.

Так же пробовал [Cursor](https://cursor.com/docs) и [Antigravity](https://antigravity.google/docs/get-started) — не зашли, в первую очередь, из-за отсутствия агентов. <br>
*А вот к Курсор можно и опять попробовать вернуться - в январе 2026 вышло обновление: [Subagents, Skills, and Image Generation](https://cursor.com/changelog/2-4)

Есть еще [GitHub Copilot](https://code.visualstudio.com/docs/copilot/overview) - это у меня в планах попробовать,
так же в январе вышло серьезное обновление, в котором завезли агентов, субагентов и другой нечисти.

Однако, независимо от используемого инструмента, у большинства использующих AI для работы возникали, примерно, одинаковые проблемы:

### Проблема 1: AI пишет код настолько правильно, насколько широко и подробно была поставлена задача

Для её решения мировое сообщество выработало подход [Specification-Driven Development](https://github.com/github/spec-kit/blob/main/spec-driven.md) — **спецификация первична, а код вторичен**. 

Самые популярные инструменты для работы с этим подходом это:

- [Spec Kit](https://github.com/github/spec-kit):
  - Спецификации определяют "что", прежде чем код определит "как".
  - Много шаговое уточнение вместо генерации кода из одного промпта.
- [OpenSpec](https://github.com/Fission-AI/OpenSpec):
  - Разделение "источника истины" (`specs/`) и "предложений" (`changes/`).
  - Каждая фича — независимый мини-проект.

Об этих инструментах ранее уже писали:

- [GitHub SpecKit: вайб-кодинг на основе спецификаций](https://habr.com/ru/articles/964368/)
- [Spec Kit от GitHub: как превратить хаотичную работу с AI в структурированную разработку](https://fulcrumlabs.ru/blog/spec-kit-ot-github-kak-prevratit-haotichnuyu-rabotu-s-ai-v-strukturirovannuyu-razrabotku/)
- [Не болтайте ерундой](https://habr.com/ru/articles/983062/)

К сожалению, у меня не получилось встроить SDD в существующие бизнес процессы.
Не укладывается этот подход, когда в команде несколько человек и у каждого своя роль.

### Проблема 2: Размывается фокус или AI забывает часть контекста

Тут приходится искать баланс между длиной контекста, который накапливается как снежный ком при каждом запросе к AI и полнотой описания задачи. 
Те надо максимально детально поставить задачу AI, чтобы получить качественный результат, но при этом AI не должен забывать базовые правила и рекомендации. А это регулярно происходит, даже с крутыми моделями.

И нам на помощь приходит возможность создания кастомных агентов ([claude](https://code.claude.com/docs/ru/sub-agents), [opencode](https://opencode.ai/docs/agents/), [roocode](https://docs.roocode.com/features/custom-modes), [copilot](https://code.visualstudio.com/docs/copilot/agents/subagents), [cursor](https://cursor.com/docs/context/subagents)) и возможность запускать агентов в новом контексте - оркестрировать.

Ключевой принцип: **один агент — одна ответственность**.

Это позволяет:

- Держать промпты компактными — меньше инструкций, меньше ошибок, меньше размытия фокуса.
- Легко отлаживать — понятно, какой агент накосячил.
- Переиспользовать — например, агент `phpstan-developer` работает и после `php-developer`, и после `php-test-developer`.

Второй принцип: **изоляции контекста**.

Каждый агент запускается в чистом контексте. Он не знает, что делали другие агенты — только умеет читать артефакты 
(файлы), которые они создали.

Это даёт несколько преимуществ:

- **Независимость** — агент знает только то что надо для работы, а не весь "снежный ком" взаимодействия с AI.
- **Воспроизводимость** — можно перезапустить любой этап с теми же входными данными.
- **Контроль качества** - выявить и устранить ошибки можно на более ранних этапах, те меньше придется переделывать.

### Проблема 3: Качество кода часто оставляет желать лучшего. Те код работает корректно, но вот поддерживать его в будущем — сложно

Эту проблему можно решить не только обучением AI стандартам принятым в команде, 
но и внедрением автоматических проверок с помощью статических анализаторов кода. <br>
Это позволяет подсказать AI, где и что надо исправить без привлечения человека.

### Проблема 4: Не ты владелец кода. И как следствие, не знаешь, как он работает

Как бы дотошно ты ни проводил code review, код остается чужим.
Часто свой код через полгода забываешь, а тут только "рядом стоял". <br>
К сожалению, на момент написания статьи, решения я не нашел.

А ведь так хочется просто написать: "Сделай всё хорошо" :).

## Свой велосипед

На тему субагентов выпущено много материалов, вот некоторые, на мой взгляд, самые информативные:

- [Skills, Sub-agents и Hooks. Как делать Code Review с помощью AI](https://www.youtube.com/watch?v=guSs80sefNo)
- [Мультиагентная разработка в Cursor: как заставить субагентов работать на большие проекты](https://habr.com/ru/articles/971620/)
- [LLM — не один большой «мозг», а команда ролей. Как собрать AI-workflow в Claude Code и уйти от вайб-коддинга](https://habr.com/ru/articles/974924/)
- [Изоляция контекста через субагенты: архитектурный паттерн для долгосрочной работы с Claude Code](https://habr.com/ru/articles/974448/)

Авторы предлагают создавать агентов по навыкам.
И это правильно - чем более узкую специализацию имеет агент, тем лучше он работает.
Сложность, в этом случае, лишь в том, как организовать управляемый процесс передачи артефактов от одного агента к другому.
Тут можно вспомнить про "Specification-Driven Development" - ведь там всё четко структурировано.
Но вопрос: как это интегрировать в существующие бизнес процессы, остается открытым.

И я решил подойти к этому с другой стороны: а что, если "организовать" агентов как обычных сотрудников.<br>
Вернее выстроить полноценный процесс разработки — как в настоящей команде, только с AI-агентами вместо людей.

Ниже я поделюсь своим видением специализированных AI-агентов и организации работы с ними.

### Немного терминов

**Бизнес-потребность** — это цель или идея, для выполнения которой нужно выполнить определённые действия.
Бизнес описывает свою **Боль** или почему это надо сделать.<br>
Например: «Операторы тратят 4 часа в день на ручной перенос данных из Excel в CRM».

**Бизнес-требования** — это высокоуровневые цели, которые бизнес стремится достичь.
Product Owner описывает **Цель** или что надо сделать.<br>
Например: «Автоматизировать синхронизацию данных, чтобы сократить ручной труд до 10 минут в день».

**Функциональные требования** - конкретные действия, которые программа должна выполнять.
Бизнес-аналитик формирует **Решение** или как надо сделать.<br>
Например: «Система должна иметь кнопку "Импорт", принимающую файлы .csv и валидирующую поля А и Б».

**Epic (эпик)** — это крупная пользовательская история.
Описывает значимую функциональность или бизнес-цель, достижение которой приносит ценность продукту.

**Feature (фича)** — это законченная единица функциональности программного продукта, которая приносит измеримую
пользу конечному пользователю или бизнесу.

**Task (задача)** — это конкретная единица работы с чётко определённым результатом, которую можно выполнить за
ограниченное время.

### Вариант структуры хранения артефактов

Артефакты хранятся в `Doc/`:

```markdown
Doc/
├── Backlog/                       # Эпики
│   └── 2026/
│       └── TZ1_Genealogy-Tree-Website/
│           ├── EpicSummary.md     # Описание эпика
│           ├── Stage1.md          # Описание этапа 1
│           └── Stage2.md          # Описание этапа 2
│
└── FeatureList/                   # Фичи
    └── 2026/
        └── 01/
            └── TZ1_01_Database-Schema-Migration/
                ├── Spec.md        # Спецификация
                ├── TaskSummary.md # Сводный план
                └── TaskList/      # Задачи
                    ├── Task1_TaskForDev.md
                    └── Task1_TaskForTest.md
```

### Пример бизнес процесса по разработке программного обеспечения

1. Заказчик рассказывает о своих хотелках (бизнес-потребности).
2. Владелец продукта формализует полученную информацию в бизнес-требования и предлагает поэтапное выполнение.
3. Бизнес аналитик на основе бизнес-требований прорабатывает как будут реализованы предлагаемые фичи.
4. Системный аналитик совместно с IT архитектором составляют общий план разработки фичи.
5. Системный аналитик и техлид формируют список задач командам разработки и тестирования.
6. Разработка программного обеспечения.
7. Тестирование программного обеспечения.
8. Составление технической документации по разработанному функционалу.
9. Обновление документации по архитектуре всей информационной системы.
10. Сдача/приема разработанного функционала заказчику.
11. Сборка ПО для продакшена.
12. Деплой.

И всеми этими процессами управляет проджект-менеджер.

То есть, фактически, каждый пункт из этого списка это отдельная роль, которую можно оформить как prompt для AI.
А в некоторых случая, над решением работают 2 роли одновременно.

### Product Owner

**Product Owner** или «владелец продукта» — это специалист, который представляет интересы бизнеса и пользователей,
отвечая за видение продукта, его ценность и развитие.

**Функция:** [Описание бизнес потребностей и планирование этапов эпика](/.ai/agents/epic-writer.md)
<cat>

### Бизнес аналитик

**Бизнес-аналитик** — это специалист, который занимается анализом бизнес-процессов и требований, предлагает решения,
помогая переводить бизнес-идеи в технические решения.

**Функция**: Описание бизнес-требований

```cat
# Описание функциональных требований

## Твоя роль

Веди себя как **Ведущий бизнес аналитик**.
Бизнес-аналитик — это специалист, который занимается анализом бизнес-процессов и требований.
Он выступает связующим звеном между бизнесом и IT-командами, помогая переводить бизнес-идеи в технические решения.

## Входные параметры (Пользовательский ввод)

Пользователь указывает номер задачи и формулирует бизнес-потребности по созданию нового функционала или изменению
 существующего.

## Что надо сделать

1. Изучить информацию о проекте в [AGENTS.md](../../AGENTS.md) для понимания контекста и бизнес-целей.

2. Создать папку "/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}", где:
   {YYYY} - текущий год
   {MM} - текущий месяц
   {FEATURE_FOLDER} формируется по следующему правилу: "Номер-Задачи_Краткое-Описание-Требований-На-Английском-Языке".
   - Пример: Для задачи MIS-123 "Добавить регистрацию пользователей" → "MIS-123_Add-User-Registration".

3. Создать новый файл (/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}/Spec.md) с детальным описанием бизнес-требований
   (что именно меняется или создается).
   Задавай уточняющие вопросы по мере необходимости.
   Этот файл будет использоваться на следующем этапе другим AI-агентом для создания технического плана по разработке
   программного кода.

   ### Структура Spec.md
  
   Спецификация должна покрывать все сценарии использования и быть понятной нетехническому пользователю.
  
   Файл Spec.md должен содержать следующие разделы:
  
   - **Описание проблемы/потребности**: Что решает новая функциональность или изменение.
   - **Функциональные требования**: Что система должна делать (список требований).
   - **Нефункциональные требования**: Производительность, безопасность, usability и т.д.
   - **Модель предметной области**: Основные Entity, ValueObject и их взаимосвязи.
   - **Зависимости**: Как новый функционал будет взаимодействовать с другими модулями.
   - **Сценарии использования**: User stories, примеры взаимодействия или примеры бизнес-процессов
     (например, синхронизация тикетов из Freshdesk, получение списка тикетов для отчета).
   - **Риски**: Что может повлиять на реализацию.
   - **Критерии приемки**: Как проверить выполнение требований.
   - **Не входит в реализацию**: Что не будет реализовано в рамках текущей задачи.

4. Проверить Spec.md на соответствие чек-листу:
   - Все требования четко сформулированы?
   - Покрыты ли edge-кейсы?
   - Соответствует ли бизнес-целям проекта?

## Критерии завершения этапа

- Создана папка "/Doc/FeatureList/{YYYY}/{MM}/{FEATURE_FOLDER}" с правильным именованием
- Создан файл Spec.md с полным описанием бизнес-требований (функциональных изменений)
- Спецификация включает все обязательные разделы, перечисленные в структуре выше
- Описание проблемы/потребности ясно и понятно
- Функциональные требования сформулированы четко и однозначно
- Учтены нефункциональные требования (производительность, безопасность, usability и т.д.)
- Модель предметной области описана корректно с указанием основных Entity и ValueObject
- Указаны зависимости от других модулей
- Приведены сценарии использования (User stories, примеры взаимодействия или бизнес-процессов)
- Определены возможные риски реализации
- Указаны критерии приемки для проверки выполнения требований
- Четко обозначено, что не входит в реализацию текущей задачи
- Спецификация проходит проверку по всем пунктам чек-листа (строки 41-44)
- Спецификация понятна нетехническому пользователю
- Все требования сформулированы четко без двусмысленности
- Учтены edge-кейсы

## Ревью пользователем бизнес-требований

Если ревю прошло → перейти к коммиту. Если нет → уточнить требования и пересоздать Spec.md.

## Коммит изменений в git

Комментарий должен быть на русском языке
```

### Системный аналитик + IT архитектор

**Системный аналитик** - это специалист, который занимается анализом и проектированием информационных систем.
Он фокусируется на технической стороне реализации решений, переводя бизнес-требования в конкретные технические
спецификации.

**IT архитектор** — это высококвалифицированный специалист, который проектирует техническую архитектуру системы
(из каких компонентов она состоит и как они взаимодействуют) и отвечает за то,
чтобы решение можно было надежно реализовать и развивать.

**Функция:** [Формирование сводного технического плана](/.ai/agents/summary-plan-writer.md)
<cat>

### Системный аналитик + PHP Техлид

**Технический лидер** или «техлид» — это наиболее компетентный инженер в команде, который отвечает за качество
технической реализации проекта.

**Функция:** [Формирование технического плана по разработке кода](/.ai/agents/dev-plan-writer.md)
<cat>

### Системный аналитик + Техлид тестировщик

**Функция:** [Формирование технического плана по написанию тестов](/.ai/agents/test-plan-writer.md)
<cat>

### PHP разработчик

**Функция:** [Разработка программного кода](/.ai/agents/php-developer.md)
<cat>

### Разработчик тестов

**Функция:** [Разработка тестов](/.ai/agents/php-test-developer.md)
<cat>

### Технический писатель

**Технический писатель** — это специалист, который собирает информацию о продукте/системе и превращает её в понятную,
точную и структурированную документацию.

**Функция:** [Создание технической документации](/.ai/agents/tech-doc-writer.md)
<cat>

### IT архитектор

**Функция:** [Создание архитектурной документации](/.ai/agents/arch-doc-writer.md)
<cat>

### Project Manager или Оркестратор

Оркестратор — это не просто еще один агент. Это **точка входа** для человека и **координатор** всей команды агентов.

**Функции:**

1. **Принимает задачу** от человека
2. **Декомпозирует** её на подзадачи для специализированных агентов
3. **Запускает агентов** в правильной последовательности
4. **Передаёт контекст** — указывает агенту, какие файлы читать
5. **Обрабатывает результаты** — анализирует, что агент вернул
6. **Управляет циклами** — если нужна доработка, запускает агента повторно
7. **Останавливается** при блокирующих вопросах и спрашивает человека

Человек остаётся в роли **супервизора**: запускает оркестратора, проводит ревью и принимает решения в неоднозначных 
ситуациях.

#### Паттерн работы с оркестратором

1. Создаём новый контекст
2. Даём команду с указанием агента и входных данных
3. Оркестратор запускает агента, получает результат
4. Запускает второго агента для перепроверки и исправления
5. Проводим ревью, делаем коммит

### Pipeline процесса разработки ПО

Весь процесс разбит на несколько последовательных шагов.

```plantuml
@startuml

skinparam backgroundColor #FEFEFE
skinparam activityBackgroundColor #F5F5F5
skinparam activityBorderColor #333333

|Планирование|
start
:Шаг 0. **Создание эпика**
Product Owner описывает бизнес-требования
и разбивает работу на этапы;

:Шаг 1. **Спецификация**
Бизнес-аналитик создаёт описание
функциональных требований для каждого этапа;

|Проектирование|
:Шаг 2. **Сводный план**
Архитектор формирует общий
технический план реализации;

:Шаг 3. **План разработки**
Детальный план по написанию кода
для каждого подэтапа;

:Шаг 4. **План тестирования**
Детальный план по написанию тестов
для каждого подэтапа;

|Реализация|
:Шаг 5. **Разработка кода**
PHP-разработчик пишет код
по плану + автофикс + PHPStan;

:Шаг 6. **Написание тестов**
Тестировщик покрывает код
unit/integration/e2e тестами;

|Документирование|
:Шаг 7. **Техническая документация**
Технический писатель описывает
реализованную функциональность;

:Шаг 8. **Архитектурная документация**
IT-архитектор документирует
взаимодействие и зависимости;

stop

@enduml
```

#### Шаг 0. Описание бизнес требований и планирование этапов эпика

**Агент:** `epic-writer` (Product Owner)

cat <промт>

На входе — описание бизнес-потребности от человека.
На выходе — структурированный эпик с разбивкой на этапы реализации, путь к EpicSummary.md.

Пример команды оркестратору:

```text
Используй агента в режиме "create-epic" для описания бизнес-потребностей.
Номер эпика: TZ1.
Описание: Создать MVP генеалогического древа с возможностью добавления и редактирования персон, отображения связей.
```

#### Шаг 1. Описание функциональных требований для каждого этапа

**Агент:** `feature-writer` (Бизнес-аналитик)

cat <промт>

Для каждого этапа из эпика создаётся отдельная спецификация `Spec.md` со структурой:

- Описание проблемы/потребности
- Функциональные требования
- Нефункциональные требования
- Модель предметной области (Entity, ValueObject)
- Зависимости от других модулей
- Сценарии использования
- Риски
- Критерии приёмки
- Что НЕ входит в реализацию

#### Шаг 2. Формирование сводного технического плана

**Агент:** `summary-plan-writer` (Системный аналитик + Архитектор)

cat <промт>

На основе спецификации по каждому этапу формируется `Task.md` — общий план с разбивкой на задачи.
Рекомендую план создавать **непосредственно перед реализацией**, а не заранее.
Иначе есть шанс, что после реализации предыдущего этапа план устареет.

Так как технический план разбивается на задачи, то Шаги 3-8 повторяются для каждого задачи.

#### Шаги 3-4. Детальные планы

**Агенты:** `dev-plan-writer`, `test-plan-writer`

cat <промт>
cat <промт>

Для каждой задачи создаются отдельные файлы:

- `TaskX_TaskForDev.md` — что именно кодить, какие классы создавать
- `TaskX_TaskForTest.md` — какие тесты писать, какие кейсы покрывать

На этих этапах очень помогла [универсальная структура PHP-проекта](https://habr.com/ru/articles/905008/).<br>
Когда проект имеет:

- **Модульную структуру** — агент понимает границы задачи ("работай только в модуле Person")
- **Слои с чёткими зависимостями** — агент знает, какие классы где создавать
- **Единые правила именования** — агент генерирует консистентный код
- **Статические анализаторы** — PHPStan ловит ошибки типов, которые агент пропустил
- **Проверку стиля кода** — PHPCS и Rector автоматически исправляют форматирование
- **Архитектурные тесты** — автоматическая проверка, что агент не нарушил правила организации модуля

В итоге, оказалось, что чёткая архитектура проекта — это не только "чистый код для людей".
Это ещё и **фундамент для работы AI-агентов**.

#### Шаг 5. Разработка кода

**Агенты:** `php-developer`, `php-auto-fixer`, `phpstan-developer`, `phpcs-developer`

cat <промт>

Самый насыщенный этап. Последовательность:

1. `php-developer` — пишет код по плану
2. `php-developer` — самопроверка на соответствие плану
3. `php-auto-fixer` — автоматическое исправление (Rector + PHPCBF)
4. `phpstan-developer` — статический анализ типов и исправление ошибок
5. `phpcs-developer` — исправление code style

Каждый инструмент запускается отдельным агентом.

#### Шаг 6. Написание тестов

**Агенты:** `php-test-developer` + те же инструменты качества

cat <промт>

Аналогичный процесс для тестов:

1. Написание тестов по плану
2. Самопроверка
3. Автофикс + статический анализ
4. Запуск PHPUnit для проверки

#### Шаги 7-8. Документация

**Агенты:** `tech-doc-writer`, `arch-doc-writer`

cat <промт>
cat <промт>

Финальные этапы — создание человекочитаемой документации:

- **TechDoc** — описание функциональности для разработчиков
- **ArchDoc** — архитектурные диаграммы и описание взаимодействий


### Визуальная схема процесса

```mermaid
flowchart TD
    Start[Бизнес-идея] --> Decision{Крупная?}

    Decision -->|Да| Epic[0. Создать эпик]
    Decision -->|Нет| Feature[1. Создать фичу]

    Epic --> Feature
    Feature --> Summary[2. Сводный план]
    Summary --> DevPlan[3. План разработки]
    DevPlan --> TestPlan[4. План тестирования]
    TestPlan --> Code[5. Разработка кода]
    Code --> Tests[6. Написание тестов]
    Tests --> TechDoc[7. Техническая документация]
    TechDoc --> ArchDoc[8. Архитектурная документация]

    ArchDoc --> MoreTasks{Еще задачи?}
    MoreTasks -->|Да| DevPlan
    MoreTasks -->|Нет| MoreStages{Еще этапы?}

    MoreStages -->|Да| Feature
    MoreStages -->|Нет| Done[Готово!]

    style Start fill:#e1f5e1
    style Done fill:#e1f5e1
    style Epic fill:#fff3cd
    style Feature fill:#fff3cd
    style Code fill:#cfe2ff
    style Tests fill:#cfe2ff
```

## Пример workflow: от идеи до кода

### Исходная задача

Создать веб-сайт семейного генеалогического древа.

### Шаг 0. Создание эпика

**Команда оркестратору:**

```markdown
/ra-....
Номер эпика: TZ1.
Описание: Создать веб-сайт для ведения семейного генеалогического древа.
Есть заготовка структуры БД в backend/database/migrations/structure.sql.
```

**Результат:** файл `Doc/Backlog/2026/TZ1_Genealogy-Tree-Website/EpicSummary.md`

Агент создал эпик с разбивкой на 7 этапов:

1. Миграция схемы БД MySQL → SQLite
2. Адаптация доменной модели
3. Просмотр дерева (MVP)
4. Управление персонами
5. Управление связями
6. Визуализация дерева
7. Безопасность и права доступа

### Шаг 1. Создание спецификации

**Команда оркестратору:**

```markdown
/ra-....
Номер задачи: TZ1_01.
Описание эпика в файле @/Doc/Backlog/2026/TZ1_Genealogy-Tree-Website/EpicSummary.md.
Создай спецификацию для этапа 1.
```

**Результат:** файл `Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration-MySQL-to-SQLite/Spec.md`

### Шаг 2. Сводный технический план

**Команда оркестратору:**

```markdown
/ra-....
Спецификация: @/Doc/FeatureList/2026/01/TZ1_01_Database-Schema-Migration-MySQL-to-SQLite/Spec.md
Создай сводный план по разработке кода и тестов.
```

**Результат:** файл `TaskSummary.md` с разбивкой на 6 задач:

| Задача | Что делаем |
|---------|------------|
| 1 | Создание структуры файлов и заглушек |
| 2 | Реализация Laravel-миграций |
| 3 | Команда экспорта данных из MySQL |
| 4 | Команда импорта данных в SQLite |
| 5 | Команда проверки целостности |
| 6 | API эндпоинт и документация |

### Шаги 3-4. Детальные планы

**Команда оркестратору:**

```markdown
/ra-....
```

```markdown
/ra-....
```

**Результат**:

- **`Stage1_TaskForDev.md`** — что кодить.
- **`Stage1_TaskForTest.md`** — какие тесты писать

### Шаг 5. Разработка кода

**Команда оркестратору:**

```markdown
/ra-....
```


### Шаг 6. Написание тестов

**Команда оркестратору:**

```markdown
/ra-....
```

@todo: дополнить шагами 7 и 8

## Технические детали

### Структура проекта

Вся конфигурация мультиагентной системы хранится в папке `.ai/`:
.......

Например, для работы с Claude Code агенты настраиваются через
....

## Грабли и выводы

### Контекст всё равно заканчивается

Агент начинает "забывать" инструкции к концу длинной сессии.
Даже при изоляции контекста, если план реализации слишком большой,
агент не удерживает в фокусе все детали.

Тут поможет создание более мелких этапов и задач или более дорогая модель.

### Циклы исправлений

Сколько раз агент уходил в цикл на PHPStan → исправление → новые ошибки → PHPStan → ...
Хорошо консоль работала на втором мониторе и я замечал это.

Тут надо более точно писать prompt: "Если после 2 циклов ошибки остаются — передать человеку" или "Повторяй перезапуск не более 2-х раз".

### Разные агенты — разный стиль

Как бы я не старался указать правила написания кода: Код от разных запусков агента выглядит по-разному.

Иногда, на этапе ревью помогала инструкция: Изучи существующий код в backend/src/Person/Domain/ и следуй тому же стилю.
А большей частью я просто принимал это как неизбежность, как нового разработчика в команде.
Ведь каждый человек пишет код по своему и со временем я даже могу угадать кто написал тот или иной кусок кода.

### Оверинжиниринг

Агент любит создавать абстракции "на будущее", которые не нужны сейчас.
Скорее всего где-то в спецификации закрались слова про "расширяемость" и "гибкость".

Поможет только одно: Review и еще раз Review.
Как вариант создать отдельного агента, который будет проверять на оверинжиниринг.

### Итого

Мультиагентная разработка — это не "AI пишет код за меня".
Это **автоматизация рутины** с сохранением контроля человека.

Человек по-прежнему:

- Формулирует требования
- Принимает архитектурные решения
- Проводит code review
- Исправляет сложные баги

Агенты берут на себя:

- Структурирование требований в документы
- Генерацию boilerplate кода
- Прогон линтеров и автоисправления
- Написание базовых тестов
- Создание документации

## Что дальше

Я продолжаю развивать свою мультиагентную систему с каждым новым эпиком, фичей или задачей и 
в планах настроить агентов для:

- Сборки образов с кодом в Gitlab
- Деплоя релизов на продакшен

## PS

Если у вас есть опыт мультиагентной разработки или по настройке по настройке агентов пишите в комментариях.
Буду рад обсудить.
