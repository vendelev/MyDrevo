# Stage 2 — Адаптация доменной модели к существующей схеме и создание репозиториев

## 1. Название этапа и его краткое описание

**Этап 2:** создать доменную модель (entities, value objects) и репозитории для работы с существующей схемой БД, учитывая многоязычность и гендерные формы.

Результат этапа: код приложения работает с доменными понятиями (Person, Name, Surname, Relation), а не напрямую с таблицами БД. Все сложности многоязычной модели скрыты в репозиториях.

## 2. Цель этапа

- Создать доменные сущности (entities) для работы с семейным древом: Person, Name, Surname, Relation, User.
- Создать value objects для гендерных форм: GenderedName, GenderedSurname.
- Создать репозитории для чтения/записи данных с учетом существующей схемы БД.
- Обеспечить поддержку многоязычности: имена и фамилии должны корректно извлекаться на нужном языке.
- Обеспечить поддержку гендерных форм: система должна выбирать правильную форму имени/фамилии в зависимости от пола персоны.
- Подготовить основу для реализации use cases (просмотр, создание, редактирование персон).

## 3. Функциональные требования

### 3.1. Доменные сущности (Entities)

Система должна иметь следующие доменные сущности:

#### Person (Персона)

- Поля:
  - `id: int` — уникальный идентификатор персоны
  - `userId: int` — владелец персоны (для разграничения доступа)
  - `firstName: Name` — имя персоны (многоязычное)
  - `middleName: ?Name` — отчество персоны (опционально, многоязычное)
  - `surname: ?Surname` — текущая фамилия (опционально, многоязычная)
  - `birthSurname: ?Surname` — девичья фамилия (опционально, многоязычная)
  - `birthDate: ?DateTime` — дата рождения
  - `deathDate: ?DateTime` — дата смерти
  - `info: array<string, string>` — дополнительная информация по языкам (ключ — код языка, значение — текст)
  - `gender: Gender` — пол персоны (для выбора гендерных форм)

#### Name (Имя/Отчество)

- Поля:
  - `id: int` — уникальный идентификатор имени
  - `userId: int` — владелец имени
  - `translations: array<NameTranslation>` — переводы имени на разные языки

#### NameTranslation (Перевод имени на язык)

- Поля:
  - `language: string` — код языка (ru, en и т.д.)
  - `name: string` — само имя
  - `malePatronymic: ?string` — отчество для сына (Иванович)
  - `femalePatronymic: ?string` — отчество для дочери (Ивановна)

#### Surname (Фамилия)

- Поля:
  - `id: int` — уникальный идентификатор фамилии
  - `userId: int` — владелец фамилии
  - `translations: array<SurnameTranslation>` — переводы фамилии на разные языки

#### SurnameTranslation (Перевод фамилии на язык)

- Поля:
  - `language: string` — код языка
  - `maleSurname: string` — мужская форма фамилии (Петров)
  - `femaleSurname: string` — женская форма фамилии (Петрова)

#### Relation (Связь между персонами)

- Поля:
  - `personId1: int` — первая персона
  - `personId2: int` — вторая персона
  - `type: RelationType` — тип связи

#### RelationType (Тип связи)

- Enum values: `PARENT_CHILD`, `SPOUSE`
- Для хранения в БД используется таблица `gen_relation_type`

#### User (Пользователь-владелец дерева)

- Поля:
  - `id: int` — уникальный идентификатор
  - `login: string` — логин
  - `email: string` — email
  - `firstName: string` — имя пользователя
  - `middleName: string` — отчество пользователя
  - `surname: string` — фамилия пользователя

### 3.2. Value Objects

#### Gender (Пол)

- Enum values: `MALE`, `FEMALE`, `UNKNOWN`
- Используется для выбора правильной гендерной формы имени/фамилии

### 3.3. Репозитории

Система должна иметь следующие репозитории:

#### PersonRepository

- Методы:
  - `findById(int $id, string $language): ?Person` — найти персону по ID с именами/фамилиями на нужном языке
  - `findByUserId(int $userId, string $language): array<Person>` — все персоны пользователя
  - `save(Person $person): void` — сохранить персону (создать или обновить)
  - `delete(int $id): void` — удалить персону

#### NameRepository

- Методы:
  - `findById(int $id): ?Name` — найти имя по ID со всеми переводами
  - `findByUserId(int $userId): array<Name>` — все имена пользователя
  - `findByName(string $name, string $language, int $userId): ?Name` — найти имя по тексту
  - `save(Name $name): void` — сохранить имя
  - `delete(int $id): void` — удалить имя

#### SurnameRepository

- Методы:
  - `findById(int $id): ?Surname` — найти фамилию по ID со всеми переводами
  - `findByUserId(int $userId): array<Surname>` — все фамилии пользователя
  - `findBySurname(string $surname, string $language, int $userId): ?Surname` — найти фамилию по тексту
  - `save(Surname $surname): void` — сохранить фамилию
  - `delete(int $id): void` — удалить фамилию

#### RelationRepository

- Методы:
  - `findByPersonId(int $personId): array<Relation>` — все связи персоны
  - `findByUserId(int $userId): array<Relation>` — все связи в дереве пользователя
  - `save(Relation $relation): void` — сохранить связь
  - `delete(int $personId1, int $personId2, RelationType $type): void` — удалить связь

#### UserRepository

- Методы:
  - `findById(int $id): ?User` — найти пользователя по ID
  - `findByLogin(string $login): ?User` — найти пользователя по логину
  - `save(User $user): void` — сохранить пользователя

### 3.4. Маппинг доменной модели на схему БД

Репозитории должны корректно работать с существующей многоязычной схемой:

#### Чтение персоны (PersonRepository::findById)

1. Прочитать запись из `gen_person`
2. Для каждого ID (FNAME_ID, SNAME_ID, SURNAME_ID, BSURNAME_ID):
   - Прочитать основную запись из `gen_name` / `gen_surname`
   - Прочитать связь из `gen_mixed_name_lang` / `gen_mixed_surname_lang`
   - Прочитать языковую запись из `gen_name_lang` / `gen_surname_lang`
   - Создать доменный объект Name / Surname с переводами
3. Прочитать информацию о персоне из `gen_person_info_lang` для нужного языка
4. Создать доменный объект Person

#### Сохранение персоны (PersonRepository::save)

1. Если Name/Surname новые:
   - Создать запись в `gen_name` / `gen_surname` с USER_ID
   - Для каждого языка создать запись в `gen_name_lang` / `gen_surname_lang`
   - Создать связи в `gen_mixed_name_lang` / `gen_mixed_surname_lang`
2. Сохранить/обновить запись в `gen_person` с ссылками на Name/Surname
3. Сохранить информацию в `gen_person_info_lang` для каждого языка

## 4. Нефункциональные требования

- **Производительность:** Чтение персоны с именами/фамилиями должно выполняться за разумное время (N+1 проблема должна быть решена через eager loading).
- **Изоляция:** Бизнес-логика не должна знать о сложностях многоязычной схемы БД.
- **Тестируемость:** Репозитории должны иметь интерфейсы для возможности мокирования в тестах.
- **Типобезопасность:** Использовать строгую типизацию PHP 8.5 (typed properties, return types).
- **Архитектура:** Следовать Clean Architecture (entities в Core, repositories в Infrastructure).

## 5. Сценарии использования

### 5.1. Разработчик создает use case для просмотра персоны

1. В use case получает PersonRepository через dependency injection.
2. Вызывает `$person = $repository->findById($id, 'ru')`.
3. Получает объект Person с именами/фамилиями на русском языке.
4. Работает с доменной моделью, не думая о БД.

### 5.2. Разработчик добавляет новую персону

1. Создает объекты Name и Surname с переводами на русский и английский.
2. Создает объект Person с ссылками на Name/Surname.
3. Вызывает `$repository->save($person)`.
4. Репозиторий сохраняет все данные в правильные таблицы БД.

### 5.3. Система отображает имя персоны с правильной гендерной формой

1. У персоны есть имя "Иван" (переводы: ru="Иван", en="John").
2. У персоны мужской пол (Gender::MALE).
3. Система запрашивает имя на русском языке: получает "Иван".
4. Система запрашивает отчество для потомка: получает "Иванович" (male) или "Ивановна" (female).

## 6. Критерии приемки

### 6.1. Доменные сущности

- ✅ Созданы классы entities: Person, Name, Surname, Relation, User.
- ✅ Созданы классы value objects: NameTranslation, SurnameTranslation, Gender, RelationType.
- ✅ Все классы используют строгую типизацию PHP 8.5.
- ✅ Entities находятся в модуле Core (не зависят от фреймворка).

### 6.2. Репозитории

- ✅ Созданы интерфейсы репозиториев в Core.
- ✅ Созданы реализации репозиториев в Infrastructure с использованием Eloquent/Query Builder.
- ✅ Репозитории корректно маппят доменные объекты на многоязычную схему БД.
- ✅ Репозитории поддерживают выбор языка при чтении данных.

### 6.3. Функциональность

- ✅ Можно создать персону с многоязычными именами/фамилиями через PersonRepository.
- ✅ Можно прочитать персону и получить имена/фамилии на нужном языке.
- ✅ Гендерные формы отчеств и фамилий выбираются корректно в зависимости от пола персоны.
- ✅ Девичья фамилия (birthSurname) корректно сохраняется и читается.

### 6.4. Тесты

- ✅ Написаны unit-тесты для entities и value objects.
- ✅ Написаны integration-тесты для репозиториев (работа с реальной БД).
- ✅ Тесты проверяют корректность маппинга многоязычных данных.
- ✅ Тесты проверяют выбор гендерных форм.

### 6.5. Документация

- ✅ Обновлена документация `Doc/Database/Schema.md` с описанием доменной модели.
- ✅ Добавлены примеры использования репозиториев.
- ✅ Документированы правила маппинга доменных объектов на таблицы БД.

## 7. Зависимости

- Этап 1: готовая схема БД с мигрированными данными.

## 8. Риски этапа

- **Сложность маппинга:** Многоязычная схема с промежуточными таблицами требует аккуратного маппинга.
- **Производительность N+1:** При чтении персон нужно использовать eager loading, иначе будет много запросов.
- **Неполнота данных:** Если в БД не все языковые варианты заполнены, нужен fallback на дефолтный язык.

## 9. Оценка трудозатрат

- **Оценка:** 4–6 дней.
- **Основные факторы:**
  - Создание всех доменных сущностей и value objects
  - Реализация репозиториев с поддержкой многоязычности
  - Реализация маппинга через промежуточные таблицы (gen_mixed_name_lang, gen_mixed_surname_lang)
  - Написание unit и integration тестов
  - Оптимизация производительности (eager loading)
