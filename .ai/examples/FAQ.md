# FAQ: Часто задаваемые вопросы

## Общие вопросы

### Когда создавать эпик, а когда сразу фичу?

**Создавайте эпик**, если:

- Задача требует разбивки на 3+ этапа
- Нужна поэтапная демонстрация стейкхолдерам
- Функционал можно реализовать частями

**Создавайте фичу напрямую**, если:

- Задача небольшая (1-2 этапа)
- Можно реализовать атомарно
- Не требуется промежуточная демонстрация

**Пример эпика**: "Система уведомлений" → 3 этапа (email, push, SMS)

**Пример фичи**: "Добавить кнопку экспорта в PDF"

---

### Почему технический план надо создавать непосредственно перед разработкой?

**Проблема "планов на будущее"**:

После реализации текущего этапа часто выясняется:

- Архитектурные решения нужно скорректировать
- Появились новые зависимости
- Изменились требования

**Результат**: План приходится переписывать → потеря времени

**Решение**: Создавайте технический план только когда готовы начать разработку.

---

### Что делать, если агент задает слишком много вопросов?

**Причина**: Недостаточно контекста в исходном запросе.

**Решение**:

1. Предоставьте более детальное описание сразу:
   - Что именно нужно сделать
   - Почему это нужно
   - Какие есть ограничения
2. Укажите ссылки на связанные документы
3. Приведите примеры, если возможно

**Плохо**: "Добавь авторизацию"

**Хорошо**: "Добавь авторизацию через JWT токены для API. Пользователи должны логиниться через email/password.
Токен действует 24 часа. Используй библиотеку tymon/jwt-auth."

---

## Workflow вопросы

### Что делать, если задача слишком большая?

**Признаки "слишком большой задачи"**:

- План разработки превышает 1000 строк
- Реализация займет > 4 часов
- Затрагивается > 20 файлов

**Решение**:

1. Вернитесь к Шагу 2 (сводный план)
2. Разбейте задачу на более мелкие подзадачи
3. Обновите TaskSummary.md
4. Создайте отдельные планы для каждой подзадачи

---

### Можно ли разрабатывать несколько задач параллельно?

**Можно**, если:

- Задачи независимы (нет общих файлов)
- Работают разные разработчики
- Используются отдельные git ветки

**Не рекомендуется**, если:

- Задачи зависят друг от друга
- Изменяются одни и те же файлы
- Работает один разработчик

**Совет**: Завершите одну задачу полностью (код + тесты + коммит) перед началом следующей.

---

## Технические вопросы

### PHPStan выдает ошибки после работы агента

**Причины**:

1. Агент не учел все типы
2. Используются устаревшие сигнатуры
3. Конфликт с существующим кодом

**Решение**:

Агент `phpstan-developer` автоматически исправляет ошибки. Если не помогло:

1. Посмотрите ошибки: `make php-run CMD="vendor/bin/phpstan analyse --level=8"`
2. Запустите агента повторно с контекстом ошибок
3. Если ошибки сложные, исправьте вручную

---

### Тесты не проходят после написания агентом

**Причины**:

1. Код не соответствует ожиданиям тестов
2. Тесты написаны некорректно
3. Недостающие зависимости (моки, фикстуры)

**Решение**:

1. Запустите тесты: `make php-run CMD="vendor/bin/phpunit"`
2. Изучите ошибки
3. Если проблема в коде - вернитесь к Шагу 5 (разработка)
4. Если проблема в тестах - вернитесь к Шагу 6 (тестирование)
5. Укажите агенту конкретные ошибки для исправления

---

### Как откатить изменения агента?

**Если не сделан коммит**:

```bash
git restore <file_path>  # откатить один файл
git restore .            # откатить все изменения
```

**Если коммит уже сделан**:

```bash
git revert HEAD          # создать новый коммит, отменяющий изменения
git reset --hard HEAD~1  # удалить последний коммит (осторожно!)
```

---

## Вопросы по архитектуре

### Почему используется Clean Architecture + CQRS?

**Clean Architecture** обеспечивает:

- Независимость от фреймворка
- Тестируемость без UI и БД
- Четкое разделение слоев

**CQRS** обеспечивает:

- Разделение чтения и записи
- Оптимизацию запросов
- Масштабируемость

**Результат**: Код легко поддерживать, тестировать и развивать.

---

### Что такое модульный монолит?

**Модульный монолит** - это:

- Единое приложение (монолит)
- Разделенное на независимые модули
- Каждый модуль имеет свою Domain, Application, Infrastructure

**Преимущества**:

- Проще, чем микросервисы
- Легче разрабатывать и тестировать
- Можно выделить в микросервис позже

**Структура**:

```text
backend/src/
├── Currency/      # Модуль 1
│   ├── Domain/
│   ├── Application/
│   └── Infrastructure/
└── User/          # Модуль 2
    ├── Domain/
    ├── Application/
    └── Infrastructure/
```

---

## Вопросы по документации

### Нужно ли создавать документацию для каждого модуля?

**Да, рекомендуется!**

**Техническая документация** (Readme.md):

- Описывает, как работает модуль
- Полезна разработчикам
- Создается после реализации

**Архитектурная документация** (DocHub):

- Описывает, как модуль вписывается в систему
- Полезна архитекторам и новым разработчикам
- Обновляется при каждом изменении

---

### Что делать, если документация устарела?

**Проблема**: Код изменился, а документация нет.

**Решение**:

1. Периодически запускайте `tech-doc-writer` для обновления Readme.md
2. Запускайте `arch-doc-writer` после крупных изменений
3. Включите обновление документации в Definition of Done

**Автоматизация** (будущее):

- Pre-commit hook для проверки актуальности документации
- CI/CD проверка соответствия кода и документации

---

## Вопросы по производительности

### Сколько времени занимает полный цикл разработки?

**Для небольшой фичи** (3 задачи):

- Шаг 1: Спецификация: ~10 минут
- Шаг 2: Сводный план: ~10 минут
- Шаги 3-4: Планы разработки и тестирования: ~30 минут (по 5 мин × 3 задачи × 2)
- Шаг 5: Разработка кода: ~1-1.5 часа (20-30 мин × 3 задачи)
- Шаг 6: Написание тестов: ~1-1.5 часа (20-30 мин × 3 задачи)
- Шаги 7-8: Документация: ~30 минут

**Итого**: ~3.5-4.5 часа

**Для крупного эпика** (3 этапа, по 3 задачи):

- Шаг 0: Эпик: ~15 минут
- 3 × (этап с 3 задачами) = ~10.5-13.5 часов

**Итого**: ~10.5-13.5 часов (вместо 40-60 часов вручную)

---

### Как ускорить процесс?

**Оптимизация**:

1. **Создавайте детальные спецификации сразу** - меньше вопросов от агентов
2. **Используйте шаблоны** - копируйте структуру из примеров
3. **Параллельная разработка** - разные задачи в разных ветках
4. **Переиспользуйте компоненты** - не изобретайте велосипед

**Не пытайтесь ускорить**:

- Тестирование (покрытие < 75% - плохо)
- Ревью (пропуск ревью приведет к багам)
- Документацию (придется писать позже, когда забудете детали)

---

## Устранение неполадок

### Агент зациклился и не завершает работу

**Причины**:

1. Слишком сложная задача
2. Нехватка контекста
3. Конфликтующие требования

**Решение**:

1. Остановите агента (Ctrl+C)
2. Упростите задачу - разбейте на подзадачи
3. Предоставьте больше контекста
4. Проверьте, нет ли противоречий в требованиях

---

### Агент создает код не в том месте

**Причины**:

1. Неправильно указан модуль в спецификации
2. Агент не понял структуру проекта
3. Путь в плане разработки некорректен

**Решение**:

1. Проверьте TaskX_TaskForDev.md - там должны быть полные пути
2. Укажите агенту правильную структуру модуля
3. Приведите примеры существующих файлов

---

### Агент не соблюдает архитектурные принципы

**Причины**:

1. Architecture.md не актуален
2. Агент не прочитал правила
3. Требования конфликтуют с архитектурой

**Решение**:

1. Обновите `.ai/rules/Architecture.md`
2. Явно укажите агенту: "Следуй правилам из Architecture.md"
3. В плане разработки укажите конкретные паттерны

---

## Дополнительные ресурсы

**Документация**:

- [Quick Start Guide](QuickStartGuide.md) - подробное руководство
- [Примеры файлов](filled-examples/) - реальные примеры
- [Чеклист](QuickStartChecklist.md) - быстрая шпаргалка

**Внешние ресурсы**:

- Clean Architecture: <https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>
- CQRS: <https://martinfowler.com/bliki/CQRS.html>
- DocHub: <https://dochub.info/>

---

## Не нашли ответ?

1. Проверьте [основную документацию](../Readme.md)
2. Изучите [документацию агентов](../agents/)
3. Посмотрите [примеры команд](../commands/)
4. Создайте issue в репозитории проекта
